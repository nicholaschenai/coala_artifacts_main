{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nTests failed:\nNone",
    "code": "\ndef heap_sort(array):\n    # Build a max heap from the array\n    def build_max_heap(array):\n        # Start from the last non-leaf node and heapify each node\n        for i in range(len(array) // 2 - 1, -1, -1):\n            heapify(array, i, len(array))\n\n    # Heapify a subtree rooted at index 'index'\n    def heapify(array, index, heap_size):\n        largest = index  # Initialize largest as root\n        left = 2 * index + 1  # left child index\n        right = 2 * index + 2  # right child index\n\n        # If left child is larger than root\n        if left < heap_size and array[left] > array[largest]:\n            largest = left\n\n        # If right child is larger than largest so far\n        if right < heap_size and array[right] > array[largest]:\n            largest = right\n\n        # If largest is not root, swap and continue heapifying\n        if largest != index:\n            array[index], array[largest] = array[largest], array[index]  # Swap\n            heapify(array, largest, heap_size)\n\n    # Main function logic\n    build_max_heap(array)  # Step 1: Build a max heap\n    # Step 2: One by one extract elements from the heap\n    for i in range(len(array) - 1, 0, -1):\n        array[0], array[i] = array[i], array[0]  # Swap\n        heapify(array, 0, i)  # Heapify the root element\n\n    return array  # Return the sorted array\n",
    "full_code": "\ndef heap_sort(array):\n    # Build a max heap from the array\n    def build_max_heap(array):\n        # Start from the last non-leaf node and heapify each node\n        for i in range(len(array) // 2 - 1, -1, -1):\n            heapify(array, i, len(array))\n\n    # Heapify a subtree rooted at index 'index'\n    def heapify(array, index, heap_size):\n        largest = index  # Initialize largest as root\n        left = 2 * index + 1  # left child index\n        right = 2 * index + 2  # right child index\n\n        # If left child is larger than root\n        if left < heap_size and array[left] > array[largest]:\n            largest = left\n\n        # If right child is larger than largest so far\n        if right < heap_size and array[right] > array[largest]:\n            largest = right\n\n        # If largest is not root, swap and continue heapifying\n        if largest != index:\n            array[index], array[largest] = array[largest], array[index]  # Swap\n            heapify(array, largest, heap_size)\n\n    # Main function logic\n    build_max_heap(array)  # Step 1: Build a max heap\n    # Step 2: One by one extract elements from the heap\n    for i in range(len(array) - 1, 0, -1):\n        array[0], array[i] = array[i], array[0]  # Swap\n        heapify(array, 0, i)  # Heapify the root element\n\n    return array  # Return the sorted array\n",
    "reward": true,
    "program_code": "\ndef heap_sort(array):\n    # Build a max heap from the array\n    def build_max_heap(array):\n        # Start from the last non-leaf node and heapify each node\n        for i in range(len(array) // 2 - 1, -1, -1):\n            heapify(array, i, len(array))\n\n    # Heapify a subtree rooted at index 'index'\n    def heapify(array, index, heap_size):\n        largest = index  # Initialize largest as root\n        left = 2 * index + 1  # left child index\n        right = 2 * index + 2  # right child index\n\n        # If left child is larger than root\n        if left < heap_size and array[left] > array[largest]:\n            largest = left\n\n        # If right child is larger than largest so far\n        if right < heap_size and array[right] > array[largest]:\n            largest = right\n\n        # If largest is not root, swap and continue heapifying\n        if largest != index:\n            array[index], array[largest] = array[largest], array[index]  # Swap\n            heapify(array, largest, heap_size)\n\n    # Main function logic\n    build_max_heap(array)  # Step 1: Build a max heap\n    # Step 2: One by one extract elements from the heap\n    for i in range(len(array) - 1, 0, -1):\n        array[0], array[i] = array[i], array[0]  # Swap\n        heapify(array, 0, i)  # Heapify the root element\n\n    return array  # Return the sorted array\n",
    "program_name": "heap_sort",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**: The task is to create a function that sorts a given list of numbers in ascending order. The function should implement a sorting algorithm and return the sorted list.\n\n2. **Conceptualize a solution first in plain English**: One effective way to sort a list is to use the heap sort algorithm. This algorithm involves building a binary heap from the list and then repeatedly extracting the maximum element from the heap to build the sorted list. The process consists of two main phases: heap construction and heap extraction.\n\n3. **Write a pseudocode solution**:\n   ```\n   function heap_sort(array):\n       build a max heap from the array\n       for i from length(array) - 1 down to 1:\n           swap array[0] with array[i]\n           heapify the reduced heap\n       return the sorted array\n\n   function build_max_heap(array):\n       for i from length(array) // 2 - 1 down to 0:\n           heapify(array, i, length(array))\n\n   function heapify(array, index, heap_size):\n       largest = index\n       left = 2 * index + 1\n       right = 2 * index + 2\n       if left < heap_size and array[left] > array[largest]:\n           largest = left\n       if right < heap_size and array[right] > array[largest]:\n           largest = right\n       if largest != index:\n           swap array[index] with array[largest]\n           heapify(array, largest, heap_size)\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\ndef heap_sort(array):\n    # Build a max heap from the array\n    def build_max_heap(array):\n        # Start from the last non-leaf node and heapify each node\n        for i in range(len(array) // 2 - 1, -1, -1):\n            heapify(array, i, len(array))\n\n    # Heapify a subtree rooted at index 'index'\n    def heapify(array, index, heap_size):\n        largest = index  # Initialize largest as root\n        left = 2 * index + 1  # left child index\n        right = 2 * index + 2  # right child index\n\n        # If left child is larger than root\n        if left < heap_size and array[left] > array[largest]:\n            largest = left\n\n        # If right child is larger than largest so far\n        if right < heap_size and array[right] > array[largest]:\n            largest = right\n\n        # If largest is not root, swap and continue heapifying\n        if largest != index:\n            array[index], array[largest] = array[largest], array[index]  # Swap\n            heapify(array, largest, heap_size)\n\n    # Main function logic\n    build_max_heap(array)  # Step 1: Build a max heap\n    # Step 2: One by one extract elements from the heap\n    for i in range(len(array) - 1, 0, -1):\n        array[0], array[i] = array[i], array[0]  # Swap\n        heapify(array, 0, i)  # Heapify the root element\n\n    return array  # Return the sorted array\n```",
    "no_parent": true,
    "dependency_used": false
}