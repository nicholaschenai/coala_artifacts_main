INFO - [test iter]: 24/378

INFO - The task prompt is Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Write a function to calculate whether the matrix is a magic square....

INFO - Attempting task_id Mbpp/129
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] Mbpp/129 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Write a function to calculate whether the matrix is a magic square.
assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True
"""

[END PROBLEM]

INFO - [Task id] Mbpp/129 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] Mbpp/129 [generation text] 1. **Restate the problem in plain English:**
   We need to create a function that checks if a given square matrix (2D list) is a magic square. A magic square is a grid where the sum of the numbers in each row, each column, and both main diagonals are all the same.

2. **Conceptualize a solution first in plain English:**
   To determine if a matrix is a magic square, we will:
   - First, check if the matrix is square (the number of rows should equal the number of columns).
   - Calculate the sum of the first row, which will be our target sum.
   - Check if the sum of each row matches the target sum.
   - Check if the sum of each column matches the target sum.
   - Calculate the sums of the two main diagonals and check if they match the target sum.
   - If all these conditions are satisfied, the matrix is a magic square.

3. **Write a pseudocode solution:**
   ```
   function magic_square_test(matrix):
       if matrix is not square:
           return False
       target_sum = sum of the first row
       for each row in matrix:
           if sum of row != target_sum:
               return False
       for each column in matrix:
           if sum of column != target_sum:
               return False
       diagonal1_sum = sum of the main diagonal
       diagonal2_sum = sum of the other diagonal
       if diagonal1_sum != target_sum or diagonal2_sum != target_sum:
           return False
       return True
   ```

4. **Output the final Python 3 solution with your solution steps in comments:**
```python
def magic_square_test(matrix):
    # Check if the matrix is square
    n = len(matrix)
    if any(len(row) != n for row in matrix):
        return False
    
    # Calculate the target sum from the first row
    target_sum = sum(matrix[0])
    
    # Check the sum of each row
    for row in matrix:
        if sum(row) != target_sum:
            return False
    
    # Check the sum of each column
    for col in range(n):
        if sum(matrix[row][col] for row in range(n)) != target_sum:
            return False
    
    # Check the sum of the main diagonal
    diagonal1_sum = sum(matrix[i][i] for i in range(n))
    # Check the sum of the other diagonal
    diagonal2_sum = sum(matrix[i][n - 1 - i] for i in range(n))
    
    # Check if both diagonal sums match the target sum
    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:
        return False
    
    # If all checks passed, it is a magic square
    return True
```
INFO - [35m Rollout attempt 1/4[0m
INFO - [33m Retrieving 3 entries for db: semantic 
 [0m
INFO - Retrieved (score=0.4673):
Title: 15 Puzzle Game: Existence Of The Solution
Part: 1/1
# 15 Puzzle Game: Existence Of The Solution

This game is played on a $4 \times 4$ board. On this board there are $15$ playing tiles numbered from 1 to 15. One cell is left empty (denoted by 0). You need to get the board to the position p...


INFO - Retrieved (score=0.4740):
Chapter: Matrices
Section: Operations
Part: 1/1
\chapter{Matrices}

\index{matrix}

A \key{matrix} is a mathematical concept
that corresponds to a two-dimensional array
in programming. For example,
\[
A = 
 \begin{bmatrix}
  6 & 13 & 7 & 4 \\
  7 & 0 & 8 & 2 \\
  9 & 5 & 4 & 18 \\
 \end{bmatrix}
...


INFO - Retrieved (score=0.5077):
Title: Finding the largest zero submatrix
Part: 1/1
# Finding the largest zero submatrix

You are given a matrix with `n` rows and `m` columns. Find the largest submatrix consisting of only zeros (a submatrix is a rectangular area of the matrix).

## Algorithm

Elements of the matrix will be `a[i...


INFO - Retrieved (score=0.4673): 
[Textbook Reference Material]:
    Title: 15 Puzzle Game: Existence Of The Solution
    Part: 1/1
    # 15 Puzzle Game: Existence Of The Solution

    This game is played on a $4 \times 4$ board. On this board there are $15$ playing tiles numbered from 1 to 15. One cell is left empty (denoted by...
INFO - Retrieved (score=0.4740): 
[Textbook Reference Material]:
    Chapter: Matrices
    Section: Operations
    Part: 1/1
    \chapter{Matrices}

    \index{matrix}

    A \key{matrix} is a mathematical concept
    that corresponds to a two-dimensional array
    in programming. For example,
    \[
    A = 
     \begin{bmatrix...
INFO - Retrieved (score=0.5077): 
[Textbook Reference Material]:
    Title: Finding the largest zero submatrix
    Part: 1/1
    # Finding the largest zero submatrix

    You are given a matrix with `n` rows and `m` columns. Find the largest submatrix consisting of only zeros (a submatrix is a rectangular area of the matrix).

 ...
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] Mbpp/129 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Write a function to calculate whether the matrix is a magic square.
assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True
"""

[END PROBLEM]

INFO - [Task id] Mbpp/129 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] Mbpp/129 [prompt] 
Also, here are some of your memories.
Feel free to use the given information to aid your problem solving process if necessary.
Do not confuse the memories with the problem statement.

## Memories

[Textbook Reference Material]:
    Title: 15 Puzzle Game: Existence Of The Solution
    Part: 1/1
    # 15 Puzzle Game: Existence Of The Solution

    This game is played on a $4 \times 4$ board. On this board there are $15$ playing tiles numbered from 1 to 15. One cell is left empty (denoted by 0). You need to get the board to the position presented below by repeatedly moving one of the tiles to the free space:

    $$\begin{matrix} 1 & 2 & 3 & 4 \\ 5 & 6 & 7 & 8 \\ 9 & 10 & 11 & 12 \\ 13 & 14 & 15 & 0 \end{matrix}$$

    The game "15 Puzzle‚Äù was created by Noyes Chapman in 1880.

    ## Existence Of The Solution

    Let's consider this problem: given a position on the board, determine whether a sequence of moves which leads to a solution exists.

    Suppose we have some position on the board:

    $$\begin{matrix} a_1 & a_2 & a_3 & a_4 \\ a_5 & a_6 & a_7 & a_8 \\ a_9 & a_{10} & a_{11} & a_{12} \\ a_{13} & a_{14} & a_{15} & a_{16} \end{matrix}$$

    where one of the elements equals zero and indicates an empty cell $a_z  = 0$

    Let‚Äôs consider the permutation:

    $$a_1 a_2 ... a_{z-1} a_{z+1} ... a_{15} a_{16}$$

    i.e. the permutation of numbers corresponding to the position on the board without a zero element

    Let $N$ be the number of inversions in this permutation (i.e. the number of such elements $a_i$  and $a_j$  that $i < j$, but $a_i  > a_j$).

    Suppose $K$ is an index of a row where the empty element is located (i.e. using our convention, $K = (z - 1) \div \ 4 + 1$).

    Then, **the solution exists iff $N + K$ is even**.

    ## Implementation

    The algorithm above can be illustrated with the following program code:

    ```cpp
    int a[16];
    for (int i=0; i<16; ++i)
        cin >> a[i];

    int inv = 0;
    for (int i=0; i<16; ++i)
        if (a[i])
            for (int j=0; j<i; ++j)
                if (a[j] > a[i])
                    ++inv;
    for (int i=0; i<16; ++i)
        if (a[i] == 0)
            inv += 1 + i / 4;

    puts ((inv & 1) ? "No Solution" : "Solution Exists");
    ```

    ## Proof

    In 1879 Johnson proved that if $N + K$ is odd, then the solution doesn‚Äôt exist, and in the same year Story proved that all positions when $N + K$ is even have a solution.

    However, all these proofs were quite complex.

    In 1999 Archer proposed a much simpler proof (you can download his article [here](http://www.cs.cmu.edu/afs/cs/academic/class/15859-f01/www/notes/15-puzzle.pdf)).
[/Textbook Reference Material]


[Textbook Reference Material]:
    Chapter: Matrices
    Section: Operations
    Part: 1/1
    \chapter{Matrices}

    \index{matrix}

    A \key{matrix} is a mathematical concept
    that corresponds to a two-dimensional array
    in programming. For example,
    \[
    A = 
     \begin{bmatrix}
      6 & 13 & 7 & 4 \\
      7 & 0 & 8 & 2 \\
      9 & 5 & 4 & 18 \\
     \end{bmatrix}
    \]
    is a matrix of size $3 \times 4$, i.e.,
    it has 3 rows and 4 columns.
    The notation $[i,j]$ refers to
    the element in row $i$ and column $j$
    in a matrix.
    For example, in the above matrix,
    $A[2,3]=8$ and $A[3,1]=9$.

    \index{vector}

    A special case of a matrix is a \key{vector}
    that is a one-dimensional matrix of size $n \times 1$.
    For example,
    \[
    V =
    \begin{bmatrix}
    4 \\
    7 \\
    5 \\
    \end{bmatrix}
    \]
    is a vector that contains three elements.

    \index{transpose}

    The \key{transpose} $A^T$ of a matrix $A$
    is obtained when the rows and columns of $A$
    are swapped, i.e., $A^T[i,j]=A[j,i]$:
    \[
    A^T = 
     \begin{bmatrix}
      6 & 7 & 9 \\
      13 & 0 & 5 \\
      7 & 8 & 4 \\
      4 & 2 & 18 \\
     \end{bmatrix}
    \]

    \index{square matrix}

    A matrix is a \key{square matrix} if it
    has the same number of rows and columns.
    For example, the following matrix is a
    square matrix:

    \[
    S = 
     \begin{bmatrix}
      3 & 12 & 4  \\
      5 & 9 & 15  \\
      0 & 2 & 4 \\
     \end{bmatrix}
    \]

    \section{Operations}

    The sum $A+B$ of matrices $A$ and $B$
    is defined if the matrices are of the same size.
    The result is a matrix where each element
    is the sum of the corresponding elements
    in $A$ and $B$.

    For example,
    \[
     \begin{bmatrix}
      6 & 1 & 4 \\
      3 & 9 & 2 \\
     \end{bmatrix}
    +
     \begin{bmatrix}
      4 & 9 & 3 \\
      8 & 1 & 3 \\
     \end{bmatrix}
    =
     \begin{bmatrix}
      6+4 & 1+9 & 4+3 \\
      3+8 & 9+1 & 2+3 \\
     \end{bmatrix}
    =
     \begin{bmatrix}
      10 & 10 & 7 \\
      11 & 10 & 5 \\
     \end{bmatrix}.
    \]

    Multiplying a matrix $A$ by a value $x$ means
    that each element of $A$ is multiplied by $x$.
    For example,
    \[
     2 \cdot \begin{bmatrix}
      6 & 1 & 4 \\
      3 & 9 & 2 \\
     \end{bmatrix}
    =
     \begin{bmatrix}
      2 \cdot 6 & 2\cdot1 & 2\cdot4 \\
      2\cdot3 & 2\cdot9 & 2\cdot2 \\
     \end{bmatrix}
    =
     \begin{bmatrix}
      12 & 2 & 8 \\
      6 & 18 & 4 \\
     \end{bmatrix}.
    \]

    \subsubsection{Matrix multiplication}

    \index{matrix multiplication}

    The product $AB$ of matrices $A$ and $B$
    is defined if $A$ is of size $a \times n$
    and $B$ is of size $n \times b$, i.e.,
    the width of $A$ equals the height of $B$.
    The result is a matrix of size $a \times b$
    whose elements are calculated using the formula
    \[
    AB[i,j] = \sum_{k=1}^n A[i,k] \cdot B[k,j].
    \]

    The idea is that each element of $AB$
    is a sum of products of elements of $A$ and $B$
    according to the following picture:

    \begin{center}
    \begin{tikzpicture}[scale=0.5]
    \draw (0,0) grid (4,3);
    \draw (5,0) grid (10,3);
    \draw (5,4) grid (10,8);

    \node at (2,-1) {$A$};
    \node at (7.5,-1) {$AB$};
    \node at (11,6) {$B$};

    \draw[thick,->,red,line width=2pt] (0,1.5) -- (4,1.5);
    \draw[thick,->,red,line width=2pt] (6.5,8) -- (6.5,4);
    \draw[thick,red,line width=2pt] (6.5,1.5) circle (0.4);
    \end{tikzpicture}
    \end{center}

    For example,

    \[
     \begin{bmatrix}
      1 & 4 \\
      3 & 9 \\
      8 & 6 \\
     \end{bmatrix}
    \cdot
     \begin{bmatrix}
      1 & 6 \\
      2 & 9 \\
     \end{bmatrix}
    =
     \begin{bmatrix}
      1 \cdot 1 + 4 \cdot 2 & 1 \cdot 6 + 4 \cdot 9 \\
      3 \cdot 1 + 9 \cdot 2 & 3 \cdot 6 + 9 \cdot 9 \\
      8 \cdot 1 + 6 \cdot 2 & 8 \cdot 6 + 6 \cdot 9 \\
     \end{bmatrix}
    =
     \begin{bmatrix}
      9 & 42 \\
      21 & 99 \\
      20 & 102 \\
     \end{bmatrix}.
    \]

    Matrix multiplication is associative,
    so $A(BC)=(AB)C$ holds,
    but it is not commutative,
    so $AB = BA$ does not usually hold.

    \index{identity matrix}

    An \key{identity matrix} is a square matrix
    where each element on the diagonal is 1
    and all other elements are 0.
    For example, the following matrix
    is the $3 \times 3$ identity matrix:
    \[
     I = \begin{bmatrix}
      1 & 0 & 0 \\
      0 & 1 & 0 \\
      0 & 0 & 1 \\
     \end{bmatrix}
    \]

    \begin{samepage}
    Multiplying a matrix by an identity matrix
    does not change it. For example,
    \[
     \begin{bmatrix}
      1 & 0 & 0 \\
      0 & 1 & 0 \\
      0 & 0 & 1 \\
     \end{bmatrix}
    \cdot
     \begin{bmatrix}
      1 & 4 \\
      3 & 9 \\
      8 & 6 \\
     \end{bmatrix}
    =
     \begin{bmatrix}
      1 & 4 \\
      3 & 9 \\
      8 & 6 \\
     \end{bmatrix} \hspace{10px} \textrm{and} \hspace{10px}
     \begin{bmatrix}
      1 & 4 \\
      3 & 9 \\
      8 & 6 \\
     \end{bmatrix}
    \cdot
     \begin{bmatrix}
      1 & 0 \\
      0 & 1 \\
     \end{bmatrix}
    =
     \begin{bmatrix}
      1 & 4 \\
      3 & 9 \\
      8 & 6 \\
     \end{bmatrix}.
    \]
    \end{samepage}

    Using a straightforward algorithm,
    we can calculate the product of
    two $n \times n$ matrices
    in $O(n^3)$ time.
    There are also more efficient algorithms
    for matrix multiplication\footnote{The first such
    algorithm was Strassen's algorithm,
    published in 1969 \cite{str69},
    whose time complexity is $O(n^{2.80735})$;
    the best current algorithm \cite{gal14}
    works in $O(n^{2.37286})$ time.},
    but they are mostly of theoretical interest
    and such algorithms are not necessary
    in competitive programming.


    \subsubsection{Matrix power}

    \index{matrix power}

    The power $A^k$ of a matrix $A$ is defined
    if $A$ is a square matrix.
    The definition is based on matrix multiplication:
    \[ A^k = \underbrace{A \cdot A \cdot A \cdots A}_{\textrm{$k$ times}} \]
    For example,

    \[
     \begin{bmatrix}
      2 & 5 \\
      1 & 4 \\
     \end{bmatrix}^3 =
     \begin{bmatrix}
      2 & 5 \\
      1 & 4 \\
     \end{bmatrix} \cdot
     \begin{bmatrix}
      2 & 5 \\
      1 & 4 \\
     \end{bmatrix} \cdot
     \begin{bmatrix}
      2 & 5 \\
      1 & 4 \\
     \end{bmatrix} =
     \begin{bmatrix}
      48 & 165 \\
      33 & 114 \\
     \end{bmatrix}.
    \]
    In addition, $A^0$ is an identity matrix. For example,
    \[
     \begin{bmatrix}
      2 & 5 \\
      1 & 4 \\
     \end{bmatrix}^0 =
     \begin{bmatrix}
      1 & 0 \\
      0 & 1 \\
     \end{bmatrix}.
    \]

    The matrix $A^k$ can be efficiently calculated
    in $O(n^3 \log k)$ time using the
    algorithm in Chapter 21.2. For example,
    \[
     \begin{bmatrix}
      2 & 5 \\
      1 & 4 \\
     \end{bmatrix}^8 =
     \begin{bmatrix}
      2 & 5 \\
      1 & 4 \\
     \end{bmatrix}^4 \cdot
     \begin{bmatrix}
      2 & 5 \\
      1 & 4 \\
     \end{bmatrix}^4.
    \]

    \subsubsection{Determinant}

    \index{determinant}

    The \key{determinant} $\det(A)$ of a matrix $A$
    is defined if $A$ is a square matrix.
    If $A$ is of size $1 \times 1$,
    then $\det(A)=A[1,1]$.
    The determinant of a larger matrix is
    calculated recursively using the formula \index{cofactor}
    \[\det(A)=\sum_{j=1}^n A[1,j] C[1,j],\]
    where $C[i,j]$ is the \key{cofactor} of $A$
    at $[i,j]$.
    The cofactor is calculated using the formula
    \[C[i,j] = (-1)^{i+j} \det(M[i,j]),\]
    where $M[i,j]$ is obtained by removing
    row $i$ and column $j$ from $A$.
    Due to the coefficient $(-1)^{i+j}$ in the cofactor,
    every other determinant is positive
    and negative.
    For example,
    \[
    \det(
     \begin{bmatrix}
      3 & 4 \\
      1 & 6 \\
     \end{bmatrix}
    ) = 3 \cdot 6 - 4 \cdot 1 = 14 
    \]
    and
    \[
    \det(
     \begin{bmatrix}
      2 & 4 & 3 \\
      5 & 1 & 6 \\
      7 & 2 & 4 \\
     \end{bmatrix}
    ) = 
    2 \cdot
    \det(
     \begin{bmatrix}
      1 & 6 \\
      2 & 4 \\
     \end{bmatrix}
    )
    -4 \cdot
    \det(
     \begin{bmatrix}
      5 & 6 \\
      7 & 4 \\
     \end{bmatrix}
    )
    +3 \cdot
    \det(
     \begin{bmatrix}
      5 & 1 \\
      7 & 2 \\
     \end{bmatrix}
    ) = 81.
    \]

    \index{inverse matrix}

    The determinant of $A$ tells us
    whether there is an \key{inverse matrix}
    $A^{-1}$ such that $A \cdot A^{-1} = I$,
    where $I$ is an identity matrix.
    It turns out that $A^{-1}$ exists
    exactly when $\det(A) \neq 0$,
    and it can be calculated using the formula

    \[A^{-1}[i,j] = \frac{C[j,i]}{det(A)}.\]

    For example,

    \[
    \underbrace{
     \begin{bmatrix}
      2 & 4 & 3\\
      5 & 1 & 6\\
      7 & 2 & 4\\
     \end{bmatrix}
    }_{A}
    \cdot
    \underbrace{
     \frac{1}{81}
     \begin{bmatrix}
       -8 & -10 & 21 \\
       22 & -13 & 3 \\
       3 & 24 & -18 \\
     \end{bmatrix}
    }_{A^{-1}}
    =
    \underbrace{
     \begin{bmatrix}
      1 & 0 & 0 \\
      0 & 1 & 0 \\
      0 & 0 & 1 \\
     \end{bmatrix}
    }_{I}.
    \]
[/Textbook Reference Material]


[Textbook Reference Material]:
    Title: Finding the largest zero submatrix
    Part: 1/1
    # Finding the largest zero submatrix

    You are given a matrix with `n` rows and `m` columns. Find the largest submatrix consisting of only zeros (a submatrix is a rectangular area of the matrix).

    ## Algorithm

    Elements of the matrix will be `a[i][j]`, where `i = 0...n - 1`, `j = 0... m - 1`. For simplicity, we will consider all non-zero elements equal to 1.

    ### Step 1: Auxiliary dynamic

    First, we calculate the following auxiliary matrix: `d[i][j]`, nearest row that has a 1 above `a[i][j]`. Formally speaking, `d[i][j]` is the largest row number (from `0` to `i - 1`), in which there is a element equal to `1` in the `j`-th column. 
    While iterating from top-left to bottom-right, when we stand in row `i`, we know the values from the previous row, so, it is enough to update just the elements with value `1`. We can save the values in a simple array `d[i]`, `i = 1...m - 1`, because in the further algorithm we will process the matrix one row at a time and only need the values of the current row.

    ```cpp
    vector<int> d(m, -1);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (a[i][j] == 1) {
                d[j] = i;
            }
        }
    }
    ```

    ### Step 2: Problem solving

    We can solve the problem in $O(n m^2)$ iterating through rows, considering every possible left and right columns for a submatrix. The bottom of the rectangle will be the current row, and using `d[i][j]` we can find the top row. However, it is possible to go further and significantly improve the complexity of the solution.

    It is clear that the desired zero submatrix is bounded on all four sides by some ones, which prevent it from increasing in size and improving the answer. Therefore,  we will not miss the answer if we act as follows: for every cell `j` in row `i` (the bottom row of a potential zero submatrix) we will have `d[i][j]` as the top row of the current zero submatrix. It now remains to determine the optimal left and right boundaries of the zero submatrix, i.e. maximally push this submatrix to the left and right of the `j`-th column. 

    What does it mean to push the maximum to the left? It means to find an index `k1` for which `d[i][k1] > d[i][j]`, and at the same time `k1` - the closest one to the left of the index `j`. It is clear that then `k1 + 1` gives the number of the left column of the required zero submatrix. If there is no such index at all, then put `k1` = `-1`(this means that we were able to extend the current zero submatrix to the left all the way to the border of matrix `a`).

    Symmetrically, you can define an index `k2` for the right border: this is the closest index to the right of `j` such that `d[i][k2] > d[i][j]` (or `m`, if there is no such index).

    So, the indices `k1` and `k2`, if we learn to search for them effectively, will give us all the necessary information about the current zero submatrix. In particular, its area will be equal to `(i - d[i][j]) * (k2 - k1 - 1)`.

    How to look for these indexes `k1` and `k2` effectively with fixed `i` and `j`? We can do that in $O(1)$ on average.

    To achieve such complexity, you can use the stack as follows. Let's first learn how to search for an index `k1`, and save its value for each index `j` within the current row `i` in matrix `d1[i][j]`. To do this, we will look through all the columns `j` from left to right, and we will store in the stack only those columns that have `d[][]` strictly greater than `d[i][j]`. It is clear that when moving from a column `j` to the next column, it is necessary to update the content of the stack. When there is an inappropriate element at the top of the stack (i.e. `d[][] <= d[i][j]`) pop it. It is easy to understand that it is enough to remove from the stack only from its top, and from none of its other places (because the stack will contain an increasing `d` sequence of columns).

    The value `d1[i][j]` for each `j` will be equal to the value lying at that moment on top of the stack.

    The dynamics `d2[i][j]` for finding the indices `k2` is considered similar, only you need to view the columns from right to left.

    It is clear that since there are exactly `m` pieces added to the stack on each line, there could not be more deletions either, the sum of complexities will be linear, so the final complexity of the algorithm is $O(nm)$.

    It should also be noted that this algorithm consumes $O(m)$ memory (not counting the input data - the matrix `a[][]`).

    ### Implementation

    ```cpp
    int zero_matrix(vector<vector<int>> a) {
        int n = a.size();
        int m = a[0].size();

        int ans = 0;
        vector<int> d(m, -1), d1(m), d2(m);
        stack<int> st;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (a[i][j] == 1)
                    d[j] = i;
            }

            for (int j = 0; j < m; ++j) {
                while (!st.empty() && d[st.top()] <= d[j])
                    st.pop();
                d1[j] = st.empty() ? -1 : st.top();
                st.push(j);
            }
            while (!st.empty())
                st.pop();

            for (int j = m - 1; j >= 0; --j) {
                while (!st.empty() && d[st.top()] <= d[j])
                    st.pop();
                d2[j] = st.empty() ? m : st.top();
                st.push(j);
            }
            while (!st.empty())
                st.pop();

            for (int j = 0; j < m; ++j)
                ans = max(ans, (i - d[j]) * (d2[j] - d1[j] - 1));
        }
        return ans;
    }
    ```
[/Textbook Reference Material]


INFO - [Task id] Mbpp/129 [generation text] 1. **Restate the problem in plain English**: 
   We need to create a function that checks if a given square matrix is a magic square. A magic square is a grid where the sum of the numbers in each row, each column, and both main diagonals are the same.

2. **Conceptualize a solution first in plain English**: 
   To determine if a matrix is a magic square, we will:
   - Calculate the sum of the first row to establish the target sum.
   - Check if all rows have the same sum as the target.
   - Check if all columns have the same sum as the target.
   - Check if both diagonals have the same sum as the target.
   - If all these conditions are met, the matrix is a magic square.

3. **Write a pseudocode solution**:
   ```
   function magic_square_test(matrix):
       if matrix is empty or not square:
           return False
       
       target_sum = sum of the first row
       
       for each row in matrix:
           if sum of row != target_sum:
               return False
       
       for each column in matrix:
           if sum of column != target_sum:
               return False
       
       diagonal1_sum = sum of the main diagonal
       diagonal2_sum = sum of the anti-diagonal
       
       if diagonal1_sum != target_sum or diagonal2_sum != target_sum:
           return False
       
       return True
   ```

4. **Output the final Python 3 solution with your solution steps in comments**:
```python
def magic_square_test(matrix):
    # Check if the matrix is empty or not square
    if not matrix or len(matrix) != len(matrix[0]):
        return False
    
    n = len(matrix)  # Size of the matrix
    target_sum = sum(matrix[0])  # Sum of the first row to establish the target
    
    # Check the sum of each row
    for row in matrix:
        if sum(row) != target_sum:
            return False
    
    # Check the sum of each column
    for col in range(n):
        if sum(matrix[row][col] for row in range(n)) != target_sum:
            return False
    
    # Check the sum of the main diagonal
    diagonal1_sum = sum(matrix[i][i] for i in range(n))
    # Check the sum of the anti-diagonal
    diagonal2_sum = sum(matrix[i][n - 1 - i] for i in range(n))
    
    # Check if both diagonals match the target sum
    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:
        return False
    
    return True
```
INFO - program_code:
 
def magic_square_test(matrix):
    # Check if the matrix is empty or not square
    if not matrix or len(matrix) != len(matrix[0]):
        return False
    
    n = len(matrix)  # Size of the matrix
    target_sum = sum(matrix[0])  # Sum of the first row to establish the target
    
    # Check the sum of each row
    for row in matrix:
        if sum(row) != target_sum:
            return False
    
    # Check the sum of each column
    for col in range(n):
        if sum(matrix[row][col] for row in range(n)) != target_sum:
            return False
    
    # Check the sum of the main diagonal
    diagonal1_sum = sum(matrix[i][i] for i in range(n))
    # Check the sum of the anti-diagonal
    diagonal2_sum = sum(matrix[i][n - 1 - i] for i in range(n))
    
    # Check if both diagonals match the target sum
    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:
        return False
    
    return True


INFO - program_name:
 magic_square_test

INFO - dependencies:
 []

INFO - raw_msg:
 1. **Restate the problem in plain English**: 
   We need to create a function that checks if a given square matrix is a magic square. A magic square is a grid where the sum of the numbers in each row, each column, and both main diagonals are the same.

2. **Conceptualize a solution first in plain English**: 
   To determine if a matrix is a magic square, we will:
   - Calculate the sum of the first row to establish the target sum.
   - Check if all rows have the same sum as the target.
   - Check if all columns have the same sum as the target.
   - Check if both diagonals have the same sum as the target.
   - If all these conditions are met, the matrix is a magic square.

3. **Write a pseudocode solution**:
   ```
   function magic_square_test(matrix):
       if matrix is empty or not square:
           return False
       
       target_sum = sum of the first row
       
       for each row in matrix:
           if sum of row != target_sum:
               return False
       
       for each column in matrix:
           if sum of column != target_sum:
               return False
       
       diagonal1_sum = sum of the main diagonal
       diagonal2_sum = sum of the anti-diagonal
       
       if diagonal1_sum != target_sum or diagonal2_sum != target_sum:
           return False
       
       return True
   ```

4. **Output the final Python 3 solution with your solution steps in comments**:
```python
def magic_square_test(matrix):
    # Check if the matrix is empty or not square
    if not matrix or len(matrix) != len(matrix[0]):
        return False
    
    n = len(matrix)  # Size of the matrix
    target_sum = sum(matrix[0])  # Sum of the first row to establish the target
    
    # Check the sum of each row
    for row in matrix:
        if sum(row) != target_sum:
            return False
    
    # Check the sum of each column
    for col in range(n):
        if sum(matrix[row][col] for row in range(n)) != target_sum:
            return False
    
    # Check the sum of the main diagonal
    diagonal1_sum = sum(matrix[i][i] for i in range(n))
    # Check the sum of the anti-diagonal
    diagonal2_sum = sum(matrix[i][n - 1 - i] for i in range(n))
    
    # Check if both diagonals match the target sum
    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:
        return False
    
    return True
```

INFO - no_parent:
 True

INFO - full code to be executed: 
 
def magic_square_test(matrix):
    # Check if the matrix is empty or not square
    if not matrix or len(matrix) != len(matrix[0]):
        return False
    
    n = len(matrix)  # Size of the matrix
    target_sum = sum(matrix[0])  # Sum of the first row to establish the target
    
    # Check the sum of each row
    for row in matrix:
        if sum(row) != target_sum:
            return False
    
    # Check the sum of each column
    for col in range(n):
        if sum(matrix[row][col] for row in range(n)) != target_sum:
            return False
    
    # Check the sum of the main diagonal
    diagonal1_sum = sum(matrix[i][i] for i in range(n))
    # Check the sum of the anti-diagonal
    diagonal2_sum = sum(matrix[i][n - 1 - i] for i in range(n))
    
    # Check if both diagonals match the target sum
    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:
        return False
    
    return True


INFO - obs: Note: Tests are automatically generated and can be wrong.

Tests passed:
assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True

Tests failed:
None
reward: True
done: None
info: {'individual_results': (True,)}
INFO - acc:23/24 = 95.83%
