[
    {
        "role": "system",
        "content": "\nYou are an expert programmer tasked with solving the problem below.\n\nFollow the user's instructions to solve the problem.\nThe user can ask for analysis, code, or both.\n\n## Instructions\nWhen asked to output code,\n- Make sure to wrap your code in '```python' and '```' Markdown delimiters, \n- include exactly one block of code with the entire solution\n- No outside libraries are allowed. \n- Builtins are allowed.\n- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).\n- DO NOT write any assert statements / tests.\n\n## Problem\n[BEGIN PROBLEM]\nWrite a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.\n\"\"\"\nWrite a function to calculate whether the matrix is a magic square.\nassert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n\"\"\"\n\n[END PROBLEM]\n"
    },
    {
        "role": "user",
        "content": "\n## Instructions\n\nReason through the problem and:\n1. Restate the problem in plain English\n2. Conceptualize a solution first in plain English\n3. Write a pseudocode solution\n4. Output the final Python 3 solution with your solution steps in comments.\n\nMake sure to wrap your code in '```python' and '```' Markdown delimiters, \nand include exactly one block of code with the entire solution.\n\nNo outside libraries are allowed.\nBuiltins are allowed.\n"
    },
    {
        "role": "assistant",
        "content": "1. **Restate the problem in plain English:**\n   We need to create a function that checks if a given square matrix (2D list) is a magic square. A magic square is a grid where the sum of the numbers in each row, each column, and both main diagonals are all the same.\n\n2. **Conceptualize a solution first in plain English:**\n   To determine if a matrix is a magic square, we will:\n   - First, check if the matrix is square (the number of rows should equal the number of columns).\n   - Calculate the sum of the first row, which will be our target sum.\n   - Check if the sum of each row matches the target sum.\n   - Check if the sum of each column matches the target sum.\n   - Calculate the sums of the two main diagonals and check if they match the target sum.\n   - If all these conditions are satisfied, the matrix is a magic square.\n\n3. **Write a pseudocode solution:**\n   ```\n   function magic_square_test(matrix):\n       if matrix is not square:\n           return False\n       target_sum = sum of the first row\n       for each row in matrix:\n           if sum of row != target_sum:\n               return False\n       for each column in matrix:\n           if sum of column != target_sum:\n               return False\n       diagonal1_sum = sum of the main diagonal\n       diagonal2_sum = sum of the other diagonal\n       if diagonal1_sum != target_sum or diagonal2_sum != target_sum:\n           return False\n       return True\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n```python\ndef magic_square_test(matrix):\n    # Check if the matrix is square\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False\n    \n    # Calculate the target sum from the first row\n    target_sum = sum(matrix[0])\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    diagonal1_sum = sum(matrix[i][i] for i in range(n))\n    # Check the sum of the other diagonal\n    diagonal2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    \n    # Check if both diagonal sums match the target sum\n    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:\n        return False\n    \n    # If all checks passed, it is a magic square\n    return True\n```"
    },
    {
        "role": "user",
        "content": "\nAlso, here are some of your memories.\nFeel free to use the given information to aid your problem solving process if necessary.\nDo not confuse the memories with the problem statement.\n\n## Memories\n\n[Textbook Reference Material]:\n    Title: 15 Puzzle Game: Existence Of The Solution\n    Part: 1/1\n    # 15 Puzzle Game: Existence Of The Solution\n\n    This game is played on a $4 \\times 4$ board. On this board there are $15$ playing tiles numbered from 1 to 15. One cell is left empty (denoted by 0). You need to get the board to the position presented below by repeatedly moving one of the tiles to the free space:\n\n    $$\\begin{matrix} 1 & 2 & 3 & 4 \\\\ 5 & 6 & 7 & 8 \\\\ 9 & 10 & 11 & 12 \\\\ 13 & 14 & 15 & 0 \\end{matrix}$$\n\n    The game \"15 Puzzle\u201d was created by Noyes Chapman in 1880.\n\n    ## Existence Of The Solution\n\n    Let's consider this problem: given a position on the board, determine whether a sequence of moves which leads to a solution exists.\n\n    Suppose we have some position on the board:\n\n    $$\\begin{matrix} a_1 & a_2 & a_3 & a_4 \\\\ a_5 & a_6 & a_7 & a_8 \\\\ a_9 & a_{10} & a_{11} & a_{12} \\\\ a_{13} & a_{14} & a_{15} & a_{16} \\end{matrix}$$\n\n    where one of the elements equals zero and indicates an empty cell $a_z  = 0$\n\n    Let\u2019s consider the permutation:\n\n    $$a_1 a_2 ... a_{z-1} a_{z+1} ... a_{15} a_{16}$$\n\n    i.e. the permutation of numbers corresponding to the position on the board without a zero element\n\n    Let $N$ be the number of inversions in this permutation (i.e. the number of such elements $a_i$  and $a_j$  that $i < j$, but $a_i  > a_j$).\n\n    Suppose $K$ is an index of a row where the empty element is located (i.e. using our convention, $K = (z - 1) \\div \\ 4 + 1$).\n\n    Then, **the solution exists iff $N + K$ is even**.\n\n    ## Implementation\n\n    The algorithm above can be illustrated with the following program code:\n\n    ```cpp\n    int a[16];\n    for (int i=0; i<16; ++i)\n        cin >> a[i];\n\n    int inv = 0;\n    for (int i=0; i<16; ++i)\n        if (a[i])\n            for (int j=0; j<i; ++j)\n                if (a[j] > a[i])\n                    ++inv;\n    for (int i=0; i<16; ++i)\n        if (a[i] == 0)\n            inv += 1 + i / 4;\n\n    puts ((inv & 1) ? \"No Solution\" : \"Solution Exists\");\n    ```\n\n    ## Proof\n\n    In 1879 Johnson proved that if $N + K$ is odd, then the solution doesn\u2019t exist, and in the same year Story proved that all positions when $N + K$ is even have a solution.\n\n    However, all these proofs were quite complex.\n\n    In 1999 Archer proposed a much simpler proof (you can download his article [here](http://www.cs.cmu.edu/afs/cs/academic/class/15859-f01/www/notes/15-puzzle.pdf)).\n[/Textbook Reference Material]\n\n\n[Textbook Reference Material]:\n    Chapter: Matrices\n    Section: Operations\n    Part: 1/1\n    \\chapter{Matrices}\n\n    \\index{matrix}\n\n    A \\key{matrix} is a mathematical concept\n    that corresponds to a two-dimensional array\n    in programming. For example,\n    \\[\n    A = \n     \\begin{bmatrix}\n      6 & 13 & 7 & 4 \\\\\n      7 & 0 & 8 & 2 \\\\\n      9 & 5 & 4 & 18 \\\\\n     \\end{bmatrix}\n    \\]\n    is a matrix of size $3 \\times 4$, i.e.,\n    it has 3 rows and 4 columns.\n    The notation $[i,j]$ refers to\n    the element in row $i$ and column $j$\n    in a matrix.\n    For example, in the above matrix,\n    $A[2,3]=8$ and $A[3,1]=9$.\n\n    \\index{vector}\n\n    A special case of a matrix is a \\key{vector}\n    that is a one-dimensional matrix of size $n \\times 1$.\n    For example,\n    \\[\n    V =\n    \\begin{bmatrix}\n    4 \\\\\n    7 \\\\\n    5 \\\\\n    \\end{bmatrix}\n    \\]\n    is a vector that contains three elements.\n\n    \\index{transpose}\n\n    The \\key{transpose} $A^T$ of a matrix $A$\n    is obtained when the rows and columns of $A$\n    are swapped, i.e., $A^T[i,j]=A[j,i]$:\n    \\[\n    A^T = \n     \\begin{bmatrix}\n      6 & 7 & 9 \\\\\n      13 & 0 & 5 \\\\\n      7 & 8 & 4 \\\\\n      4 & 2 & 18 \\\\\n     \\end{bmatrix}\n    \\]\n\n    \\index{square matrix}\n\n    A matrix is a \\key{square matrix} if it\n    has the same number of rows and columns.\n    For example, the following matrix is a\n    square matrix:\n\n    \\[\n    S = \n     \\begin{bmatrix}\n      3 & 12 & 4  \\\\\n      5 & 9 & 15  \\\\\n      0 & 2 & 4 \\\\\n     \\end{bmatrix}\n    \\]\n\n    \\section{Operations}\n\n    The sum $A+B$ of matrices $A$ and $B$\n    is defined if the matrices are of the same size.\n    The result is a matrix where each element\n    is the sum of the corresponding elements\n    in $A$ and $B$.\n\n    For example,\n    \\[\n     \\begin{bmatrix}\n      6 & 1 & 4 \\\\\n      3 & 9 & 2 \\\\\n     \\end{bmatrix}\n    +\n     \\begin{bmatrix}\n      4 & 9 & 3 \\\\\n      8 & 1 & 3 \\\\\n     \\end{bmatrix}\n    =\n     \\begin{bmatrix}\n      6+4 & 1+9 & 4+3 \\\\\n      3+8 & 9+1 & 2+3 \\\\\n     \\end{bmatrix}\n    =\n     \\begin{bmatrix}\n      10 & 10 & 7 \\\\\n      11 & 10 & 5 \\\\\n     \\end{bmatrix}.\n    \\]\n\n    Multiplying a matrix $A$ by a value $x$ means\n    that each element of $A$ is multiplied by $x$.\n    For example,\n    \\[\n     2 \\cdot \\begin{bmatrix}\n      6 & 1 & 4 \\\\\n      3 & 9 & 2 \\\\\n     \\end{bmatrix}\n    =\n     \\begin{bmatrix}\n      2 \\cdot 6 & 2\\cdot1 & 2\\cdot4 \\\\\n      2\\cdot3 & 2\\cdot9 & 2\\cdot2 \\\\\n     \\end{bmatrix}\n    =\n     \\begin{bmatrix}\n      12 & 2 & 8 \\\\\n      6 & 18 & 4 \\\\\n     \\end{bmatrix}.\n    \\]\n\n    \\subsubsection{Matrix multiplication}\n\n    \\index{matrix multiplication}\n\n    The product $AB$ of matrices $A$ and $B$\n    is defined if $A$ is of size $a \\times n$\n    and $B$ is of size $n \\times b$, i.e.,\n    the width of $A$ equals the height of $B$.\n    The result is a matrix of size $a \\times b$\n    whose elements are calculated using the formula\n    \\[\n    AB[i,j] = \\sum_{k=1}^n A[i,k] \\cdot B[k,j].\n    \\]\n\n    The idea is that each element of $AB$\n    is a sum of products of elements of $A$ and $B$\n    according to the following picture:\n\n    \\begin{center}\n    \\begin{tikzpicture}[scale=0.5]\n    \\draw (0,0) grid (4,3);\n    \\draw (5,0) grid (10,3);\n    \\draw (5,4) grid (10,8);\n\n    \\node at (2,-1) {$A$};\n    \\node at (7.5,-1) {$AB$};\n    \\node at (11,6) {$B$};\n\n    \\draw[thick,->,red,line width=2pt] (0,1.5) -- (4,1.5);\n    \\draw[thick,->,red,line width=2pt] (6.5,8) -- (6.5,4);\n    \\draw[thick,red,line width=2pt] (6.5,1.5) circle (0.4);\n    \\end{tikzpicture}\n    \\end{center}\n\n    For example,\n\n    \\[\n     \\begin{bmatrix}\n      1 & 4 \\\\\n      3 & 9 \\\\\n      8 & 6 \\\\\n     \\end{bmatrix}\n    \\cdot\n     \\begin{bmatrix}\n      1 & 6 \\\\\n      2 & 9 \\\\\n     \\end{bmatrix}\n    =\n     \\begin{bmatrix}\n      1 \\cdot 1 + 4 \\cdot 2 & 1 \\cdot 6 + 4 \\cdot 9 \\\\\n      3 \\cdot 1 + 9 \\cdot 2 & 3 \\cdot 6 + 9 \\cdot 9 \\\\\n      8 \\cdot 1 + 6 \\cdot 2 & 8 \\cdot 6 + 6 \\cdot 9 \\\\\n     \\end{bmatrix}\n    =\n     \\begin{bmatrix}\n      9 & 42 \\\\\n      21 & 99 \\\\\n      20 & 102 \\\\\n     \\end{bmatrix}.\n    \\]\n\n    Matrix multiplication is associative,\n    so $A(BC)=(AB)C$ holds,\n    but it is not commutative,\n    so $AB = BA$ does not usually hold.\n\n    \\index{identity matrix}\n\n    An \\key{identity matrix} is a square matrix\n    where each element on the diagonal is 1\n    and all other elements are 0.\n    For example, the following matrix\n    is the $3 \\times 3$ identity matrix:\n    \\[\n     I = \\begin{bmatrix}\n      1 & 0 & 0 \\\\\n      0 & 1 & 0 \\\\\n      0 & 0 & 1 \\\\\n     \\end{bmatrix}\n    \\]\n\n    \\begin{samepage}\n    Multiplying a matrix by an identity matrix\n    does not change it. For example,\n    \\[\n     \\begin{bmatrix}\n      1 & 0 & 0 \\\\\n      0 & 1 & 0 \\\\\n      0 & 0 & 1 \\\\\n     \\end{bmatrix}\n    \\cdot\n     \\begin{bmatrix}\n      1 & 4 \\\\\n      3 & 9 \\\\\n      8 & 6 \\\\\n     \\end{bmatrix}\n    =\n     \\begin{bmatrix}\n      1 & 4 \\\\\n      3 & 9 \\\\\n      8 & 6 \\\\\n     \\end{bmatrix} \\hspace{10px} \\textrm{and} \\hspace{10px}\n     \\begin{bmatrix}\n      1 & 4 \\\\\n      3 & 9 \\\\\n      8 & 6 \\\\\n     \\end{bmatrix}\n    \\cdot\n     \\begin{bmatrix}\n      1 & 0 \\\\\n      0 & 1 \\\\\n     \\end{bmatrix}\n    =\n     \\begin{bmatrix}\n      1 & 4 \\\\\n      3 & 9 \\\\\n      8 & 6 \\\\\n     \\end{bmatrix}.\n    \\]\n    \\end{samepage}\n\n    Using a straightforward algorithm,\n    we can calculate the product of\n    two $n \\times n$ matrices\n    in $O(n^3)$ time.\n    There are also more efficient algorithms\n    for matrix multiplication\\footnote{The first such\n    algorithm was Strassen's algorithm,\n    published in 1969 \\cite{str69},\n    whose time complexity is $O(n^{2.80735})$;\n    the best current algorithm \\cite{gal14}\n    works in $O(n^{2.37286})$ time.},\n    but they are mostly of theoretical interest\n    and such algorithms are not necessary\n    in competitive programming.\n\n\n    \\subsubsection{Matrix power}\n\n    \\index{matrix power}\n\n    The power $A^k$ of a matrix $A$ is defined\n    if $A$ is a square matrix.\n    The definition is based on matrix multiplication:\n    \\[ A^k = \\underbrace{A \\cdot A \\cdot A \\cdots A}_{\\textrm{$k$ times}} \\]\n    For example,\n\n    \\[\n     \\begin{bmatrix}\n      2 & 5 \\\\\n      1 & 4 \\\\\n     \\end{bmatrix}^3 =\n     \\begin{bmatrix}\n      2 & 5 \\\\\n      1 & 4 \\\\\n     \\end{bmatrix} \\cdot\n     \\begin{bmatrix}\n      2 & 5 \\\\\n      1 & 4 \\\\\n     \\end{bmatrix} \\cdot\n     \\begin{bmatrix}\n      2 & 5 \\\\\n      1 & 4 \\\\\n     \\end{bmatrix} =\n     \\begin{bmatrix}\n      48 & 165 \\\\\n      33 & 114 \\\\\n     \\end{bmatrix}.\n    \\]\n    In addition, $A^0$ is an identity matrix. For example,\n    \\[\n     \\begin{bmatrix}\n      2 & 5 \\\\\n      1 & 4 \\\\\n     \\end{bmatrix}^0 =\n     \\begin{bmatrix}\n      1 & 0 \\\\\n      0 & 1 \\\\\n     \\end{bmatrix}.\n    \\]\n\n    The matrix $A^k$ can be efficiently calculated\n    in $O(n^3 \\log k)$ time using the\n    algorithm in Chapter 21.2. For example,\n    \\[\n     \\begin{bmatrix}\n      2 & 5 \\\\\n      1 & 4 \\\\\n     \\end{bmatrix}^8 =\n     \\begin{bmatrix}\n      2 & 5 \\\\\n      1 & 4 \\\\\n     \\end{bmatrix}^4 \\cdot\n     \\begin{bmatrix}\n      2 & 5 \\\\\n      1 & 4 \\\\\n     \\end{bmatrix}^4.\n    \\]\n\n    \\subsubsection{Determinant}\n\n    \\index{determinant}\n\n    The \\key{determinant} $\\det(A)$ of a matrix $A$\n    is defined if $A$ is a square matrix.\n    If $A$ is of size $1 \\times 1$,\n    then $\\det(A)=A[1,1]$.\n    The determinant of a larger matrix is\n    calculated recursively using the formula \\index{cofactor}\n    \\[\\det(A)=\\sum_{j=1}^n A[1,j] C[1,j],\\]\n    where $C[i,j]$ is the \\key{cofactor} of $A$\n    at $[i,j]$.\n    The cofactor is calculated using the formula\n    \\[C[i,j] = (-1)^{i+j} \\det(M[i,j]),\\]\n    where $M[i,j]$ is obtained by removing\n    row $i$ and column $j$ from $A$.\n    Due to the coefficient $(-1)^{i+j}$ in the cofactor,\n    every other determinant is positive\n    and negative.\n    For example,\n    \\[\n    \\det(\n     \\begin{bmatrix}\n      3 & 4 \\\\\n      1 & 6 \\\\\n     \\end{bmatrix}\n    ) = 3 \\cdot 6 - 4 \\cdot 1 = 14 \n    \\]\n    and\n    \\[\n    \\det(\n     \\begin{bmatrix}\n      2 & 4 & 3 \\\\\n      5 & 1 & 6 \\\\\n      7 & 2 & 4 \\\\\n     \\end{bmatrix}\n    ) = \n    2 \\cdot\n    \\det(\n     \\begin{bmatrix}\n      1 & 6 \\\\\n      2 & 4 \\\\\n     \\end{bmatrix}\n    )\n    -4 \\cdot\n    \\det(\n     \\begin{bmatrix}\n      5 & 6 \\\\\n      7 & 4 \\\\\n     \\end{bmatrix}\n    )\n    +3 \\cdot\n    \\det(\n     \\begin{bmatrix}\n      5 & 1 \\\\\n      7 & 2 \\\\\n     \\end{bmatrix}\n    ) = 81.\n    \\]\n\n    \\index{inverse matrix}\n\n    The determinant of $A$ tells us\n    whether there is an \\key{inverse matrix}\n    $A^{-1}$ such that $A \\cdot A^{-1} = I$,\n    where $I$ is an identity matrix.\n    It turns out that $A^{-1}$ exists\n    exactly when $\\det(A) \\neq 0$,\n    and it can be calculated using the formula\n\n    \\[A^{-1}[i,j] = \\frac{C[j,i]}{det(A)}.\\]\n\n    For example,\n\n    \\[\n    \\underbrace{\n     \\begin{bmatrix}\n      2 & 4 & 3\\\\\n      5 & 1 & 6\\\\\n      7 & 2 & 4\\\\\n     \\end{bmatrix}\n    }_{A}\n    \\cdot\n    \\underbrace{\n     \\frac{1}{81}\n     \\begin{bmatrix}\n       -8 & -10 & 21 \\\\\n       22 & -13 & 3 \\\\\n       3 & 24 & -18 \\\\\n     \\end{bmatrix}\n    }_{A^{-1}}\n    =\n    \\underbrace{\n     \\begin{bmatrix}\n      1 & 0 & 0 \\\\\n      0 & 1 & 0 \\\\\n      0 & 0 & 1 \\\\\n     \\end{bmatrix}\n    }_{I}.\n    \\]\n[/Textbook Reference Material]\n\n\n[Textbook Reference Material]:\n    Title: Finding the largest zero submatrix\n    Part: 1/1\n    # Finding the largest zero submatrix\n\n    You are given a matrix with `n` rows and `m` columns. Find the largest submatrix consisting of only zeros (a submatrix is a rectangular area of the matrix).\n\n    ## Algorithm\n\n    Elements of the matrix will be `a[i][j]`, where `i = 0...n - 1`, `j = 0... m - 1`. For simplicity, we will consider all non-zero elements equal to 1.\n\n    ### Step 1: Auxiliary dynamic\n\n    First, we calculate the following auxiliary matrix: `d[i][j]`, nearest row that has a 1 above `a[i][j]`. Formally speaking, `d[i][j]` is the largest row number (from `0` to `i - 1`), in which there is a element equal to `1` in the `j`-th column. \n    While iterating from top-left to bottom-right, when we stand in row `i`, we know the values from the previous row, so, it is enough to update just the elements with value `1`. We can save the values in a simple array `d[i]`, `i = 1...m - 1`, because in the further algorithm we will process the matrix one row at a time and only need the values of the current row.\n\n    ```cpp\n    vector<int> d(m, -1);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (a[i][j] == 1) {\n                d[j] = i;\n            }\n        }\n    }\n    ```\n\n    ### Step 2: Problem solving\n\n    We can solve the problem in $O(n m^2)$ iterating through rows, considering every possible left and right columns for a submatrix. The bottom of the rectangle will be the current row, and using `d[i][j]` we can find the top row. However, it is possible to go further and significantly improve the complexity of the solution.\n\n    It is clear that the desired zero submatrix is bounded on all four sides by some ones, which prevent it from increasing in size and improving the answer. Therefore,  we will not miss the answer if we act as follows: for every cell `j` in row `i` (the bottom row of a potential zero submatrix) we will have `d[i][j]` as the top row of the current zero submatrix. It now remains to determine the optimal left and right boundaries of the zero submatrix, i.e. maximally push this submatrix to the left and right of the `j`-th column. \n\n    What does it mean to push the maximum to the left? It means to find an index `k1` for which `d[i][k1] > d[i][j]`, and at the same time `k1` - the closest one to the left of the index `j`. It is clear that then `k1 + 1` gives the number of the left column of the required zero submatrix. If there is no such index at all, then put `k1` = `-1`(this means that we were able to extend the current zero submatrix to the left all the way to the border of matrix `a`).\n\n    Symmetrically, you can define an index `k2` for the right border: this is the closest index to the right of `j` such that `d[i][k2] > d[i][j]` (or `m`, if there is no such index).\n\n    So, the indices `k1` and `k2`, if we learn to search for them effectively, will give us all the necessary information about the current zero submatrix. In particular, its area will be equal to `(i - d[i][j]) * (k2 - k1 - 1)`.\n\n    How to look for these indexes `k1` and `k2` effectively with fixed `i` and `j`? We can do that in $O(1)$ on average.\n\n    To achieve such complexity, you can use the stack as follows. Let's first learn how to search for an index `k1`, and save its value for each index `j` within the current row `i` in matrix `d1[i][j]`. To do this, we will look through all the columns `j` from left to right, and we will store in the stack only those columns that have `d[][]` strictly greater than `d[i][j]`. It is clear that when moving from a column `j` to the next column, it is necessary to update the content of the stack. When there is an inappropriate element at the top of the stack (i.e. `d[][] <= d[i][j]`) pop it. It is easy to understand that it is enough to remove from the stack only from its top, and from none of its other places (because the stack will contain an increasing `d` sequence of columns).\n\n    The value `d1[i][j]` for each `j` will be equal to the value lying at that moment on top of the stack.\n\n    The dynamics `d2[i][j]` for finding the indices `k2` is considered similar, only you need to view the columns from right to left.\n\n    It is clear that since there are exactly `m` pieces added to the stack on each line, there could not be more deletions either, the sum of complexities will be linear, so the final complexity of the algorithm is $O(nm)$.\n\n    It should also be noted that this algorithm consumes $O(m)$ memory (not counting the input data - the matrix `a[][]`).\n\n    ### Implementation\n\n    ```cpp\n    int zero_matrix(vector<vector<int>> a) {\n        int n = a.size();\n        int m = a[0].size();\n\n        int ans = 0;\n        vector<int> d(m, -1), d1(m), d2(m);\n        stack<int> st;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (a[i][j] == 1)\n                    d[j] = i;\n            }\n\n            for (int j = 0; j < m; ++j) {\n                while (!st.empty() && d[st.top()] <= d[j])\n                    st.pop();\n                d1[j] = st.empty() ? -1 : st.top();\n                st.push(j);\n            }\n            while (!st.empty())\n                st.pop();\n\n            for (int j = m - 1; j >= 0; --j) {\n                while (!st.empty() && d[st.top()] <= d[j])\n                    st.pop();\n                d2[j] = st.empty() ? m : st.top();\n                st.push(j);\n            }\n            while (!st.empty())\n                st.pop();\n\n            for (int j = 0; j < m; ++j)\n                ans = max(ans, (i - d[j]) * (d2[j] - d1[j] - 1));\n        }\n        return ans;\n    }\n    ```\n[/Textbook Reference Material]\n\n"
    },
    {
        "role": "assistant",
        "content": "1. **Restate the problem in plain English**: \n   We need to create a function that checks if a given square matrix is a magic square. A magic square is a grid where the sum of the numbers in each row, each column, and both main diagonals are the same.\n\n2. **Conceptualize a solution first in plain English**: \n   To determine if a matrix is a magic square, we will:\n   - Calculate the sum of the first row to establish the target sum.\n   - Check if all rows have the same sum as the target.\n   - Check if all columns have the same sum as the target.\n   - Check if both diagonals have the same sum as the target.\n   - If all these conditions are met, the matrix is a magic square.\n\n3. **Write a pseudocode solution**:\n   ```\n   function magic_square_test(matrix):\n       if matrix is empty or not square:\n           return False\n       \n       target_sum = sum of the first row\n       \n       for each row in matrix:\n           if sum of row != target_sum:\n               return False\n       \n       for each column in matrix:\n           if sum of column != target_sum:\n               return False\n       \n       diagonal1_sum = sum of the main diagonal\n       diagonal2_sum = sum of the anti-diagonal\n       \n       if diagonal1_sum != target_sum or diagonal2_sum != target_sum:\n           return False\n       \n       return True\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\ndef magic_square_test(matrix):\n    # Check if the matrix is empty or not square\n    if not matrix or len(matrix) != len(matrix[0]):\n        return False\n    \n    n = len(matrix)  # Size of the matrix\n    target_sum = sum(matrix[0])  # Sum of the first row to establish the target\n    \n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    diagonal1_sum = sum(matrix[i][i] for i in range(n))\n    # Check the sum of the anti-diagonal\n    diagonal2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    \n    # Check if both diagonals match the target sum\n    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:\n        return False\n    \n    return True\n```"
    },
    {
        "role": "user",
        "content": "\n[Environment Feedback]:\n    Note: Tests are automatically generated and can be wrong.\n\n    Tests passed:\n    assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n\n    Tests failed:\n    None\n[/Environment Feedback]\n"
    }
]