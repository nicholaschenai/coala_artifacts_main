{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert check_expression(\"{()}[{}]\") == True\n\nTests failed:\nNone",
    "code": "\ndef is_opening_bracket(c):\n    return c in '{[('\n\ndef is_closing_bracket(c):\n    return c in '}])'\n\ndef matches(opening, closing):\n    return (opening == '{' and closing == '}') or \\\n           (opening == '[' and closing == ']') or \\\n           (opening == '(' and closing == ')')\n\ndef check_expression(expression: str) -> bool:\n    stack = []\n    for char in expression:\n        if is_opening_bracket(char):\n            stack.append(char)\n        elif is_closing_bracket(char):\n            if not stack:\n                return False\n            top = stack.pop()\n            if not matches(top, char):\n                return False\n    return len(stack) == 0\n",
    "full_code": "\ndef is_opening_bracket(c):\n    return c in '{[('\n\ndef is_closing_bracket(c):\n    return c in '}])'\n\ndef matches(opening, closing):\n    return (opening == '{' and closing == '}') or \\\n           (opening == '[' and closing == ']') or \\\n           (opening == '(' and closing == ')')\n\ndef check_expression(expression: str) -> bool:\n    stack = []\n    for char in expression:\n        if is_opening_bracket(char):\n            stack.append(char)\n        elif is_closing_bracket(char):\n            if not stack:\n                return False\n            top = stack.pop()\n            if not matches(top, char):\n                return False\n    return len(stack) == 0\n",
    "reward": true,
    "program_code": "\ndef is_opening_bracket(c):\n    return c in '{[('\n\ndef is_closing_bracket(c):\n    return c in '}])'\n\ndef matches(opening, closing):\n    return (opening == '{' and closing == '}') or \\\n           (opening == '[' and closing == ']') or \\\n           (opening == '(' and closing == ')')\n\ndef check_expression(expression: str) -> bool:\n    stack = []\n    for char in expression:\n        if is_opening_bracket(char):\n            stack.append(char)\n        elif is_closing_bracket(char):\n            if not stack:\n                return False\n            top = stack.pop()\n            if not matches(top, char):\n                return False\n    return len(stack) == 0\n",
    "program_name": "check_expression",
    "dependencies": [],
    "raw_msg": "1. **Restatement of the Problem**: \n   The task is to create a function that checks if a given string of brackets (which can include different types of brackets like `{}`, `()`, and `[]`) is balanced. A balanced string means that every opening bracket has a corresponding closing bracket in the correct order.\n\n2. **Conceptualizing a Solution**: \n   To determine if the string is balanced, we can use a stack data structure. As we iterate through the string:\n   - If we encounter an opening bracket (`{`, `(`, or `[`), we push it onto the stack.\n   - If we encounter a closing bracket (`}`, `)`, or `]`), we check if the stack is not empty and if the top of the stack is the corresponding opening bracket. If both conditions are met, we pop the stack. If not, the string is unbalanced.\n   - At the end of the iteration, if the stack is empty, the string is balanced; otherwise, it is not.\n\n3. **Pseudocode Solution**:\n   ```\n   function check_expression(expression):\n       create an empty stack\n       for each character in expression:\n           if character is an opening bracket:\n               push character onto the stack\n           else if character is a closing bracket:\n               if stack is empty:\n                   return False\n               top = pop from stack\n               if top does not match the corresponding opening bracket for character:\n                   return False\n       return True if stack is empty, else False\n   ```\n\n4. **Final Python 3 Solution**:\n```python\ndef is_opening_bracket(c):\n    return c in '{[('\n\ndef is_closing_bracket(c):\n    return c in '}])'\n\ndef matches(opening, closing):\n    return (opening == '{' and closing == '}') or \\\n           (opening == '[' and closing == ']') or \\\n           (opening == '(' and closing == ')')\n\ndef check_expression(expression: str) -> bool:\n    stack = []\n    for char in expression:\n        if is_opening_bracket(char):\n            stack.append(char)\n        elif is_closing_bracket(char):\n            if not stack:\n                return False\n            top = stack.pop()\n            if not matches(top, char):\n                return False\n    return len(stack) == 0\n```",
    "no_parent": true,
    "dependency_used": false
}