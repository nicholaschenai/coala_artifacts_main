{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n\nTests failed:\nNone",
    "code": "\ndef maxAverageOfPath(matrix):\n    n = len(matrix)  # Get the size of the matrix\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array for dynamic programming\n\n    dp[0][0] = matrix[0][0]  # Starting point\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    max_sum = dp[n - 1][n - 1]  # Maximum sum to reach the bottom-right corner\n    number_of_cells = n + n - 1  # Total cells in the path\n    return max_sum / number_of_cells  # Return the maximum average\n",
    "full_code": "\ndef maxAverageOfPath(matrix):\n    n = len(matrix)  # Get the size of the matrix\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array for dynamic programming\n\n    dp[0][0] = matrix[0][0]  # Starting point\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    max_sum = dp[n - 1][n - 1]  # Maximum sum to reach the bottom-right corner\n    number_of_cells = n + n - 1  # Total cells in the path\n    return max_sum / number_of_cells  # Return the maximum average\n",
    "reward": true,
    "program_code": "\ndef maxAverageOfPath(matrix):\n    n = len(matrix)  # Get the size of the matrix\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array for dynamic programming\n\n    dp[0][0] = matrix[0][0]  # Starting point\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    max_sum = dp[n - 1][n - 1]  # Maximum sum to reach the bottom-right corner\n    number_of_cells = n + n - 1  # Total cells in the path\n    return max_sum / number_of_cells  # Return the maximum average\n",
    "program_name": "maxAverageOfPath",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**: \n   We need to find a path in a square matrix that starts from the top-left corner and ends at the bottom-right corner. The path can only move right or down. Each cell in the matrix has a cost associated with it, and we want to find the path that gives the maximum average cost. The average is calculated by dividing the total cost of the path by the number of cells in that path.\n\n2. **Conceptualize a solution first in plain English**: \n   To solve this problem, we can use dynamic programming. We will create a 2D array to store the maximum sum of costs to reach each cell in the matrix. We will iterate through the matrix, and for each cell, we will calculate the maximum sum of costs by considering the cells above and to the left. Once we have the maximum sum to reach the bottom-right corner, we can calculate the average by dividing this sum by the total number of cells in the path.\n\n3. **Write a pseudocode solution**:\n   ```\n   function maxAverageOfPath(matrix):\n       n = length of matrix\n       create a 2D array dp of size n x n initialized to 0\n       \n       dp[0][0] = matrix[0][0]  // starting point\n       \n       // Fill the first row\n       for j from 1 to n-1:\n           dp[0][j] = dp[0][j-1] + matrix[0][j]\n       \n       // Fill the first column\n       for i from 1 to n-1:\n           dp[i][0] = dp[i-1][0] + matrix[i][0]\n       \n       // Fill the rest of the dp array\n       for i from 1 to n-1:\n           for j from 1 to n-1:\n               dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n       \n       max_sum = dp[n-1][n-1]\n       number_of_cells = n + n - 1  // total cells in the path\n       return max_sum / number_of_cells\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\ndef maxAverageOfPath(matrix):\n    n = len(matrix)  # Get the size of the matrix\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array for dynamic programming\n\n    dp[0][0] = matrix[0][0]  # Starting point\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    max_sum = dp[n - 1][n - 1]  # Maximum sum to reach the bottom-right corner\n    number_of_cells = n + n - 1  # Total cells in the path\n    return max_sum / number_of_cells  # Return the maximum average\n```",
    "no_parent": true,
    "dependency_used": false
}