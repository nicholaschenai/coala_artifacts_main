INFO - [test iter]: 55/378

INFO - The task prompt is Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Write a function that takes in a sorted array, its length (n), and ...

INFO - Attempting task_id Mbpp/223
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] Mbpp/223 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)
assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
"""

[END PROBLEM]

INFO - [Task id] Mbpp/223 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] Mbpp/223 [generation text] 1. **Restate the problem in plain English:**
   We need to create a function that checks if a given element in a sorted array appears more than half the time (n/2) in that array. If it does, we return `True`, indicating that it is the majority element; otherwise, we return `False`.

2. **Conceptualize a solution first in plain English:**
   - First, we need to determine how many times the specified element appears in the array.
   - Since the array is sorted, we can find the first and last occurrence of the element using binary search.
   - We can then calculate the count of the element by subtracting the index of the first occurrence from the index of the last occurrence and adding one.
   - Finally, we compare this count to n/2 to determine if it is a majority element.

3. **Write a pseudocode solution:**
   ```
   function is_majority(arr, n, element):
       if n is 0:
           return False
       
       first_index = find_first_index(arr, element)
       if first_index is -1:
           return False
       
       last_index = find_last_index(arr, element)
       count = last_index - first_index + 1
       
       return count > n / 2

   function find_first_index(arr, element):
       // Implement binary search to find the first index of element

   function find_last_index(arr, element):
       // Implement binary search to find the last index of element
   ```

4. **Output the final Python 3 solution with your solution steps in comments:**
```python
def find_first_index(arr, element):
    left, right = 0, len(arr) - 1
    first_index = -1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == element:
            first_index = mid
            right = mid - 1  # continue searching in the left half
        elif arr[mid] < element:
            left = mid + 1
        else:
            right = mid - 1
    return first_index

def find_last_index(arr, element):
    left, right = 0, len(arr) - 1
    last_index = -1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == element:
            last_index = mid
            left = mid + 1  # continue searching in the right half
        elif arr[mid] < element:
            left = mid + 1
        else:
            right = mid - 1
    return last_index

def is_majority(arr, n, element):
    if n == 0:
        return False
    
    first_index = find_first_index(arr, element)
    if first_index == -1:
        return False
    
    last_index = find_last_index(arr, element)
    count = last_index - first_index + 1
    
    return count > n / 2
```
INFO - [35m Rollout attempt 1/4[0m
INFO - [33m Retrieving 3 entries for db: semantic 
 [0m
INFO - Retrieved (score=0.4614):
Title: Binary search
Part: 1/2
# Binary search

**Binary search** is a method that allows for quicker search of something by splitting the search interval into two. Its most common application is searching values in sorted arrays, however the splitting idea is crucial in many other typical tasks....


INFO - Retrieved (score=0.4619):
Chapter: Sorting
Section: Binary search
Part: 1/1
\section{Binary search}

\index{binary search}

A general method for searching for an element
in an array is to use a \texttt{for} loop
that iterates through the elements of the array.
For example, the following code searches for
an element $x$ in...


INFO - Retrieved (score=0.4808):
Chapter: Data structures
Section: Comparison to sorting
Part: 1/1
\section{Comparison to sorting}

It is often possible to solve a problem
using either data structures or sorting.
Sometimes there are remarkable differences
in the actual efficiency of these approaches,
which may be hidden in their...


INFO - Retrieved (score=0.4614): 
[Textbook Reference Material]:
    Title: Binary search
    Part: 1/2
    # Binary search

    **Binary search** is a method that allows for quicker search of something by splitting the search interval into two. Its most common application is searching values in sorted arrays, however the splitt...
INFO - Retrieved (score=0.4619): 
[Textbook Reference Material]:
    Chapter: Sorting
    Section: Binary search
    Part: 1/1
    \section{Binary search}

    \index{binary search}

    A general method for searching for an element
    in an array is to use a \texttt{for} loop
    that iterates through the elements of the array...
INFO - Retrieved (score=0.4808): 
[Textbook Reference Material]:
    Chapter: Data structures
    Section: Comparison to sorting
    Part: 1/1
    \section{Comparison to sorting}

    It is often possible to solve a problem
    using either data structures or sorting.
    Sometimes there are remarkable differences
    in the act...
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] Mbpp/223 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)
assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True
"""

[END PROBLEM]

INFO - [Task id] Mbpp/223 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] Mbpp/223 [prompt] 
Also, here are some of your memories.
Feel free to use the given information to aid your problem solving process if necessary.
Do not confuse the memories with the problem statement.

## Memories

[Textbook Reference Material]:
    Title: Binary search
    Part: 1/2
    # Binary search

    **Binary search** is a method that allows for quicker search of something by splitting the search interval into two. Its most common application is searching values in sorted arrays, however the splitting idea is crucial in many other typical tasks.

    ## Search in sorted arrays

    The most typical problem that leads to the binary search is as follows. You're given a sorted array $A_0 \leq A_1 \leq \dots \leq A_{n-1}$, check if $k$ is present within the sequence. The simplest solution would be to check every element one by one and compare it with $k$ (a so-called linear search). This approach works in $O(n)$, but doesn't utilize the fact that the array is sorted.

    <center>
    <img src="https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg" width="800px">
    <br>
    <i>Binary search of the value $7$ in an array</i>.
    <br>
    <i>The <a href="https://commons.wikimedia.org/wiki/File:Binary_Search_Depiction.svg">image</a> by [AlwaysAngry](https://commons.wikimedia.org/wiki/User:AlwaysAngry) is distributed under <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">CC BY-SA 4.0</a></i> license.
    </center>

    Now assume that we know two indices $L < R$ such that $A_L \leq k \leq A_R$. Because the array is sorted, we can deduce that $k$ either occurs among $A_L, A_{L+1}, \dots, A_R$ or doesn't occur in the array at all. If we pick an arbitrary index $M$ such that $L < M < R$ and check whether $k$ is less or greater than $A_M$. We have two possible cases:

    1. $A_L \leq k \leq A_M$. In this case, we reduce the problem from $[L, R]$ to $[L, M]$;
    1. $A_M \leq k \leq A_R$. In this case, we reduce the problem from $[L, R]$ to $[M, R]$.

    When it is impossible to pick  $M$, that is, when $R = L + 1$, we directly compare $k$ with $A_L$ and $A_R$. Otherwise we would want to pick $M$ in such manner that it reduces the active segment to a single element as quickly as possible _in the worst case_.

    Since in the worst case we will always reduce to larger segment of $[L, M]$ and $[M, R]$. Thus, in the worst case scenario the reduction would be from $R-L$ to $\max(M-L, R-M)$. To minimize this value, we should pick $M \approx \frac{L+R}{2}$, then

    $$
    M-L \approx \frac{R-L}{2} \approx R-M.
    $$

    In other words, from the worst-case scenario perspective it is optimal to always pick $M$ in the middle of $[L, R]$ and split it in half. Thus, the active segment halves on each step until it becomes of size $1$. So, if the process needs $h$ steps, in the end it reduces the difference between $R$ and $L$ from $R-L$ to $\frac{R-L}{2^h} \approx 1$, giving us the equation $2^h \approx R-L$.

    Taking $\log_2$ on both sides, we get $h \approx \log_2(R-L) \in O(\log n)$.

    Logarithmic number of steps is drastically better than that of linear search. For example, for $n \approx 2^{20} \approx 10^6$ you'd need to make approximately a million operations for linear search, but only around $20$ operations with the binary search.

    ### Lower bound and upper bound

    It is often convenient to find the position of the first element that is not less than $k$ (called the lower bound of $k$ in the array) or the position of the first element that is greater than $k$ (called the upper bound of $k$) rather than the exact position of the element.

    Together, lower and upper bounds produce a possibly empty half-interval of the array elements that are equal to $k$. To check whether $k$ is present in the array it's enough to find its lower bound and check if the corresponding element equates to $k$.

    ### Implementation

    The explanation above provides a rough description of the algorithm. For the implementation details, we'd need to be more precise.

    We will maintain a pair $L < R$ such that $A_L \leq k < A_R$. Meaning that the active search interval is $[L, R)$. We use half-interval here instead of a segment $[L, R]$ as it turns out to require less corner case work.

    When $R = L+1$, we can deduce from definitions above that $R$ is the upper bound of $k$. It is convenient to initialize $R$ with past-the-end index, that is $R=n$ and $L$ with before-the-beginning index, that is $L=-1$. It is fine as long as we never evaluate $A_L$ and $A_R$ in our algorithm directly, formally treating it as $A_L = -\infty$ and $A_R = +\infty$.

    Finally, to be specific about the value of $M$ we pick, we will stick with $M = \lfloor \frac{L+R}{2} \rfloor$.

    Then the implementation could look like this:

    ```cpp
    ... // a sorted array is stored as a[0], a[1], ..., a[n-1]
    int l = -1, r = n;
    while(r - l > 1) {
        int m = (l + r) / 2;
        if(k < a[m]) {
            r = m; // a[l] <= k < a[m] <= a[r]
        } else {
            l = m; // a[l] <= a[m] <= k < a[r]
        }
    }
    ```

    During the execution of the algorithm, we never evaluate neither $A_L$ nor $A_R$, as $L < M < R$. In the end, $L$ will be the index of the last element that is not greater than $k$ (or $-1$ if there is no such element) and $R$ will be the index of the first element larger than $k$ (or $n$ if there is no such element).

    ## Search on arbitrary predicate

    Let $f : \{0,1,\dots, n-1\} \to \{0, 1\}$ be a boolean function defined on $0,1,\dots,n-1$ such that it is monotonous, that is

    $$
    f(0) \leq f(1) \leq \dots \leq f(n-1).
    $$

    The binary search, the way it is described above, finds the partition of the array by the predicate $f(M)$, holding the boolean value of $k < A_M$ expression. In other words, binary search finds the unique index $L$ such that $f(L) = 0$ and $f(R)=f(L+1)=1$.

    It is possible to use arbitrary monotonous predicate instead of $k < A_M$. It is particularly useful when the computation of $f(k)$ is requires too much time to actually compute it for every possible value.

    ```cpp
    ... // f(i) is a boolean function such that f(0) <= ... <= f(n-1)
    int l = -1, r = n;
    while(r - l > 1) {
        int m = (l + r) / 2;
        if(f(m)) {
            r = m; // 0 = f(l) < f(m) = 1
        } else {
            l = m; // 0 = f(m) < f(r) = 1
        }
    }
[/Textbook Reference Material]


[Textbook Reference Material]:
    Chapter: Sorting
    Section: Binary search
    Part: 1/1
    \section{Binary search}

    \index{binary search}

    A general method for searching for an element
    in an array is to use a \texttt{for} loop
    that iterates through the elements of the array.
    For example, the following code searches for
    an element $x$ in an array:

    \begin{lstlisting}
    for (int i = 0; i < n; i++) {
        if (array[i] == x) {
            // x found at index i
        }
    }
    \end{lstlisting}

    The time complexity of this approach is $O(n)$,
    because in the worst case, it is necessary to check
    all elements of the array.
    If the order of the elements is arbitrary,
    this is also the best possible approach, because
    there is no additional information available where
    in the array we should search for the element $x$.

    However, if the array is \emph{sorted},
    the situation is different.
    In this case it is possible to perform the
    search much faster, because the order of the
    elements in the array guides the search.
    The following \key{binary search} algorithm
    efficiently searches for an element in a sorted array
    in $O(\log n)$ time.

    \subsubsection{Method 1}

    The usual way to implement binary search
    resembles looking for a word in a dictionary.
    The search maintains an active region in the array,
    which initially contains all array elements.
    Then, a number of steps is performed,
    each of which halves the size of the region.

    At each step, the search checks the middle element
    of the active region.
    If the middle element is the target element,
    the search terminates.
    Otherwise, the search recursively continues
    to the left or right half of the region,
    depending on the value of the middle element.

    The above idea can be implemented as follows:
    \begin{lstlisting}
    int a = 0, b = n-1;
    while (a <= b) {
        int k = (a+b)/2;
        if (array[k] == x) {
            // x found at index k
        }
        if (array[k] > x) b = k-1;
        else a = k+1;
    }
    \end{lstlisting}

    In this implementation, the active region is $a \ldots b$,
    and initially the region is $0 \ldots n-1$.
    The algorithm halves the size of the region at each step,
    so the time complexity is $O(\log n)$.

    \subsubsection{Method 2}

    An alternative method to implement binary search
    is based on an efficient way to iterate through
    the elements of the array.
    The idea is to make jumps and slow the speed
    when we get closer to the target element.

    The search goes through the array from left to
    right, and the initial jump length is $n/2$.
    At each step, the jump length will be halved:
    first $n/4$, then $n/8$, $n/16$, etc., until
    finally the length is 1.
    After the jumps, either the target element has
    been found or we know that it does not appear in the array.

    The following code implements the above idea:
    \begin{lstlisting}
    int k = 0;
    for (int b = n/2; b >= 1; b /= 2) {
        while (k+b < n && array[k+b] <= x) k += b;
    }
    if (array[k] == x) {
        // x found at index k
    }
    \end{lstlisting}

    During the search, the variable $b$
    contains the current jump length.
    The time complexity of the algorithm is $O(\log n)$,
    because the code in the \texttt{while} loop
    is performed at most twice for each jump length.

    \subsubsection{C++ functions}

    The C++ standard library contains the following functions
    that are based on binary search and work in logarithmic time:

    \begin{itemize}
    \item \texttt{lower\_bound} returns a pointer to the
    first array element whose value is at least $x$.
    \item \texttt{upper\_bound} returns a pointer to the
    first array element whose value is larger than $x$.
    \item \texttt{equal\_range} returns both above pointers.
    \end{itemize}

    The functions assume that the array is sorted.
    If there is no such element, the pointer points to
    the element after the last array element.
    For example, the following code finds out whether
    an array contains an element with value $x$:

    \begin{lstlisting}
    auto k = lower_bound(array,array+n,x)-array;
    if (k < n && array[k] == x) {
        // x found at index k
    }
    \end{lstlisting}

    Then, the following code counts the number of elements
    whose value is $x$:

    \begin{lstlisting}
    auto a = lower_bound(array, array+n, x);
    auto b = upper_bound(array, array+n, x);
    cout << b-a << "\n";
    \end{lstlisting}

    Using \texttt{equal\_range}, the code becomes shorter:

    \begin{lstlisting}
    auto r = equal_range(array, array+n, x);
    cout << r.second-r.first << "\n";
    \end{lstlisting}

    \subsubsection{Finding the smallest solution}

    An important use for binary search is
    to find the position where the value of a \emph{function} changes.
    Suppose that we wish to find the smallest value $k$
    that is a valid solution for a problem.
    We are given a function $\texttt{ok}(x)$
    that returns \texttt{true} if $x$ is a valid solution
    and \texttt{false} otherwise.
    In addition, we know that $\texttt{ok}(x)$ is \texttt{false}
    when $x<k$ and \texttt{true} when $x \ge k$.
    The situation looks as follows:

    \begin{center}
    \begin{tabular}{r|rrrrrrrr}
    $x$ & 0 & 1 & $\cdots$ & $k-1$ & $k$ & $k+1$ & $\cdots$ \\
    \hline
    $\texttt{ok}(x)$ & \texttt{false} & \texttt{false}
    & $\cdots$ & \texttt{false} & \texttt{true} & \texttt{true} & $\cdots$ \\
    \end{tabular}
    \end{center}

    \noindent
    Now, the value of $k$ can be found using binary search:

    \begin{lstlisting}
    int x = -1;
    for (int b = z; b >= 1; b /= 2) {
        while (!ok(x+b)) x += b;
    }
    int k = x+1;
    \end{lstlisting}

    The search finds the largest value of $x$ for which
    $\texttt{ok}(x)$ is \texttt{false}.
    Thus, the next value $k=x+1$
    is the smallest possible value for which
    $\texttt{ok}(k)$ is \texttt{true}.
    The initial jump length $z$ has to be
    large enough, for example some value
    for which we know beforehand that $\texttt{ok}(z)$ is \texttt{true}.

    The algorithm calls the function \texttt{ok}
    $O(\log z)$ times, so the total time complexity
    depends on the function \texttt{ok}.
    For example, if the function works in $O(n)$ time,
    the total time complexity is $O(n \log z)$.

    \subsubsection{Finding the maximum value}

    Binary search can also be used to find
    the maximum value for a function that is
    first increasing and then decreasing.
    Our task is to find a position $k$ such that

    \begin{itemize}
    \item
    $f(x)<f(x+1)$ when $x<k$, and
    \item
    $f(x)>f(x+1)$ when $x \ge k$.
    \end{itemize}

    The idea is to use binary search
    for finding the largest value of $x$
    for which $f(x)<f(x+1)$.
    This implies that $k=x+1$
    because $f(x+1)>f(x+2)$.
    The following code implements the search: 

    \begin{lstlisting}
    int x = -1;
    for (int b = z; b >= 1; b /= 2) {
        while (f(x+b) < f(x+b+1)) x += b;
    }
    int k = x+1;
    \end{lstlisting}

    Note that unlike in the ordinary binary search,
    here it is not allowed that consecutive values
    of the function are equal.
    In this case it would not be possible to know
    how to continue the search.
[/Textbook Reference Material]


[Textbook Reference Material]:
    Chapter: Data structures
    Section: Comparison to sorting
    Part: 1/1
    \section{Comparison to sorting}

    It is often possible to solve a problem
    using either data structures or sorting.
    Sometimes there are remarkable differences
    in the actual efficiency of these approaches,
    which may be hidden in their time complexities.

    Let us consider a problem where
    we are given two lists $A$ and $B$
    that both contain $n$ elements.
    Our task is to calculate the number of elements
    that belong to both of the lists.
    For example, for the lists
    \[A = [5,2,8,9] \hspace{10px} \textrm{and} \hspace{10px} B = [3,2,9,5],\]
    the answer is 3 because the numbers 2, 5
    and 9 belong to both of the lists.

    A straightforward solution to the problem is
    to go through all pairs of elements in $O(n^2)$ time,
    but next we will focus on
    more efficient algorithms.

    \subsubsection{Algorithm 1}

    We construct a set of the elements that appear in $A$,
    and after this, we iterate through the elements
    of $B$ and check for each elements if it
    also belongs to $A$.
    This is efficient because the elements of $A$
    are in a set.
    Using the \texttt{set} structure,
    the time complexity of the algorithm is $O(n \log n)$.

    \subsubsection{Algorithm 2}

    It is not necessary to maintain an ordered set,
    so instead of the \texttt{set} structure
    we can also use the \texttt{unordered\_set} structure.
    This is an easy way to make the algorithm
    more efficient, because we only have to change
    the underlying data structure.
    The time complexity of the new algorithm is $O(n)$.

    \subsubsection{Algorithm 3}

    Instead of data structures, we can use sorting.
    First, we sort both lists $A$ and $B$.
    After this, we iterate through both the lists
    at the same time and find the common elements.
    The time complexity of sorting is $O(n \log n)$,
    and the rest of the algorithm works in $O(n)$ time,
    so the total time complexity is $O(n \log n)$.

    \subsubsection{Efficiency comparison}

    The following table shows how efficient
    the above algorithms are when $n$ varies and
    the elements of the lists are random
    integers between $1 \ldots 10^9$:

    \begin{center}
    \begin{tabular}{rrrr}
    $n$ & Algorithm 1 & Algorithm 2 & Algorithm 3 \\
    \hline
    $10^6$ & $1.5$ s & $0.3$ s & $0.2$ s \\
    $2 \cdot 10^6$ & $3.7$ s & $0.8$ s & $0.3$ s \\
    $3 \cdot 10^6$ & $5.7$ s & $1.3$ s & $0.5$ s \\
    $4 \cdot 10^6$ & $7.7$ s & $1.7$ s & $0.7$ s \\
    $5 \cdot 10^6$ & $10.0$ s & $2.3$ s & $0.9$ s \\
    \end{tabular}
    \end{center}

    Algorithms 1 and 2 are equal except that
    they use different set structures.
    In this problem, this choice has an important effect on
    the running time, because Algorithm 2
    is 4–5 times faster than Algorithm 1.

    However, the most efficient algorithm is Algorithm 3
    which uses sorting.
    It only uses half the time compared to Algorithm 2.
    Interestingly, the time complexity of both
    Algorithm 1 and Algorithm 3 is $O(n \log n)$,
    but despite this, Algorithm 3 is ten times faster.
    This can be explained by the fact that
    sorting is a simple procedure and it is done
    only once at the beginning of Algorithm 3,
    and the rest of the algorithm works in linear time.
    On the other hand,
    Algorithm 1 maintains a complex balanced binary tree
    during the whole algorithm.
[/Textbook Reference Material]


INFO - [Task id] Mbpp/223 [generation text] 1. **Restate the problem in plain English**: 
   We need to create a function that checks if a given element appears more than half the time in a sorted array. This element is referred to as the "majority element." If it does, the function should return `True`; otherwise, it should return `False`.

2. **Conceptualize a solution first in plain English**: 
   Since the array is sorted, we can efficiently find the first and last occurrence of the element in question. If the count of this element (which can be calculated as the difference between the indices of its last and first occurrence) exceeds half the length of the array, we can conclude that it is the majority element.

3. **Write a pseudocode solution**:
   ```
   function is_majority(arr, n, element):
       if n == 0:
           return False
       
       first_index = find_first_index(arr, element)
       if first_index == -1:
           return False
       
       last_index = find_last_index(arr, element)
       count = last_index - first_index + 1
       
       return count > n / 2

   function find_first_index(arr, element):
       // Implement binary search to find the first occurrence of element

   function find_last_index(arr, element):
       // Implement binary search to find the last occurrence of element
   ```

4. **Output the final Python 3 solution with your solution steps in comments**:
```python
def find_first_index(arr, element):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < element:
            left = mid + 1
        else:
            right = mid
    return left if left < len(arr) and arr[left] == element else -1

def find_last_index(arr, element):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= element:
            left = mid + 1
        else:
            right = mid
    return left - 1 if left > 0 and arr[left - 1] == element else -1

def is_majority(arr, n, element):
    # Check if the array is empty
    if n == 0:
        return False
    
    # Find the first index of the element
    first_index = find_first_index(arr, element)
    # If the element is not found, return False
    if first_index == -1:
        return False
    
    # Find the last index of the element
    last_index = find_last_index(arr, element)
    # Calculate the count of the element
    count = last_index - first_index + 1
    
    # Check if the count is greater than n/2
    return count > n / 2
```
INFO - program_code:
 
def find_first_index(arr, element):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < element:
            left = mid + 1
        else:
            right = mid
    return left if left < len(arr) and arr[left] == element else -1

def find_last_index(arr, element):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= element:
            left = mid + 1
        else:
            right = mid
    return left - 1 if left > 0 and arr[left - 1] == element else -1

def is_majority(arr, n, element):
    # Check if the array is empty
    if n == 0:
        return False
    
    # Find the first index of the element
    first_index = find_first_index(arr, element)
    # If the element is not found, return False
    if first_index == -1:
        return False
    
    # Find the last index of the element
    last_index = find_last_index(arr, element)
    # Calculate the count of the element
    count = last_index - first_index + 1
    
    # Check if the count is greater than n/2
    return count > n / 2


INFO - program_name:
 is_majority

INFO - dependencies:
 []

INFO - raw_msg:
 1. **Restate the problem in plain English**: 
   We need to create a function that checks if a given element appears more than half the time in a sorted array. This element is referred to as the "majority element." If it does, the function should return `True`; otherwise, it should return `False`.

2. **Conceptualize a solution first in plain English**: 
   Since the array is sorted, we can efficiently find the first and last occurrence of the element in question. If the count of this element (which can be calculated as the difference between the indices of its last and first occurrence) exceeds half the length of the array, we can conclude that it is the majority element.

3. **Write a pseudocode solution**:
   ```
   function is_majority(arr, n, element):
       if n == 0:
           return False
       
       first_index = find_first_index(arr, element)
       if first_index == -1:
           return False
       
       last_index = find_last_index(arr, element)
       count = last_index - first_index + 1
       
       return count > n / 2

   function find_first_index(arr, element):
       // Implement binary search to find the first occurrence of element

   function find_last_index(arr, element):
       // Implement binary search to find the last occurrence of element
   ```

4. **Output the final Python 3 solution with your solution steps in comments**:
```python
def find_first_index(arr, element):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < element:
            left = mid + 1
        else:
            right = mid
    return left if left < len(arr) and arr[left] == element else -1

def find_last_index(arr, element):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= element:
            left = mid + 1
        else:
            right = mid
    return left - 1 if left > 0 and arr[left - 1] == element else -1

def is_majority(arr, n, element):
    # Check if the array is empty
    if n == 0:
        return False
    
    # Find the first index of the element
    first_index = find_first_index(arr, element)
    # If the element is not found, return False
    if first_index == -1:
        return False
    
    # Find the last index of the element
    last_index = find_last_index(arr, element)
    # Calculate the count of the element
    count = last_index - first_index + 1
    
    # Check if the count is greater than n/2
    return count > n / 2
```

INFO - no_parent:
 True

INFO - full code to be executed: 
 
def find_first_index(arr, element):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < element:
            left = mid + 1
        else:
            right = mid
    return left if left < len(arr) and arr[left] == element else -1

def find_last_index(arr, element):
    left, right = 0, len(arr)
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= element:
            left = mid + 1
        else:
            right = mid
    return left - 1 if left > 0 and arr[left - 1] == element else -1

def is_majority(arr, n, element):
    # Check if the array is empty
    if n == 0:
        return False
    
    # Find the first index of the element
    first_index = find_first_index(arr, element)
    # If the element is not found, return False
    if first_index == -1:
        return False
    
    # Find the last index of the element
    last_index = find_last_index(arr, element)
    # Calculate the count of the element
    count = last_index - first_index + 1
    
    # Check if the count is greater than n/2
    return count > n / 2


INFO - obs: Note: Tests are automatically generated and can be wrong.

Tests passed:
assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True

Tests failed:
None
reward: True
done: None
info: {'individual_results': (True,)}
INFO - acc:54/55 = 98.18%
