{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['1', '3 3', '1 2', '2 1', '3 2'] Output: 0\n2\n2\n\nTests failed:\nNone",
    "code": "\ndef calculate_subsets(N, Q, queries):\n    MOD = 10**9 + 7\n    \n    # Precompute factorials and inverse factorials\n    factorials, inverse_factorials = precompute_factorials(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K > N:\n            results.append(0)\n        else:\n            count_less = C(I-1, K-1, factorials, inverse_factorials, MOD)\n            count_greater = pow(2, N-I, MOD)\n            result = (count_less * count_greater) % MOD\n            results.append(result)\n    return results\n\ndef precompute_factorials(N, MOD):\n    factorials = [1] * (N+1)\n    inverse_factorials = [1] * (N+1)\n    for i in range(2, N+1):\n        factorials[i] = (factorials[i-1] * i) % MOD\n    inverse_factorials[N] = pow(factorials[N], MOD-2, MOD)\n    for i in range(N-1, 0, -1):\n        inverse_factorials[i] = (inverse_factorials[i+1] * (i+1)) % MOD\n    return factorials, inverse_factorials\n\ndef C(n, k, factorials, inverse_factorials, MOD):\n    if k > n or k < 0:\n        return 0\n    return (factorials[n] * inverse_factorials[k] % MOD) * inverse_factorials[n-k] % MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        Q = int(data[index + 1])\n        index += 2\n        \n        queries = []\n        for _ in range(Q):\n            I = int(data[index])\n            K = int(data[index + 1])\n            index += 2\n            queries.append((I, K))\n        \n        results.extend(calculate_subsets(N, Q, queries))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\ndef calculate_subsets(N, Q, queries):\n    MOD = 10**9 + 7\n    \n    # Precompute factorials and inverse factorials\n    factorials, inverse_factorials = precompute_factorials(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K > N:\n            results.append(0)\n        else:\n            count_less = C(I-1, K-1, factorials, inverse_factorials, MOD)\n            count_greater = pow(2, N-I, MOD)\n            result = (count_less * count_greater) % MOD\n            results.append(result)\n    return results\n\ndef precompute_factorials(N, MOD):\n    factorials = [1] * (N+1)\n    inverse_factorials = [1] * (N+1)\n    for i in range(2, N+1):\n        factorials[i] = (factorials[i-1] * i) % MOD\n    inverse_factorials[N] = pow(factorials[N], MOD-2, MOD)\n    for i in range(N-1, 0, -1):\n        inverse_factorials[i] = (inverse_factorials[i+1] * (i+1)) % MOD\n    return factorials, inverse_factorials\n\ndef C(n, k, factorials, inverse_factorials, MOD):\n    if k > n or k < 0:\n        return 0\n    return (factorials[n] * inverse_factorials[k] % MOD) * inverse_factorials[n-k] % MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        Q = int(data[index + 1])\n        index += 2\n        \n        queries = []\n        for _ in range(Q):\n            I = int(data[index])\n            K = int(data[index + 1])\n            index += 2\n            queries.append((I, K))\n        \n        results.extend(calculate_subsets(N, Q, queries))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": true,
    "program_code": "\ndef calculate_subsets(N, Q, queries):\n    MOD = 10**9 + 7\n    \n    # Precompute factorials and inverse factorials\n    factorials, inverse_factorials = precompute_factorials(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K > N:\n            results.append(0)\n        else:\n            count_less = C(I-1, K-1, factorials, inverse_factorials, MOD)\n            count_greater = pow(2, N-I, MOD)\n            result = (count_less * count_greater) % MOD\n            results.append(result)\n    return results\n\ndef precompute_factorials(N, MOD):\n    factorials = [1] * (N+1)\n    inverse_factorials = [1] * (N+1)\n    for i in range(2, N+1):\n        factorials[i] = (factorials[i-1] * i) % MOD\n    inverse_factorials[N] = pow(factorials[N], MOD-2, MOD)\n    for i in range(N-1, 0, -1):\n        inverse_factorials[i] = (inverse_factorials[i+1] * (i+1)) % MOD\n    return factorials, inverse_factorials\n\ndef C(n, k, factorials, inverse_factorials, MOD):\n    if k > n or k < 0:\n        return 0\n    return (factorials[n] * inverse_factorials[k] % MOD) * inverse_factorials[n-k] % MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        Q = int(data[index + 1])\n        index += 2\n        \n        queries = []\n        for _ in range(Q):\n            I = int(data[index])\n            K = int(data[index + 1])\n            index += 2\n            queries.append((I, K))\n        \n        results.extend(calculate_subsets(N, Q, queries))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe are given a set of natural numbers from 1 to N and a number of queries. Each query asks us to determine the number of subsets in which a specific number `I` appears at a specific position `K` when the subset is sorted. The result should be given modulo \\(10^9 + 7\\).\n\n## Conceptual Solution\n\n1. **Understanding Subsets**: \n   - A subset of a set of numbers is any combination of those numbers, including the empty set and the set itself.\n   - When a subset is sorted, the position of a number in the subset is determined by its order in the sorted list.\n\n2. **Constraints**:\n   - We need to find subsets where a specific number `I` is at position `K` in the sorted order.\n   - If `K` is greater than `N`, or if `I` is less than `K`, the result is 0 because it's impossible for `I` to be at position `K`.\n\n3. **Combinatorial Approach**:\n   - For a number `I` to be at position `K` in a sorted subset:\n     - There must be exactly `K-1` numbers less than `I` in the subset.\n     - The remaining numbers in the subset can be any of the numbers greater than `I`.\n   - The number of ways to choose `K-1` numbers from the `I-1` numbers less than `I` is given by the binomial coefficient `C(I-1, K-1)`.\n   - The number of ways to choose any subset of the numbers greater than `I` is `2^(N-I)`.\n\n4. **Modulo Operation**:\n   - Since the result can be large, we need to compute the result modulo \\(10^9 + 7\\).\n\n## Pseudocode\n\n```\nfunction calculate_subsets(N, Q, queries):\n    MOD = 10^9 + 7\n    precompute factorials and inverse factorials up to N\n\n    results = []\n    for each query (I, K):\n        if K > I or K > N:\n            results.append(0)\n        else:\n            count_less = C(I-1, K-1) % MOD\n            count_greater = 2^(N-I) % MOD\n            result = (count_less * count_greater) % MOD\n            results.append(result)\n    return results\n\nfunction precompute_factorials(N):\n    factorials = [1] * (N+1)\n    inverse_factorials = [1] * (N+1)\n    for i from 2 to N:\n        factorials[i] = (factorials[i-1] * i) % MOD\n    inverse_factorials[N] = pow(factorials[N], MOD-2, MOD)\n    for i from N-1 down to 1:\n        inverse_factorials[i] = (inverse_factorials[i+1] * (i+1)) % MOD\n    return factorials, inverse_factorials\n\nfunction C(n, k):\n    if k > n or k < 0:\n        return 0\n    return (factorials[n] * inverse_factorials[k] % MOD) * inverse_factorials[n-k] % MOD\n```\n\n## Final Python Solution\n\n```python\ndef calculate_subsets(N, Q, queries):\n    MOD = 10**9 + 7\n    \n    # Precompute factorials and inverse factorials\n    factorials, inverse_factorials = precompute_factorials(N, MOD)\n    \n    results = []\n    for I, K in queries:\n        if K > I or K > N:\n            results.append(0)\n        else:\n            count_less = C(I-1, K-1, factorials, inverse_factorials, MOD)\n            count_greater = pow(2, N-I, MOD)\n            result = (count_less * count_greater) % MOD\n            results.append(result)\n    return results\n\ndef precompute_factorials(N, MOD):\n    factorials = [1] * (N+1)\n    inverse_factorials = [1] * (N+1)\n    for i in range(2, N+1):\n        factorials[i] = (factorials[i-1] * i) % MOD\n    inverse_factorials[N] = pow(factorials[N], MOD-2, MOD)\n    for i in range(N-1, 0, -1):\n        inverse_factorials[i] = (inverse_factorials[i+1] * (i+1)) % MOD\n    return factorials, inverse_factorials\n\ndef C(n, k, factorials, inverse_factorials, MOD):\n    if k > n or k < 0:\n        return 0\n    return (factorials[n] * inverse_factorials[k] % MOD) * inverse_factorials[n-k] % MOD\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        Q = int(data[index + 1])\n        index += 2\n        \n        queries = []\n        for _ in range(Q):\n            I = int(data[index])\n            K = int(data[index + 1])\n            index += 2\n            queries.append((I, K))\n        \n        results.extend(calculate_subsets(N, Q, queries))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis solution efficiently calculates the number of subsets for each query by precomputing factorials and using combinatorial mathematics to determine the number of valid subsets.",
    "no_parent": false,
    "dependency_used": false
}