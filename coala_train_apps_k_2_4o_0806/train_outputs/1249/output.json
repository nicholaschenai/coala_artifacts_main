{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['3', '4 12', '2 2', '5 14'] Output: [{'-1'}, {'2', '1'}, {'2', '5', '3', '1', '4'}]\n\nTests failed:\nNone",
    "code": "\ndef find_permutation(N, K):\n    # Calculate the maximum possible value of f(P)\n    max_possible = sum(range(2, N + 1))\n    # Calculate the minimum possible value of f(P)\n    min_possible = sum(range(1, N))\n    \n    if K > max_possible or K < min_possible:\n        return -1\n    \n    # Start with the permutation in descending order\n    permutation = list(range(N, 0, -1))\n    current_sum = max_possible\n    \n    # Adjust the permutation to achieve the desired sum K\n    for i in range(N - 1):\n        if current_sum == K:\n            break\n        for j in range(N - 1, i, -1):\n            if current_sum - (permutation[i] - permutation[j]) >= K:\n                current_sum -= (permutation[i] - permutation[j])\n                permutation[i], permutation[j] = permutation[j], permutation[i]\n                break\n    \n    return permutation\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        result = find_permutation(N, K)\n        if result == -1:\n            results.append(\"-1\")\n        else:\n            results.append(\" \".join(map(str, result)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\ndef find_permutation(N, K):\n    # Calculate the maximum possible value of f(P)\n    max_possible = sum(range(2, N + 1))\n    # Calculate the minimum possible value of f(P)\n    min_possible = sum(range(1, N))\n    \n    if K > max_possible or K < min_possible:\n        return -1\n    \n    # Start with the permutation in descending order\n    permutation = list(range(N, 0, -1))\n    current_sum = max_possible\n    \n    # Adjust the permutation to achieve the desired sum K\n    for i in range(N - 1):\n        if current_sum == K:\n            break\n        for j in range(N - 1, i, -1):\n            if current_sum - (permutation[i] - permutation[j]) >= K:\n                current_sum -= (permutation[i] - permutation[j])\n                permutation[i], permutation[j] = permutation[j], permutation[i]\n                break\n    \n    return permutation\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        result = find_permutation(N, K)\n        if result == -1:\n            results.append(\"-1\")\n        else:\n            results.append(\" \".join(map(str, result)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": true,
    "program_code": "\ndef find_permutation(N, K):\n    # Calculate the maximum possible value of f(P)\n    max_possible = sum(range(2, N + 1))\n    # Calculate the minimum possible value of f(P)\n    min_possible = sum(range(1, N))\n    \n    if K > max_possible or K < min_possible:\n        return -1\n    \n    # Start with the permutation in descending order\n    permutation = list(range(N, 0, -1))\n    current_sum = max_possible\n    \n    # Adjust the permutation to achieve the desired sum K\n    for i in range(N - 1):\n        if current_sum == K:\n            break\n        for j in range(N - 1, i, -1):\n            if current_sum - (permutation[i] - permutation[j]) >= K:\n                current_sum -= (permutation[i] - permutation[j])\n                permutation[i], permutation[j] = permutation[j], permutation[i]\n                break\n    \n    return permutation\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        result = find_permutation(N, K)\n        if result == -1:\n            results.append(\"-1\")\n        else:\n            results.append(\" \".join(map(str, result)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe are given a sequence of numbers from 1 to N, and we need to find a permutation of these numbers such that the sum of the maximum of each consecutive pair is equal to a given integer K. If such a permutation exists, we should output it; otherwise, we should output -1.\n\n## Conceptual Solution\n\n1. **Understanding the Function f(P)**: \n   - For a permutation P = (p1, p2, ..., pN), the function f(P) is defined as the sum of the maximum of each consecutive pair: max(p1, p2) + max(p2, p3) + ... + max(pN-1, pN).\n\n2. **Constraints and Observations**:\n   - The maximum possible value of f(P) for a permutation of [1, 2, ..., N] is the sum of the largest N-1 numbers, i.e., N + (N-1) + ... + 2.\n   - The minimum possible value of f(P) is the sum of the smallest N-1 numbers, i.e., 2 + 3 + ... + N.\n\n3. **Strategy**:\n   - Calculate the maximum possible value of f(P) for the given N.\n   - If K is greater than this maximum, output -1 because it's impossible to achieve.\n   - If K is less than the minimum possible value, output -1 because it's impossible to achieve.\n   - Otherwise, construct a permutation that achieves the desired sum K.\n\n4. **Constructing the Permutation**:\n   - Start with the permutation in descending order, which gives the maximum possible f(P).\n   - Adjust the permutation to decrease the sum to K by swapping elements to reduce the maximums in the sum.\n\n## Pseudocode\n\n```\nfunction find_permutation(N, K):\n    max_possible = sum of largest N-1 numbers\n    min_possible = sum of smallest N-1 numbers\n    \n    if K > max_possible or K < min_possible:\n        return -1\n    \n    permutation = list of numbers from N to 1 (descending order)\n    current_sum = max_possible\n    \n    for i from 0 to N-2:\n        if current_sum == K:\n            break\n        for j from N-1 down to i+1:\n            if current_sum - (permutation[i] - permutation[j]) >= K:\n                current_sum -= (permutation[i] - permutation[j])\n                swap permutation[i] and permutation[j]\n                break\n    \n    return permutation\n```\n\n## Final Python Solution\n\n```python\ndef find_permutation(N, K):\n    # Calculate the maximum possible value of f(P)\n    max_possible = sum(range(2, N + 1))\n    # Calculate the minimum possible value of f(P)\n    min_possible = sum(range(1, N))\n    \n    if K > max_possible or K < min_possible:\n        return -1\n    \n    # Start with the permutation in descending order\n    permutation = list(range(N, 0, -1))\n    current_sum = max_possible\n    \n    # Adjust the permutation to achieve the desired sum K\n    for i in range(N - 1):\n        if current_sum == K:\n            break\n        for j in range(N - 1, i, -1):\n            if current_sum - (permutation[i] - permutation[j]) >= K:\n                current_sum -= (permutation[i] - permutation[j])\n                permutation[i], permutation[j] = permutation[j], permutation[i]\n                break\n    \n    return permutation\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        result = find_permutation(N, K)\n        if result == -1:\n            results.append(\"-1\")\n        else:\n            results.append(\" \".join(map(str, result)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis solution efficiently calculates the permutation for each test case by starting with the maximum possible sum and adjusting it to match the desired K.",
    "no_parent": false,
    "dependency_used": false
}