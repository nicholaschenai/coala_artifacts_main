{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['2', '0 1', '1 -1'] Output: YES\n\nTests failed:\nNone",
    "code": "\ndef check_zebras_spitting(t, zebra_data):\n    # Dictionary to store the positions that can be hit by zebras\n    spit_positions = {}\n    \n    # Populate the dictionary with positions each zebra can hit\n    for a, b in zebra_data:\n        hit_position = a + b\n        spit_positions[hit_position] = a\n    \n    # Check if any zebra is hit by another and can hit back\n    for a, b in zebra_data:\n        if a in spit_positions:\n            if spit_positions[a] == a + b:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# First line is the number of zebras\nt = int(data[0])\n\n# Following lines are the positions and spit distances of each zebra\nzebra_data = []\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    zebra_data.append((a, b))\n    index += 2\n\n# Output the result\nprint(check_zebras_spitting(t, zebra_data))\n",
    "full_code": "\ndef check_zebras_spitting(t, zebra_data):\n    # Dictionary to store the positions that can be hit by zebras\n    spit_positions = {}\n    \n    # Populate the dictionary with positions each zebra can hit\n    for a, b in zebra_data:\n        hit_position = a + b\n        spit_positions[hit_position] = a\n    \n    # Check if any zebra is hit by another and can hit back\n    for a, b in zebra_data:\n        if a in spit_positions:\n            if spit_positions[a] == a + b:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# First line is the number of zebras\nt = int(data[0])\n\n# Following lines are the positions and spit distances of each zebra\nzebra_data = []\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    zebra_data.append((a, b))\n    index += 2\n\n# Output the result\nprint(check_zebras_spitting(t, zebra_data))\n",
    "reward": true,
    "program_code": "\ndef check_zebras_spitting(t, zebra_data):\n    # Dictionary to store the positions that can be hit by zebras\n    spit_positions = {}\n    \n    # Populate the dictionary with positions each zebra can hit\n    for a, b in zebra_data:\n        hit_position = a + b\n        spit_positions[hit_position] = a\n    \n    # Check if any zebra is hit by another and can hit back\n    for a, b in zebra_data:\n        if a in spit_positions:\n            if spit_positions[a] == a + b:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# First line is the number of zebras\nt = int(data[0])\n\n# Following lines are the positions and spit distances of each zebra\nzebra_data = []\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    zebra_data.append((a, b))\n    index += 2\n\n# Output the result\nprint(check_zebras_spitting(t, zebra_data))\n",
    "program_name": "check_zebras_spitting",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n\n   We have a number of zebras in a jungle, each positioned at a unique location. Each zebra can spit a certain distance either to the left or right. We need to determine if there are any two zebras that spit at each other. This means if one zebra spits and hits another, the second zebra should also spit back and hit the first one.\n\n2. **Conceptualize a solution in plain English:**\n\n   - For each zebra, calculate the position it can hit by adding its spit distance to its position.\n   - Store these positions in a dictionary where the key is the position a zebra can hit, and the value is the position of the zebra that can hit it.\n   - For each zebra, check if its position is a key in the dictionary, and if the zebra at that position can hit back the original zebra. If such a pair is found, output \"YES\". If no such pair is found after checking all zebras, output \"NO\".\n\n3. **Write a pseudocode solution:**\n\n   ```\n   function check_zebras_spitting(t, zebra_data):\n       create an empty dictionary called spit_positions\n       \n       for each zebra in zebra_data:\n           calculate the hit_position as zebra's position + spit distance\n           store in spit_positions with hit_position as key and zebra's position as value\n       \n       for each zebra in zebra_data:\n           if zebra's position is in spit_positions:\n               if spit_positions[zebra's position] equals zebra's position + spit distance:\n                   return \"YES\"\n       \n       return \"NO\"\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n\n```python\ndef check_zebras_spitting(t, zebra_data):\n    # Dictionary to store the positions that can be hit by zebras\n    spit_positions = {}\n    \n    # Populate the dictionary with positions each zebra can hit\n    for a, b in zebra_data:\n        hit_position = a + b\n        spit_positions[hit_position] = a\n    \n    # Check if any zebra is hit by another and can hit back\n    for a, b in zebra_data:\n        if a in spit_positions:\n            if spit_positions[a] == a + b:\n                return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# First line is the number of zebras\nt = int(data[0])\n\n# Following lines are the positions and spit distances of each zebra\nzebra_data = []\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    zebra_data.append((a, b))\n    index += 2\n\n# Output the result\nprint(check_zebras_spitting(t, zebra_data))\n```\n\nThis code reads the input, processes the zebra data, and checks if any two zebras spit at each other, outputting \"YES\" if they do and \"NO\" otherwise.",
    "no_parent": false,
    "dependency_used": false
}