{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['10 3', '1', '3', '7', '6', '-1', '5', '-1', '18', '9', '11', '2', '-1', '4'] Expected output: [{'7'}, {'6'}, {'18'}] # Execution output: []\nNo output detected. You might want to check the reading from / writing to standard IO.\nA common mistake is to put the IO inside a function, but the function is not called.\n",
    "code": "\nimport sys\nimport heapq\n\ndef execute_wealthiest():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Max-heap to store the wealth of citizens\n    max_heap = []\n    \n    # To store the results of each king's visit\n    results = []\n    \n    # Process each line after the first line\n    for i in range(2, len(data)):\n        value = int(data[i])\n        \n        if value == -1:\n            # King's visit, pop the richest citizen\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n        else:\n            # Citizen's wealth, push it onto the heap\n            heapq.heappush(max_heap, -value)\n    \n    # Output the results for each king's visit\n    for result in results:\n        print(result)\n\n",
    "full_code": "\nimport sys\nimport heapq\n\ndef execute_wealthiest():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Max-heap to store the wealth of citizens\n    max_heap = []\n    \n    # To store the results of each king's visit\n    results = []\n    \n    # Process each line after the first line\n    for i in range(2, len(data)):\n        value = int(data[i])\n        \n        if value == -1:\n            # King's visit, pop the richest citizen\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n        else:\n            # Citizen's wealth, push it onto the heap\n            heapq.heappush(max_heap, -value)\n    \n    # Output the results for each king's visit\n    for result in results:\n        print(result)\n\n",
    "reward": false,
    "program_code": "\nimport sys\nimport heapq\n\ndef execute_wealthiest():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Max-heap to store the wealth of citizens\n    max_heap = []\n    \n    # To store the results of each king's visit\n    results = []\n    \n    # Process each line after the first line\n    for i in range(2, len(data)):\n        value = int(data[i])\n        \n        if value == -1:\n            # King's visit, pop the richest citizen\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n        else:\n            # Citizen's wealth, push it onto the heap\n            heapq.heappush(max_heap, -value)\n    \n    # Output the results for each king's visit\n    for result in results:\n        print(result)\n\n",
    "program_name": "execute_wealthiest",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nThe problem involves a kingdom where citizens declare their wealth in court. The king occasionally visits the court, and during each visit, the richest citizen who has appeared so far and is still alive is executed. The task is to determine the wealth of the citizen executed during each of the king's visits.\n\n### Conceptual Solution\n\n1. **Data Structure Choice**: Use a max-heap to efficiently track the richest citizen who is still alive. A max-heap allows us to quickly retrieve and remove the maximum element.\n\n2. **Processing Input**: As we process each line of input:\n   - If it's a positive integer, it represents a citizen's wealth. Add this wealth to the max-heap.\n   - If it's `-1`, it represents a king's visit. Remove the richest citizen from the heap and record their wealth.\n\n3. **Output**: For each king's visit, output the wealth of the citizen who is executed.\n\n### Pseudocode\n\n1. Initialize an empty max-heap.\n2. For each line in the input:\n   - If the line is a positive integer, push it onto the max-heap.\n   - If the line is `-1`, pop the maximum element from the max-heap and record it as the wealth of the executed citizen.\n3. Print the recorded wealths for each king's visit.\n\n### Python Code\n\n```python\nimport sys\nimport heapq\n\ndef execute_wealthiest():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    # Max-heap to store the wealth of citizens\n    max_heap = []\n    \n    # To store the results of each king's visit\n    results = []\n    \n    # Process each line after the first line\n    for i in range(2, len(data)):\n        value = int(data[i])\n        \n        if value == -1:\n            # King's visit, pop the richest citizen\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n        else:\n            # Citizen's wealth, push it onto the heap\n            heapq.heappush(max_heap, -value)\n    \n    # Output the results for each king's visit\n    for result in results:\n        print(result)\n\n```\n\n### Explanation of the Code\n\n- **Heapq Module**: We use Python's `heapq` module, which implements a min-heap. To simulate a max-heap, we store negative values.\n- **Input Handling**: We read all input at once and split it into a list of strings for processing.\n- **Heap Operations**: \n  - When a citizen's wealth is declared, we push the negative of their wealth onto the heap.\n  - When the king visits, we pop the smallest element from the heap (which corresponds to the largest wealth due to negation) and record it.\n- **Output**: We print the wealth of the executed citizen for each king's visit.",
    "no_parent": false,
    "dependency_used": false
}