{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['4 1', '    0 1', '    0 -1', '    1 0', '   -1 0', ''] Output: ['5.656854249492380']\n\nTests failed:\nNone",
    "code": "\ndef main():\n    import sys\n    import math\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = float(data[1])\n    \n    # Calculate the angle theta\n    theta = math.atan(M)\n    cos_theta = math.cos(theta)\n    sin_theta = math.sin(theta)\n    \n    min_x_rot = float('inf')\n    max_x_rot = float('-inf')\n    min_y_rot = float('inf')\n    max_y_rot = float('-inf')\n    \n    index = 2\n    for _ in range(N):\n        x = float(data[index])\n        y = float(data[index + 1])\n        index += 2\n        \n        # Rotate the coordinates\n        x_rot = x * cos_theta - y * sin_theta\n        y_rot = x * sin_theta + y * cos_theta\n        \n        # Update min and max for rotated coordinates\n        if x_rot < min_x_rot:\n            min_x_rot = x_rot\n        if x_rot > max_x_rot:\n            max_x_rot = x_rot\n        if y_rot < min_y_rot:\n            min_y_rot = y_rot\n        if y_rot > max_y_rot:\n            max_y_rot = y_rot\n    \n    # Calculate width and height in the rotated space\n    width = max_x_rot - min_x_rot\n    height = max_y_rot - min_y_rot\n    \n    # Calculate the perimeter\n    perimeter = 2 * (width + height)\n    \n    # Print the result with high precision\n    print(f\"{perimeter:.12f}\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\ndef main():\n    import sys\n    import math\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = float(data[1])\n    \n    # Calculate the angle theta\n    theta = math.atan(M)\n    cos_theta = math.cos(theta)\n    sin_theta = math.sin(theta)\n    \n    min_x_rot = float('inf')\n    max_x_rot = float('-inf')\n    min_y_rot = float('inf')\n    max_y_rot = float('-inf')\n    \n    index = 2\n    for _ in range(N):\n        x = float(data[index])\n        y = float(data[index + 1])\n        index += 2\n        \n        # Rotate the coordinates\n        x_rot = x * cos_theta - y * sin_theta\n        y_rot = x * sin_theta + y * cos_theta\n        \n        # Update min and max for rotated coordinates\n        if x_rot < min_x_rot:\n            min_x_rot = x_rot\n        if x_rot > max_x_rot:\n            max_x_rot = x_rot\n        if y_rot < min_y_rot:\n            min_y_rot = y_rot\n        if y_rot > max_y_rot:\n            max_y_rot = y_rot\n    \n    # Calculate width and height in the rotated space\n    width = max_x_rot - min_x_rot\n    height = max_y_rot - min_y_rot\n    \n    # Calculate the perimeter\n    perimeter = 2 * (width + height)\n    \n    # Print the result with high precision\n    print(f\"{perimeter:.12f}\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": true,
    "program_code": "\ndef main():\n    import sys\n    import math\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = float(data[1])\n    \n    # Calculate the angle theta\n    theta = math.atan(M)\n    cos_theta = math.cos(theta)\n    sin_theta = math.sin(theta)\n    \n    min_x_rot = float('inf')\n    max_x_rot = float('-inf')\n    min_y_rot = float('inf')\n    max_y_rot = float('-inf')\n    \n    index = 2\n    for _ in range(N):\n        x = float(data[index])\n        y = float(data[index + 1])\n        index += 2\n        \n        # Rotate the coordinates\n        x_rot = x * cos_theta - y * sin_theta\n        y_rot = x * sin_theta + y * cos_theta\n        \n        # Update min and max for rotated coordinates\n        if x_rot < min_x_rot:\n            min_x_rot = x_rot\n        if x_rot > max_x_rot:\n            max_x_rot = x_rot\n        if y_rot < min_y_rot:\n            min_y_rot = y_rot\n        if y_rot > max_y_rot:\n            max_y_rot = y_rot\n    \n    # Calculate width and height in the rotated space\n    width = max_x_rot - min_x_rot\n    height = max_y_rot - min_y_rot\n    \n    # Calculate the perimeter\n    perimeter = 2 * (width + height)\n    \n    # Print the result with high precision\n    print(f\"{perimeter:.12f}\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "```python\ndef main():\n    import sys\n    import math\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = float(data[1])\n    \n    # Calculate the angle theta\n    theta = math.atan(M)\n    cos_theta = math.cos(theta)\n    sin_theta = math.sin(theta)\n    \n    min_x_rot = float('inf')\n    max_x_rot = float('-inf')\n    min_y_rot = float('inf')\n    max_y_rot = float('-inf')\n    \n    index = 2\n    for _ in range(N):\n        x = float(data[index])\n        y = float(data[index + 1])\n        index += 2\n        \n        # Rotate the coordinates\n        x_rot = x * cos_theta - y * sin_theta\n        y_rot = x * sin_theta + y * cos_theta\n        \n        # Update min and max for rotated coordinates\n        if x_rot < min_x_rot:\n            min_x_rot = x_rot\n        if x_rot > max_x_rot:\n            max_x_rot = x_rot\n        if y_rot < min_y_rot:\n            min_y_rot = y_rot\n        if y_rot > max_y_rot:\n            max_y_rot = y_rot\n    \n    # Calculate width and height in the rotated space\n    width = max_x_rot - min_x_rot\n    height = max_y_rot - min_y_rot\n    \n    # Calculate the perimeter\n    perimeter = 2 * (width + height)\n    \n    # Print the result with high precision\n    print(f\"{perimeter:.12f}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code correctly rotates the points to align with the slope \\( M \\) and calculates the perimeter of the bounding rectangle. The transformation uses a rotation matrix derived from the angle \\(\\theta\\) calculated using the arctangent of \\( M \\). This ensures that the rectangle's sides are aligned with the specified slope, and the perimeter is computed accurately.",
    "no_parent": false,
    "dependency_used": false
}