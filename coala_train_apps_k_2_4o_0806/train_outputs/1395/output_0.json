{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['1', '2 6'] Output: 3\n\nTests failed:\nNone",
    "code": "\ndef countDivisors(n):\n    if n == 0:\n        return -1\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count\n\ndef solve(T, test_cases):\n    results = []\n    for A, B in test_cases:\n        diff = abs(A - B)\n        if diff == 0:\n            results.append(-1)\n        else:\n            results.append(countDivisors(diff))\n    return results\n\n# Reading input and outputting results\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    A = int(data[index])\n    B = int(data[index + 1])\n    test_cases.append((A, B))\n    index += 2\n\nresults = solve(T, test_cases)\nfor result in results:\n    print(result)\n",
    "full_code": "\ndef countDivisors(n):\n    if n == 0:\n        return -1\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count\n\ndef solve(T, test_cases):\n    results = []\n    for A, B in test_cases:\n        diff = abs(A - B)\n        if diff == 0:\n            results.append(-1)\n        else:\n            results.append(countDivisors(diff))\n    return results\n\n# Reading input and outputting results\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    A = int(data[index])\n    B = int(data[index + 1])\n    test_cases.append((A, B))\n    index += 2\n\nresults = solve(T, test_cases)\nfor result in results:\n    print(result)\n",
    "reward": true,
    "program_code": "\ndef countDivisors(n):\n    if n == 0:\n        return -1\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count\n\ndef solve(T, test_cases):\n    results = []\n    for A, B in test_cases:\n        diff = abs(A - B)\n        if diff == 0:\n            results.append(-1)\n        else:\n            results.append(countDivisors(diff))\n    return results\n\n# Reading input and outputting results\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    A = int(data[index])\n    B = int(data[index + 1])\n    test_cases.append((A, B))\n    index += 2\n\nresults = solve(T, test_cases)\nfor result in results:\n    print(result)\n",
    "program_name": "solve",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nRam and Shyam want to cheat on an exam by getting the same set of questions. The exam board has `p` different sets of questions, and each student gets a set based on their roll number `r` using the formula `((r-1) % p)`. Given the roll numbers `A` and `B` for Ram and Shyam, we need to determine how many values of `p` allow them to get the same set of questions. If there are infinitely many such values, we should return `-1`.\n\n### Conceptual Solution\n\n1. **Understanding the Condition**: For Ram and Shyam to get the same set, the condition `((A-1) % p) == ((B-1) % p)` must hold. This implies that `(A-1) % p` and `(B-1) % p` must be equal.\n\n2. **Simplifying the Condition**: The condition can be rewritten as `(A-1) % p == (B-1) % p`, which implies `(A-1) - (B-1) = k * p` for some integer `k`. This simplifies to `(A-B) % p == 0`.\n\n3. **Finding Valid `p` Values**: The number of valid `p` values is the number of divisors of `|A-B|`. If `A == B`, then `|A-B| = 0`, and any positive integer `p` will satisfy the condition, leading to infinitely many solutions.\n\n4. **Algorithm**:\n   - For each test case, calculate `|A-B|`.\n   - If `A == B`, output `-1` (infinite solutions).\n   - Otherwise, count the divisors of `|A-B|` to determine the number of valid `p` values.\n\n### Pseudocode\n\n```\nfunction countDivisors(n):\n    if n == 0:\n        return -1\n    count = 0\n    for i from 1 to sqrt(n):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n\nfunction solve(T, test_cases):\n    results = []\n    for each (A, B) in test_cases:\n        diff = abs(A - B)\n        if diff == 0:\n            results.append(-1)\n        else:\n            results.append(countDivisors(diff))\n    return results\n```\n\n### Final Python Solution\n\n```python\ndef countDivisors(n):\n    if n == 0:\n        return -1\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count\n\ndef solve(T, test_cases):\n    results = []\n    for A, B in test_cases:\n        diff = abs(A - B)\n        if diff == 0:\n            results.append(-1)\n        else:\n            results.append(countDivisors(diff))\n    return results\n\n# Reading input and outputting results\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\ntest_cases = []\nindex = 1\nfor _ in range(T):\n    A = int(data[index])\n    B = int(data[index + 1])\n    test_cases.append((A, B))\n    index += 2\n\nresults = solve(T, test_cases)\nfor result in results:\n    print(result)\n```\n\nThis solution reads the input, processes each test case to determine the number of valid `p` values, and outputs the result for each test case.",
    "no_parent": false,
    "dependency_used": false
}