{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: [[2, 2, 2, 1, 1]] Output: True\n\nTests failed:\nNone",
    "code": "\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums or sum(nums) % 4 != 0:\n            return False\n        \n        target = sum(nums) // 4\n        nums.sort(reverse=True)\n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n",
    "full_code": "\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums or sum(nums) % 4 != 0:\n            return False\n        \n        target = sum(nums) // 4\n        nums.sort(reverse=True)\n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n",
    "reward": true,
    "program_code": "\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums or sum(nums) % 4 != 0:\n            return False\n        \n        target = sum(nums) // 4\n        nums.sort(reverse=True)\n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n",
    "program_name": "",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe need to determine if we can use all given matchsticks to form a square. Each matchstick can only be used once, and we cannot break any matchstick. The goal is to check if it's possible to arrange the matchsticks such that they form a square with equal sides.\n\n### Conceptual Solution\n\n1. **Check Total Length**: First, calculate the total length of all matchsticks. If this total is not divisible by 4, it's impossible to form a square, so we return `False`.\n\n2. **Target Side Length**: If the total length is divisible by 4, the target length for each side of the square is `total_length / 4`.\n\n3. **Backtracking Approach**: Use a backtracking approach to try and form the square:\n   - Sort the matchsticks in descending order to optimize the backtracking process (larger sticks are harder to place, so try them first).\n   - Attempt to place each matchstick into one of the four sides, ensuring that no side exceeds the target length.\n   - If all matchsticks are placed successfully, return `True`.\n\n4. **Base Case**: If all matchsticks are used and each side equals the target length, return `True`.\n\n5. **Pruning**: If at any point a side exceeds the target length, backtrack and try a different configuration.\n\n### Pseudocode\n\n```\nfunction makesquare(nums):\n    if nums is empty or sum(nums) % 4 != 0:\n        return False\n    \n    target = sum(nums) / 4\n    sort nums in descending order\n    sides = [0, 0, 0, 0]\n    \n    function backtrack(index):\n        if index == length of nums:\n            return all sides are equal to target\n        \n        for i from 0 to 3:\n            if sides[i] + nums[index] <= target:\n                sides[i] += nums[index]\n                if backtrack(index + 1):\n                    return True\n                sides[i] -= nums[index]\n        \n        return False\n    \n    return backtrack(0)\n```\n\n### Final Python Solution\n\n```python\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums or sum(nums) % 4 != 0:\n            return False\n        \n        target = sum(nums) // 4\n        nums.sort(reverse=True)\n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n```\n\n### Explanation of the Code\n\n- **Initial Checks**: We first check if the total length of matchsticks is divisible by 4. If not, forming a square is impossible.\n- **Sorting**: We sort the matchsticks in descending order to optimize the backtracking process.\n- **Backtracking Function**: The `backtrack` function attempts to place each matchstick into one of the four sides. If a valid configuration is found, it returns `True`.\n- **Pruning**: If adding a matchstick to a side exceeds the target length, we backtrack and try a different configuration.\n- **Base Case**: If all matchsticks are placed and each side equals the target length, the function returns `True`.",
    "no_parent": false,
    "dependency_used": false
}