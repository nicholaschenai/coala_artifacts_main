{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['2', '3', '2'] Output: YES\n010\n001\n100\nNO\n\nTests failed:\nNone",
    "code": "\ndef solve_tournament(T, test_cases):\n    for N in test_cases:\n        if N % 2 == 0:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            for i in range(N):\n                row = []\n                for j in range(N):\n                    if i == j:\n                        row.append('0')\n                    elif (j - i + N) % N <= (N - 1) // 2:\n                        row.append('1')\n                    else:\n                        row.append('0')\n                print(\"\".join(row))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    test_cases = [int(data[i]) for i in range(1, T + 1)]\n    \n    solve_tournament(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\ndef solve_tournament(T, test_cases):\n    for N in test_cases:\n        if N % 2 == 0:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            for i in range(N):\n                row = []\n                for j in range(N):\n                    if i == j:\n                        row.append('0')\n                    elif (j - i + N) % N <= (N - 1) // 2:\n                        row.append('1')\n                    else:\n                        row.append('0')\n                print(\"\".join(row))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    test_cases = [int(data[i]) for i in range(1, T + 1)]\n    \n    solve_tournament(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": true,
    "program_code": "\ndef solve_tournament(T, test_cases):\n    for N in test_cases:\n        if N % 2 == 0:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            for i in range(N):\n                row = []\n                for j in range(N):\n                    if i == j:\n                        row.append('0')\n                    elif (j - i + N) % N <= (N - 1) // 2:\n                        row.append('1')\n                    else:\n                        row.append('0')\n                print(\"\".join(row))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    test_cases = [int(data[i]) for i in range(1, T + 1)]\n    \n    solve_tournament(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe need to determine if it's possible for each player in a tennis tournament to win the same number of matches. If it is possible, we should provide a schedule of matches where each player wins the same number of matches. Each player plays against every other player exactly once, and there are no ties.\n\n### Conceptual Solution\n\n1. **Understanding the Problem**: \n   - Each player plays \\( N-1 \\) matches (since they play against every other player once).\n   - For each player to win the same number of matches, the total number of matches \\( \\frac{N(N-1)}{2} \\) must be divisible by \\( N \\).\n\n2. **Feasibility Check**:\n   - If \\( N \\) is even, it's impossible for each player to win the same number of matches because the total number of matches is odd, and an odd number cannot be evenly distributed among an even number of players.\n   - If \\( N \\) is odd, it is possible because the total number of matches is even, and it can be evenly distributed among the players.\n\n3. **Constructing the Schedule**:\n   - For odd \\( N \\), we can construct a round-robin schedule where each player wins exactly \\( \\frac{N-1}{2} \\) matches.\n   - This can be achieved by using a cyclic pattern where each player beats the next \\( \\frac{N-1}{2} \\) players in a circular manner.\n\n### Pseudocode\n\n```\nfunction solve_tournament(T, test_cases):\n    for each N in test_cases:\n        if N is even:\n            print \"NO\"\n        else:\n            print \"YES\"\n            for i from 0 to N-1:\n                row = []\n                for j from 0 to N-1:\n                    if i == j:\n                        row.append('0')\n                    else if (j - i + N) % N <= (N-1)/2:\n                        row.append('1')\n                    else:\n                        row.append('0')\n                print row as a string\n```\n\n### Final Python Solution\n\n```python\ndef solve_tournament(T, test_cases):\n    for N in test_cases:\n        if N % 2 == 0:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            for i in range(N):\n                row = []\n                for j in range(N):\n                    if i == j:\n                        row.append('0')\n                    elif (j - i + N) % N <= (N - 1) // 2:\n                        row.append('1')\n                    else:\n                        row.append('0')\n                print(\"\".join(row))\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    test_cases = [int(data[i]) for i in range(1, T + 1)]\n    \n    solve_tournament(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation of the Code\n\n- **Input Handling**: We read the number of test cases and the list of \\( N \\) values.\n- **Feasibility Check**: For each \\( N \\), we check if it is even. If it is, we print \"NO\" because it's impossible to distribute wins evenly.\n- **Schedule Construction**: For odd \\( N \\), we construct a schedule using a cyclic pattern. Each player \\( i \\) wins against the next \\( \\frac{N-1}{2} \\) players in a circular manner.\n- **Output**: We print the constructed schedule for each test case.",
    "no_parent": false,
    "dependency_used": false
}