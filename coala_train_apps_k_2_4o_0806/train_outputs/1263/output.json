{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['2', '4 1', '38 2'] Output: 2\n1\n\nTests failed:\nNone",
    "code": "\ndef countWays(N, K):\n    # Memoization dictionary to store results of subproblems\n    memo = {}\n    \n    def helper(remaining, start):\n        # Base case: if remaining is 0, we found a valid combination\n        if remaining == 0:\n            return 1\n        # If remaining is negative, this path is invalid\n        if remaining < 0:\n            return 0\n        # Check if the result is already computed\n        if (remaining, start) in memo:\n            return memo[(remaining, start)]\n        \n        count = 0\n        # Try each number starting from 'start'\n        for i in range(start, N + 1):\n            power = i ** K\n            # If the power exceeds the remaining sum, break early\n            if power > remaining:\n                break\n            # Recurse with the reduced sum and next starting number\n            count += helper(remaining - power, i + 1)\n        \n        # Store the result in memoization dictionary\n        memo[(remaining, start)] = count\n        return count\n    \n    # Start the helper function with the full sum N and starting number 1\n    return helper(N, 1)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        results.append(countWays(N, K))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\ndef countWays(N, K):\n    # Memoization dictionary to store results of subproblems\n    memo = {}\n    \n    def helper(remaining, start):\n        # Base case: if remaining is 0, we found a valid combination\n        if remaining == 0:\n            return 1\n        # If remaining is negative, this path is invalid\n        if remaining < 0:\n            return 0\n        # Check if the result is already computed\n        if (remaining, start) in memo:\n            return memo[(remaining, start)]\n        \n        count = 0\n        # Try each number starting from 'start'\n        for i in range(start, N + 1):\n            power = i ** K\n            # If the power exceeds the remaining sum, break early\n            if power > remaining:\n                break\n            # Recurse with the reduced sum and next starting number\n            count += helper(remaining - power, i + 1)\n        \n        # Store the result in memoization dictionary\n        memo[(remaining, start)] = count\n        return count\n    \n    # Start the helper function with the full sum N and starting number 1\n    return helper(N, 1)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        results.append(countWays(N, K))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": true,
    "program_code": "\ndef countWays(N, K):\n    # Memoization dictionary to store results of subproblems\n    memo = {}\n    \n    def helper(remaining, start):\n        # Base case: if remaining is 0, we found a valid combination\n        if remaining == 0:\n            return 1\n        # If remaining is negative, this path is invalid\n        if remaining < 0:\n            return 0\n        # Check if the result is already computed\n        if (remaining, start) in memo:\n            return memo[(remaining, start)]\n        \n        count = 0\n        # Try each number starting from 'start'\n        for i in range(start, N + 1):\n            power = i ** K\n            # If the power exceeds the remaining sum, break early\n            if power > remaining:\n                break\n            # Recurse with the reduced sum and next starting number\n            count += helper(remaining - power, i + 1)\n        \n        # Store the result in memoization dictionary\n        memo[(remaining, start)] = count\n        return count\n    \n    # Start the helper function with the full sum N and starting number 1\n    return helper(N, 1)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        results.append(countWays(N, K))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe need to determine the number of ways to express a given natural number \\( N \\) as the sum of unique positive integers raised to the power \\( K \\). For each test case, we are given \\( N \\) and \\( K \\), and we need to find the number of unique combinations of integers whose \\( K \\)-th powers sum up to \\( N \\).\n\n## Conceptual Solution\n\n1. **Understanding the Problem**:\n   - We need to find combinations of unique integers such that their \\( K \\)-th powers sum up to \\( N \\).\n   - For example, if \\( N = 4 \\) and \\( K = 1 \\), the valid combinations are [4] and [1, 3].\n\n2. **Recursive Approach**:\n   - Use a recursive function to explore all possible combinations of integers.\n   - Start with the smallest integer and try to build up to \\( N \\) using the \\( K \\)-th powers of integers.\n   - Ensure that each combination uses unique integers.\n\n3. **Backtracking**:\n   - Use backtracking to explore different combinations.\n   - If a combination exceeds \\( N \\), backtrack and try a different path.\n   - If a combination exactly equals \\( N \\), count it as a valid way.\n\n4. **Optimization**:\n   - Use memoization to store results of subproblems to avoid redundant calculations.\n\n## Pseudocode\n\n```\nfunction countWays(N, K):\n    memo = {}\n    \n    function helper(remaining, start):\n        if remaining == 0:\n            return 1\n        if remaining < 0:\n            return 0\n        if (remaining, start) in memo:\n            return memo[(remaining, start)]\n        \n        count = 0\n        for i from start to N:\n            power = i^K\n            if power > remaining:\n                break\n            count += helper(remaining - power, i + 1)\n        \n        memo[(remaining, start)] = count\n        return count\n    \n    return helper(N, 1)\n\nfunction main():\n    read T\n    for each test case:\n        read N, K\n        print countWays(N, K)\n```\n\n## Final Python Solution\n\n```python\ndef countWays(N, K):\n    # Memoization dictionary to store results of subproblems\n    memo = {}\n    \n    def helper(remaining, start):\n        # Base case: if remaining is 0, we found a valid combination\n        if remaining == 0:\n            return 1\n        # If remaining is negative, this path is invalid\n        if remaining < 0:\n            return 0\n        # Check if the result is already computed\n        if (remaining, start) in memo:\n            return memo[(remaining, start)]\n        \n        count = 0\n        # Try each number starting from 'start'\n        for i in range(start, N + 1):\n            power = i ** K\n            # If the power exceeds the remaining sum, break early\n            if power > remaining:\n                break\n            # Recurse with the reduced sum and next starting number\n            count += helper(remaining - power, i + 1)\n        \n        # Store the result in memoization dictionary\n        memo[(remaining, start)] = count\n        return count\n    \n    # Start the helper function with the full sum N and starting number 1\n    return helper(N, 1)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        results.append(countWays(N, K))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis solution uses a recursive approach with memoization to efficiently count the number of ways to express \\( N \\) as the sum of unique integers raised to the power \\( K \\). The `helper` function explores all possible combinations using backtracking, and memoization ensures that we do not recompute results for the same subproblems.",
    "no_parent": false,
    "dependency_used": false
}