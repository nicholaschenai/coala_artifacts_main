{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['3 2', '3 1 2', '2 3 1', ''] Output: 3 2 1\n3 1 2 \n\nTests failed:\nNone",
    "code": "\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i == -1:\n        # If no such element is found, return the sorted permutation\n        return sorted(perm)\n    # Find the smallest element larger than perm[i] to the right\n    j = n - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    # Swap them\n    perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    results = []\n    \n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i == -1:\n        # If no such element is found, return the sorted permutation\n        return sorted(perm)\n    # Find the smallest element larger than perm[i] to the right\n    j = n - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    # Swap them\n    perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    results = []\n    \n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": true,
    "program_code": "\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i == -1:\n        # If no such element is found, return the sorted permutation\n        return sorted(perm)\n    # Find the smallest element larger than perm[i] to the right\n    j = n - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    # Swap them\n    perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    results = []\n    \n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe are given a permutation of numbers from 1 to N, and we need to find the next permutation in lexicographic order. The input consists of multiple permutations, and for each permutation, we need to output its next lexicographic permutation.\n\n## Conceptual Solution\n\n1. **Understanding Lexicographic Order**:\n   - Lexicographic order is similar to dictionary order. For permutations, it means arranging numbers in the smallest possible order that is greater than the current permutation.\n\n2. **Finding the Next Permutation**:\n   - Start from the end of the permutation and find the first pair where the earlier number is smaller than the later number. This identifies the point where the order can be increased.\n   - Swap this number with the smallest number to its right that is larger than it.\n   - Reverse the sequence to the right of the original position to get the smallest possible order.\n\n3. **Steps**:\n   - Traverse the permutation from right to left to find the first decreasing element.\n   - If no such element is found, the permutation is the last one, and we should return the first permutation (sorted order).\n   - Otherwise, find the smallest element larger than this element to the right, swap them, and reverse the sequence to the right.\n\n## Pseudocode\n\n```\nfunction next_permutation(perm):\n    n = length of perm\n    i = n - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i == -1:\n        return perm sorted in ascending order\n    j = n - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    swap perm[i] and perm[j]\n    reverse perm from i + 1 to end\n    return perm\n\nfunction main():\n    read N and K\n    for each permutation in input:\n        result = next_permutation(permutation)\n        print result\n```\n\n## Final Python Solution\n\n```python\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i == -1:\n        # If no such element is found, return the sorted permutation\n        return sorted(perm)\n    # Find the smallest element larger than perm[i] to the right\n    j = n - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    # Swap them\n    perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    results = []\n    \n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis solution reads the input, processes each permutation to find its next lexicographic permutation, and outputs the result. The `next_permutation` function implements the logic to find the next permutation efficiently.",
    "no_parent": false,
    "dependency_used": false
}