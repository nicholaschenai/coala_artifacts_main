{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['4', '', '1', '0', '', '3', '0', '0', '1 1 2', '', '3', '0', '0', '2 1 2', '', '5', '0', '0', '0', '2 1 2', '1 3 4', '', ''] Expected output: 0.50000\n0.29289\n0.70711\n0.40303 # Execution output: None # Runtime error or time limit exceeded error",
    "code": "\ndef calculate_probability(node, nodes):\n    if nodes[node][0] == 0:  # Input node\n        return None  # Probability is dependent on p\n    elif nodes[node][0] == 1:  # OR gate\n        a, b = nodes[node][1], nodes[node][2]\n        return lambda p: 1 - (1 - calculate_probability(a, nodes)(p)) * (1 - calculate_probability(b, nodes)(p))\n    elif nodes[node][0] == 2:  # AND gate\n        a, b = nodes[node][1], nodes[node][2]\n        return lambda p: calculate_probability(a, nodes)(p) * calculate_probability(b, nodes)(p)\n\ndef find_p_for_half_probability(nodes):\n    low, high = 0.0, 1.0\n    while high - low > 1e-7:  # Precision for binary search\n        mid = (low + high) / 2\n        if calculate_probability(len(nodes) - 1, nodes)(mid) < 0.5:\n            low = mid\n        else:\n            high = mid\n    return (low + high) / 2\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    results = []\n    T = int(data[index])\n    index += 1\n    \n    for _ in range(T):\n        if data[index] == '':\n            index += 1  # Skip blank line\n        n = int(data[index])\n        index += 1\n        \n        nodes = []\n        for i in range(n):\n            line = list(map(int, data[index].split()))\n            if line[0] == 0:\n                nodes.append((0,))  # Input node\n            else:\n                nodes.append((line[0], line[1] - 1, line[2] - 1))  # Gate node\n            index += 1\n        \n        p = find_p_for_half_probability(nodes)\n        results.append(f\"{p:.5f}\")\n    \n    print(\"\\n\".join(results))\n\nmain()\n",
    "full_code": "\ndef calculate_probability(node, nodes):\n    if nodes[node][0] == 0:  # Input node\n        return None  # Probability is dependent on p\n    elif nodes[node][0] == 1:  # OR gate\n        a, b = nodes[node][1], nodes[node][2]\n        return lambda p: 1 - (1 - calculate_probability(a, nodes)(p)) * (1 - calculate_probability(b, nodes)(p))\n    elif nodes[node][0] == 2:  # AND gate\n        a, b = nodes[node][1], nodes[node][2]\n        return lambda p: calculate_probability(a, nodes)(p) * calculate_probability(b, nodes)(p)\n\ndef find_p_for_half_probability(nodes):\n    low, high = 0.0, 1.0\n    while high - low > 1e-7:  # Precision for binary search\n        mid = (low + high) / 2\n        if calculate_probability(len(nodes) - 1, nodes)(mid) < 0.5:\n            low = mid\n        else:\n            high = mid\n    return (low + high) / 2\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    results = []\n    T = int(data[index])\n    index += 1\n    \n    for _ in range(T):\n        if data[index] == '':\n            index += 1  # Skip blank line\n        n = int(data[index])\n        index += 1\n        \n        nodes = []\n        for i in range(n):\n            line = list(map(int, data[index].split()))\n            if line[0] == 0:\n                nodes.append((0,))  # Input node\n            else:\n                nodes.append((line[0], line[1] - 1, line[2] - 1))  # Gate node\n            index += 1\n        \n        p = find_p_for_half_probability(nodes)\n        results.append(f\"{p:.5f}\")\n    \n    print(\"\\n\".join(results))\n\nmain()\n",
    "reward": false,
    "program_code": "\ndef calculate_probability(node, nodes):\n    if nodes[node][0] == 0:  # Input node\n        return None  # Probability is dependent on p\n    elif nodes[node][0] == 1:  # OR gate\n        a, b = nodes[node][1], nodes[node][2]\n        return lambda p: 1 - (1 - calculate_probability(a, nodes)(p)) * (1 - calculate_probability(b, nodes)(p))\n    elif nodes[node][0] == 2:  # AND gate\n        a, b = nodes[node][1], nodes[node][2]\n        return lambda p: calculate_probability(a, nodes)(p) * calculate_probability(b, nodes)(p)\n\ndef find_p_for_half_probability(nodes):\n    low, high = 0.0, 1.0\n    while high - low > 1e-7:  # Precision for binary search\n        mid = (low + high) / 2\n        if calculate_probability(len(nodes) - 1, nodes)(mid) < 0.5:\n            low = mid\n        else:\n            high = mid\n    return (low + high) / 2\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    results = []\n    T = int(data[index])\n    index += 1\n    \n    for _ in range(T):\n        if data[index] == '':\n            index += 1  # Skip blank line\n        n = int(data[index])\n        index += 1\n        \n        nodes = []\n        for i in range(n):\n            line = list(map(int, data[index].split()))\n            if line[0] == 0:\n                nodes.append((0,))  # Input node\n            else:\n                nodes.append((line[0], line[1] - 1, line[2] - 1))  # Gate node\n            index += 1\n        \n        p = find_p_for_half_probability(nodes)\n        results.append(f\"{p:.5f}\")\n    \n    print(\"\\n\".join(results))\n\nmain()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\nThe problem involves calculating the probability \\( p \\) such that the output of a digital circuit composed of AND and OR gates is 1 with a probability of exactly 1/2. Each input bit is set to 1 independently with probability \\( p \\). The circuit is defined by a series of nodes, where each node can either be an input (0) or a gate (1 for OR, 2 for AND) that takes inputs from previous nodes.\n\n### Conceptual Solution\nTo solve this problem, we need to:\n1. Parse the input to understand the structure of the circuit.\n2. Represent the circuit as a directed acyclic graph (DAG) where nodes are either inputs or gates.\n3. Use a recursive approach to calculate the probability of the output node being 1 based on the probabilities of its input nodes.\n4. Find the value of \\( p \\) such that the output probability equals 1/2.\n\nThe output probability for each gate can be computed as follows:\n- For an AND gate, the output is 1 if both inputs are 1: \\( P(\\text{output}) = p_a \\cdot p_b \\).\n- For an OR gate, the output is 1 if at least one input is 1: \\( P(\\text{output}) = 1 - (1 - p_a)(1 - p_b) \\).\n\n### Pseudocode\n1. Read the number of test cases.\n2. For each test case:\n   - Read the number of nodes.\n   - Construct a list to hold the nodes.\n   - For each node, determine if it is an input or a gate and store its dependencies.\n3. Define a recursive function to calculate the output probability of the final node.\n4. Use a binary search to find the value of \\( p \\) such that the output probability equals 1/2.\n5. Print the result formatted to five decimal places.\n\n### Final Python Solution\n```python\ndef calculate_probability(node, nodes):\n    if nodes[node][0] == 0:  # Input node\n        return None  # Probability is dependent on p\n    elif nodes[node][0] == 1:  # OR gate\n        a, b = nodes[node][1], nodes[node][2]\n        return lambda p: 1 - (1 - calculate_probability(a, nodes)(p)) * (1 - calculate_probability(b, nodes)(p))\n    elif nodes[node][0] == 2:  # AND gate\n        a, b = nodes[node][1], nodes[node][2]\n        return lambda p: calculate_probability(a, nodes)(p) * calculate_probability(b, nodes)(p)\n\ndef find_p_for_half_probability(nodes):\n    low, high = 0.0, 1.0\n    while high - low > 1e-7:  # Precision for binary search\n        mid = (low + high) / 2\n        if calculate_probability(len(nodes) - 1, nodes)(mid) < 0.5:\n            low = mid\n        else:\n            high = mid\n    return (low + high) / 2\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    index = 0\n    results = []\n    T = int(data[index])\n    index += 1\n    \n    for _ in range(T):\n        if data[index] == '':\n            index += 1  # Skip blank line\n        n = int(data[index])\n        index += 1\n        \n        nodes = []\n        for i in range(n):\n            line = list(map(int, data[index].split()))\n            if line[0] == 0:\n                nodes.append((0,))  # Input node\n            else:\n                nodes.append((line[0], line[1] - 1, line[2] - 1))  # Gate node\n            index += 1\n        \n        p = find_p_for_half_probability(nodes)\n        results.append(f\"{p:.5f}\")\n    \n    print(\"\\n\".join(results))\n\nmain()\n``` \n\nThis code reads the input, constructs the circuit, calculates the required probabilities, and finds the value of \\( p \\) that results in an output probability of 1/2, formatted to five decimal places.",
    "no_parent": false,
    "dependency_used": false
}