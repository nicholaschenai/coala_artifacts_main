{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['1', '2 6'] Output: 3\n\nTests failed:\nNone",
    "code": "\ndef count_divisors(n):\n    count = 0\n    # Loop through all numbers from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Count i\n            if i != n // i:  # If i and n/i are different\n                count += 1  # Count n/i as well\n    return count\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])  # Read number of test cases\n    results = []\n    \n    for i in range(1, T + 1):\n        A, B = map(int, data[i].split())  # Read each test case\n        if A == B:\n            results.append(-1)  # Infinite solutions if A equals B\n        else:\n            diff = abs(A - B)  # Calculate the absolute difference\n            divisors_count = count_divisors(diff)  # Count the divisors of the difference\n            results.append(divisors_count)  # Store the result\n    \n    for res in results:\n        print(res)  # Print all results\n\nsolve()\n",
    "full_code": "\ndef count_divisors(n):\n    count = 0\n    # Loop through all numbers from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Count i\n            if i != n // i:  # If i and n/i are different\n                count += 1  # Count n/i as well\n    return count\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])  # Read number of test cases\n    results = []\n    \n    for i in range(1, T + 1):\n        A, B = map(int, data[i].split())  # Read each test case\n        if A == B:\n            results.append(-1)  # Infinite solutions if A equals B\n        else:\n            diff = abs(A - B)  # Calculate the absolute difference\n            divisors_count = count_divisors(diff)  # Count the divisors of the difference\n            results.append(divisors_count)  # Store the result\n    \n    for res in results:\n        print(res)  # Print all results\n\nsolve()\n",
    "reward": true,
    "program_code": "\ndef count_divisors(n):\n    count = 0\n    # Loop through all numbers from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Count i\n            if i != n // i:  # If i and n/i are different\n                count += 1  # Count n/i as well\n    return count\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])  # Read number of test cases\n    results = []\n    \n    for i in range(1, T + 1):\n        A, B = map(int, data[i].split())  # Read each test case\n        if A == B:\n            results.append(-1)  # Infinite solutions if A equals B\n        else:\n            diff = abs(A - B)  # Calculate the absolute difference\n            divisors_count = count_divisors(diff)  # Count the divisors of the difference\n            results.append(divisors_count)  # Store the result\n    \n    for res in results:\n        print(res)  # Print all results\n\nsolve()\n",
    "program_name": "solve",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**:\n   Ram and Shyam have roll numbers A and B, respectively. They will receive the same set of exam questions if the modulo operation of their roll numbers with respect to the number of question sets (p) yields the same result. We need to determine how many values of p allow them to receive the same set of questions, or if there are infinitely many such values.\n\n2. **Conceptualize a solution first in plain English**:\n   To find the values of p for which Ram and Shyam can cheat, we need to check when the results of the modulo operation for their roll numbers are equal. This can be expressed as:\n   \\[\n   (A - 1) \\% p = (B - 1) \\% p\n   \\]\n   This simplifies to:\n   \\[\n   (A - B) \\% p = 0\n   \\]\n   This means that p must be a divisor of the absolute difference between A and B. If A equals B, they will always receive the same set of questions for any p (infinite solutions). If A is not equal to B, we can count the divisors of the absolute difference to find the number of valid p values.\n\n3. **Write a pseudocode solution**:\n   ```\n   function count_divisors(n):\n       count = 0\n       for i from 1 to sqrt(n):\n           if n % i == 0:\n               count += 1\n               if i != n / i:\n                   count += 1\n       return count\n\n   function solve():\n       read T\n       for each test case:\n           read A, B\n           if A == B:\n               print -1\n           else:\n               diff = abs(A - B)\n               divisors_count = count_divisors(diff)\n               print divisors_count\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\ndef count_divisors(n):\n    count = 0\n    # Loop through all numbers from 1 to the square root of n\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:  # If i is a divisor of n\n            count += 1  # Count i\n            if i != n // i:  # If i and n/i are different\n                count += 1  # Count n/i as well\n    return count\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    T = int(data[0])  # Read number of test cases\n    results = []\n    \n    for i in range(1, T + 1):\n        A, B = map(int, data[i].split())  # Read each test case\n        if A == B:\n            results.append(-1)  # Infinite solutions if A equals B\n        else:\n            diff = abs(A - B)  # Calculate the absolute difference\n            divisors_count = count_divisors(diff)  # Count the divisors of the difference\n            results.append(divisors_count)  # Store the result\n    \n    for res in results:\n        print(res)  # Print all results\n\nsolve()\n```",
    "no_parent": false,
    "dependency_used": false
}