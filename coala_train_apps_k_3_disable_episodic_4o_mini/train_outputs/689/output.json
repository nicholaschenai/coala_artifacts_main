{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['2', '0 1', '1 -1'] Output: YES\n\nTests failed:\nNone",
    "code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # Read number of zebras\n    spit_map = {}  # Dictionary to store zebra positions and their spit distances\n    \n    # Read each zebra's position and spit distance\n    for i in range(1, t + 1):\n        a, b = map(int, data[i].split())\n        spit_map[a] = b  # Store position a with spit distance b\n    \n    # Check for each zebra if it spits at another zebra that spits back\n    for a in spit_map:\n        b = spit_map[a]  # Get the spit distance of zebra at position a\n        target_position = a + b  # Calculate where it spits to\n        \n        # Check if the target position exists in the map\n        if target_position in spit_map:\n            # Check if the zebra at target_position spits back to a\n            if spit_map[target_position] == -b:\n                print(\"YES\")\n                return\n    \n    print(\"NO\")  # If no pairs found, print NO\n\n# Call the solve function to execute the code\nsolve()\n",
    "full_code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # Read number of zebras\n    spit_map = {}  # Dictionary to store zebra positions and their spit distances\n    \n    # Read each zebra's position and spit distance\n    for i in range(1, t + 1):\n        a, b = map(int, data[i].split())\n        spit_map[a] = b  # Store position a with spit distance b\n    \n    # Check for each zebra if it spits at another zebra that spits back\n    for a in spit_map:\n        b = spit_map[a]  # Get the spit distance of zebra at position a\n        target_position = a + b  # Calculate where it spits to\n        \n        # Check if the target position exists in the map\n        if target_position in spit_map:\n            # Check if the zebra at target_position spits back to a\n            if spit_map[target_position] == -b:\n                print(\"YES\")\n                return\n    \n    print(\"NO\")  # If no pairs found, print NO\n\n# Call the solve function to execute the code\nsolve()\n",
    "reward": true,
    "program_code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # Read number of zebras\n    spit_map = {}  # Dictionary to store zebra positions and their spit distances\n    \n    # Read each zebra's position and spit distance\n    for i in range(1, t + 1):\n        a, b = map(int, data[i].split())\n        spit_map[a] = b  # Store position a with spit distance b\n    \n    # Check for each zebra if it spits at another zebra that spits back\n    for a in spit_map:\n        b = spit_map[a]  # Get the spit distance of zebra at position a\n        target_position = a + b  # Calculate where it spits to\n        \n        # Check if the target position exists in the map\n        if target_position in spit_map:\n            # Check if the zebra at target_position spits back to a\n            if spit_map[target_position] == -b:\n                print(\"YES\")\n                return\n    \n    print(\"NO\")  # If no pairs found, print NO\n\n# Call the solve function to execute the code\nsolve()\n",
    "program_name": "solve",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**:\n   The problem involves determining if there are two zebras in a jungle that spit at each other. Each zebra has a position and a distance it spits. If a zebra at position `a` spits `b` meters, it can hit another zebra at position `a + b`. We need to check if there exists a pair of zebras such that one spits at the other and vice versa.\n\n2. **Conceptualize a solution first in plain English**:\n   To solve this problem, we can use a dictionary to map each zebra's position to the distance it spits. For each zebra, we will check if the position it spits to contains another zebra that spits back to its original position. If such a pair is found, we will output \"YES\". If we finish checking all zebras without finding such a pair, we will output \"NO\".\n\n3. **Write a pseudocode solution**:\n   ```\n   Initialize an empty dictionary to store zebra positions and their spit distances\n   Read the number of zebras\n   For each zebra:\n       Read its position and spit distance\n       Store the position and spit distance in the dictionary\n   For each zebra:\n       Calculate the position it spits to\n       Check if that position exists in the dictionary\n       If it exists, check if the spit distance from that position points back to the original zebra's position\n       If both conditions are met, print \"YES\" and exit\n   If no pairs are found, print \"NO\"\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])  # Read number of zebras\n    spit_map = {}  # Dictionary to store zebra positions and their spit distances\n    \n    # Read each zebra's position and spit distance\n    for i in range(1, t + 1):\n        a, b = map(int, data[i].split())\n        spit_map[a] = b  # Store position a with spit distance b\n    \n    # Check for each zebra if it spits at another zebra that spits back\n    for a in spit_map:\n        b = spit_map[a]  # Get the spit distance of zebra at position a\n        target_position = a + b  # Calculate where it spits to\n        \n        # Check if the target position exists in the map\n        if target_position in spit_map:\n            # Check if the zebra at target_position spits back to a\n            if spit_map[target_position] == -b:\n                print(\"YES\")\n                return\n    \n    print(\"NO\")  # If no pairs found, print NO\n\n# Call the solve function to execute the code\nsolve()\n```",
    "no_parent": false,
    "dependency_used": false
}