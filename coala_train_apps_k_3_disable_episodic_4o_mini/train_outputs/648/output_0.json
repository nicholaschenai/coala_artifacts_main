{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['5 3', '1 2 3 4 5', '1 1 2', '2 3 4 -1', '1 1 2'] Output: 3\n4\n\nTests failed:\nNone",
    "code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    N, Q = map(int, data[index].split())  # Read number of hills and operations\n    index += 1\n    A = list(map(int, data[index].split()))  # Read initial heights of the hills\n    index += 1\n    \n    results = []\n    \n    for _ in range(Q):\n        operation = list(map(int, data[index].split()))  # Read operation\n        index += 1\n        \n        if operation[0] == 1:  # Type 1 operation\n            i, k = operation[1], operation[2]\n            current_index = i - 1  # Convert to 0-based index\n            jumps = 0\n            \n            while jumps < k:\n                next_index = current_index + 1\n                found = False\n                \n                # Find the nearest higher hill within the next 100 hills\n                while next_index < N and next_index <= current_index + 100:\n                    if A[next_index] > A[current_index]:\n                        current_index = next_index\n                        found = True\n                        break\n                    next_index += 1\n                \n                if not found:  # No valid hill found\n                    break\n                \n                jumps += 1\n            \n            results.append(current_index + 1)  # Convert back to 1-based index\n        \n        elif operation[0] == 2:  # Type 2 operation\n            L, R, X = operation[1], operation[2], operation[3]\n            for j in range(L - 1, R):  # Update heights from L to R\n                A[j] += X\n    \n    # Print all results for Type 1 operations\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\n# Call the solve function to execute the code\nsolve()\n",
    "full_code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    N, Q = map(int, data[index].split())  # Read number of hills and operations\n    index += 1\n    A = list(map(int, data[index].split()))  # Read initial heights of the hills\n    index += 1\n    \n    results = []\n    \n    for _ in range(Q):\n        operation = list(map(int, data[index].split()))  # Read operation\n        index += 1\n        \n        if operation[0] == 1:  # Type 1 operation\n            i, k = operation[1], operation[2]\n            current_index = i - 1  # Convert to 0-based index\n            jumps = 0\n            \n            while jumps < k:\n                next_index = current_index + 1\n                found = False\n                \n                # Find the nearest higher hill within the next 100 hills\n                while next_index < N and next_index <= current_index + 100:\n                    if A[next_index] > A[current_index]:\n                        current_index = next_index\n                        found = True\n                        break\n                    next_index += 1\n                \n                if not found:  # No valid hill found\n                    break\n                \n                jumps += 1\n            \n            results.append(current_index + 1)  # Convert back to 1-based index\n        \n        elif operation[0] == 2:  # Type 2 operation\n            L, R, X = operation[1], operation[2], operation[3]\n            for j in range(L - 1, R):  # Update heights from L to R\n                A[j] += X\n    \n    # Print all results for Type 1 operations\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\n# Call the solve function to execute the code\nsolve()\n",
    "reward": true,
    "program_code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    N, Q = map(int, data[index].split())  # Read number of hills and operations\n    index += 1\n    A = list(map(int, data[index].split()))  # Read initial heights of the hills\n    index += 1\n    \n    results = []\n    \n    for _ in range(Q):\n        operation = list(map(int, data[index].split()))  # Read operation\n        index += 1\n        \n        if operation[0] == 1:  # Type 1 operation\n            i, k = operation[1], operation[2]\n            current_index = i - 1  # Convert to 0-based index\n            jumps = 0\n            \n            while jumps < k:\n                next_index = current_index + 1\n                found = False\n                \n                # Find the nearest higher hill within the next 100 hills\n                while next_index < N and next_index <= current_index + 100:\n                    if A[next_index] > A[current_index]:\n                        current_index = next_index\n                        found = True\n                        break\n                    next_index += 1\n                \n                if not found:  # No valid hill found\n                    break\n                \n                jumps += 1\n            \n            results.append(current_index + 1)  # Convert back to 1-based index\n        \n        elif operation[0] == 2:  # Type 2 operation\n            L, R, X = operation[1], operation[2], operation[3]\n            for j in range(L - 1, R):  # Update heights from L to R\n                A[j] += X\n    \n    # Print all results for Type 1 operations\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\n# Call the solve function to execute the code\nsolve()\n",
    "program_name": "solve",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**:\n   The problem involves a competition where participants jump between hills of varying heights. Each participant starts at a specified hill and must jump to the nearest higher hill to the right a certain number of times. If there are no higher hills within a distance of 100 hills, the participant remains on their current hill. Additionally, there are operations to increase or decrease the heights of a range of hills.\n\n2. **Conceptualize a solution first in plain English**:\n   We need to handle two types of operations:\n   - For the first type, we will simulate the jumps starting from a given hill and count how many jumps can be made to higher hills, stopping if we reach the maximum number of jumps or if there are no valid hills to jump to.\n   - For the second type, we will update the heights of a specified range of hills by a given amount.\n   To efficiently find the nearest higher hill, we can iterate through the hills to the right of the current hill, checking their heights.\n\n3. **Write a pseudocode solution**:\n   ```\n   function solve():\n       read N, Q\n       read heights array A of size N\n       \n       for each operation in Q:\n           if operation type is 1:\n               read i, k\n               current_index = i - 1  # convert to 0-based index\n               jumps = 0\n               while jumps < k:\n                   next_index = current_index + 1\n                   found = False\n                   while next_index < N and next_index <= current_index + 100:\n                       if A[next_index] > A[current_index]:\n                           current_index = next_index\n                           found = True\n                           break\n                       next_index += 1\n                   if not found:\n                       break\n                   jumps += 1\n               print(current_index + 1)  # convert back to 1-based index\n           \n           else if operation type is 2:\n               read L, R, X\n               for j from L-1 to R-1:\n                   A[j] += X\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    index = 0\n    N, Q = map(int, data[index].split())  # Read number of hills and operations\n    index += 1\n    A = list(map(int, data[index].split()))  # Read initial heights of the hills\n    index += 1\n    \n    results = []\n    \n    for _ in range(Q):\n        operation = list(map(int, data[index].split()))  # Read operation\n        index += 1\n        \n        if operation[0] == 1:  # Type 1 operation\n            i, k = operation[1], operation[2]\n            current_index = i - 1  # Convert to 0-based index\n            jumps = 0\n            \n            while jumps < k:\n                next_index = current_index + 1\n                found = False\n                \n                # Find the nearest higher hill within the next 100 hills\n                while next_index < N and next_index <= current_index + 100:\n                    if A[next_index] > A[current_index]:\n                        current_index = next_index\n                        found = True\n                        break\n                    next_index += 1\n                \n                if not found:  # No valid hill found\n                    break\n                \n                jumps += 1\n            \n            results.append(current_index + 1)  # Convert back to 1-based index\n        \n        elif operation[0] == 2:  # Type 2 operation\n            L, R, X = operation[1], operation[2], operation[3]\n            for j in range(L - 1, R):  # Update heights from L to R\n                A[j] += X\n    \n    # Print all results for Type 1 operations\n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\n# Call the solve function to execute the code\nsolve()\n```",
    "no_parent": false,
    "dependency_used": false
}