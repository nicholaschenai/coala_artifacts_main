{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['3 3', '16 24 60', '498 861 589', '14 24 62', '72 557 819', '16 15 69', '435 779 232'] Output: 2\n1\n3\n\nTests failed:\nNone",
    "code": "\ndef main():\n    # Read number of problems and subtasks\n    P, S = map(int, input().split())\n    difficulties = []\n    \n    for i in range(1, P + 1):\n        # Read scores and number of contestants for each problem\n        scores = list(map(int, input().split()))\n        contestants = list(map(int, input().split()))\n        \n        # Pair scores with contestants and sort by score\n        paired = sorted(zip(scores, contestants))\n        \n        # Count the number of valid indices where NS_k > NS_{k + 1}\n        n = 0\n        for k in range(1, S):\n            if paired[k - 1][1] > paired[k][1]:\n                n += 1\n        \n        # Store the difficulty as a tuple (n, i)\n        difficulties.append((n, i))\n    \n    # Sort difficulties by (n, i)\n    difficulties.sort()\n    \n    # Output the indices of the problems in increasing order of difficulty\n    for difficulty in difficulties:\n        print(difficulty[1])\n\n# Call the main function to execute the code\nmain()\n",
    "full_code": "\ndef main():\n    # Read number of problems and subtasks\n    P, S = map(int, input().split())\n    difficulties = []\n    \n    for i in range(1, P + 1):\n        # Read scores and number of contestants for each problem\n        scores = list(map(int, input().split()))\n        contestants = list(map(int, input().split()))\n        \n        # Pair scores with contestants and sort by score\n        paired = sorted(zip(scores, contestants))\n        \n        # Count the number of valid indices where NS_k > NS_{k + 1}\n        n = 0\n        for k in range(1, S):\n            if paired[k - 1][1] > paired[k][1]:\n                n += 1\n        \n        # Store the difficulty as a tuple (n, i)\n        difficulties.append((n, i))\n    \n    # Sort difficulties by (n, i)\n    difficulties.sort()\n    \n    # Output the indices of the problems in increasing order of difficulty\n    for difficulty in difficulties:\n        print(difficulty[1])\n\n# Call the main function to execute the code\nmain()\n",
    "reward": true,
    "program_code": "\ndef main():\n    # Read number of problems and subtasks\n    P, S = map(int, input().split())\n    difficulties = []\n    \n    for i in range(1, P + 1):\n        # Read scores and number of contestants for each problem\n        scores = list(map(int, input().split()))\n        contestants = list(map(int, input().split()))\n        \n        # Pair scores with contestants and sort by score\n        paired = sorted(zip(scores, contestants))\n        \n        # Count the number of valid indices where NS_k > NS_{k + 1}\n        n = 0\n        for k in range(1, S):\n            if paired[k - 1][1] > paired[k][1]:\n                n += 1\n        \n        # Store the difficulty as a tuple (n, i)\n        difficulties.append((n, i))\n    \n    # Sort difficulties by (n, i)\n    difficulties.sort()\n    \n    # Output the indices of the problems in increasing order of difficulty\n    for difficulty in difficulties:\n        print(difficulty[1])\n\n# Call the main function to execute the code\nmain()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "1. **Restatement of the Problem**:\n   The problem involves determining the difficulty of several contest problems based on their subtasks. Each problem has a set of subtasks, each with a score and the number of contestants who solved it. The difficulty of a problem is defined by counting how many times the number of contestants who solved a subtask decreases as we move to the next subtask when sorted by score. We need to sort the problems based on their difficulty and output their indices in increasing order.\n\n2. **Conceptualization of a Solution**:\n   - Read the number of problems (P) and the number of subtasks (S).\n   - For each problem, read the scores and the number of contestants who solved each subtask.\n   - Pair the scores with the number of contestants and sort them by score.\n   - Count the number of valid indices where the number of contestants decreases as we move to the next subtask.\n   - Store the difficulty as a tuple (n, i) where n is the count of decreases and i is the problem index.\n   - Sort the list of difficulties and output the indices of the problems in the required order.\n\n3. **Pseudocode Solution**:\n   ```\n   function main():\n       read P, S\n       difficulties = []\n       \n       for i from 1 to P:\n           read scores\n           read contestants\n           pair scores with contestants\n           sort pairs by score\n           n = 0\n           for k from 1 to S-1:\n               if contestants[k-1] > contestants[k]:\n                   n += 1\n           difficulties.append((n, i))\n       \n       sort difficulties by (n, i)\n       for each difficulty in difficulties:\n           print difficulty[1]\n   ```\n\n4. **Final Python 3 Solution**:\n```python\ndef main():\n    # Read number of problems and subtasks\n    P, S = map(int, input().split())\n    difficulties = []\n    \n    for i in range(1, P + 1):\n        # Read scores and number of contestants for each problem\n        scores = list(map(int, input().split()))\n        contestants = list(map(int, input().split()))\n        \n        # Pair scores with contestants and sort by score\n        paired = sorted(zip(scores, contestants))\n        \n        # Count the number of valid indices where NS_k > NS_{k + 1}\n        n = 0\n        for k in range(1, S):\n            if paired[k - 1][1] > paired[k][1]:\n                n += 1\n        \n        # Store the difficulty as a tuple (n, i)\n        difficulties.append((n, i))\n    \n    # Sort difficulties by (n, i)\n    difficulties.sort()\n    \n    # Output the indices of the problems in increasing order of difficulty\n    for difficulty in difficulties:\n        print(difficulty[1])\n\n# Call the main function to execute the code\nmain()\n```",
    "no_parent": false,
    "dependency_used": false
}