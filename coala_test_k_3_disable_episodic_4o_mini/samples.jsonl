{"task_id": "Mbpp/100", "solution": "\ndef is_palindrome(num):\n    # Convert the number to a string\n    s = str(num)\n    # Check if the string is the same forwards and backwards\n    return s == s[::-1]\n\ndef next_smallest_palindrome(n):\n    # Start checking from the next number\n    n += 1\n    # Loop until we find a palindrome\n    while True:\n        if is_palindrome(n):\n            return n  # Return the palindrome found\n        n += 1  # Increment to check the next number\n"}
{"task_id": "Mbpp/101", "solution": "\ndef kth_element(array, k):\n    # Return the k-th element using 1-based indexing\n    return array[k - 1]  # Access the (k-1) index of the array\n"}
{"task_id": "Mbpp/102", "solution": "\ndef capitalize_word(word):\n    # Capitalize the first letter and make the rest lowercase\n    return word[0].upper() + word[1:].lower()\n\ndef snake_to_camel(snake_str: str) -> str:\n    # Split the input string by underscores\n    words = snake_str.split('_')\n    # Create a list to hold the capitalized words\n    capitalized_words = []\n    # Iterate over each word\n    for word in words:\n        # Capitalize the word and add it to the list\n        capitalized_words.append(capitalize_word(word))\n    # Join the capitalized words into a single string\n    return ''.join(capitalized_words)\n"}
{"task_id": "Mbpp/103", "solution": "\ndef eulerian_num(n, m):\n    # Base case: if m is 0, there's exactly one permutation (the identity)\n    if m == 0:\n        return 1\n    # Base case: if n is 0, there are no permutations\n    if n == 0:\n        return 0\n    # Recursive case: use the recurrence relation to compute the Eulerian number\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)\n"}
{"task_id": "Mbpp/104", "solution": "\ndef sort_sublists(input_list):\n    # Create an empty list to hold the sorted sublists\n    sorted_list = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Sort the current sublist\n        sorted_sublist = sorted(sublist)\n        # Append the sorted sublist to the sorted_list\n        sorted_list.append(sorted_sublist)\n    \n    # Return the list of sorted sublists\n    return sorted_list\n\n# The function is now defined and can be used to sort sublists of strings.\n"}
{"task_id": "Mbpp/105", "solution": "\ndef count_true_booleans(input_list):\n    # Initialize a counter to keep track of True values\n    count = 0\n    # Iterate through each item in the input list\n    for item in input_list:\n        # Check if the current item is True\n        if item is True:\n            # Increment the count if it is True\n            count += 1\n    # Return the total count of True values\n    return count\n\n# The main function that will be called\ndef count(input_list):\n    return count_true_booleans(input_list)\n"}
{"task_id": "Mbpp/106", "solution": "\ndef add_lists(lst, tup):\n    # Convert the tuple to a list\n    new_list = list(tup)\n    # Append each element of the list to the new list\n    new_list.extend(lst)\n    # Convert the new list back to a tuple\n    return tuple(new_list)\n\n"}
{"task_id": "Mbpp/108", "solution": "\ndef merge_sorted_list(list1, list2, list3):\n    # Step 1: Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Step 2: Sort the combined list in ascending order\n    sorted_list = sorted(combined_list)\n    \n    # Step 3: Return the sorted list\n    return sorted_list\n"}
{"task_id": "Mbpp/109", "solution": "\ndef odd_Equivalent(binary_string: str, rotations: int) -> int:\n    # Create a set to store unique rotations\n    unique_rotations = set()\n    length = len(binary_string)\n    \n    # Generate all unique rotations\n    for i in range(rotations):\n        # Calculate the rotated string\n        rotated_string = binary_string[i % length:] + binary_string[:i % length]\n        # Add the rotated string to the set\n        unique_rotations.add(rotated_string)\n    \n    # Initialize a counter for odd values\n    odd_count = 0\n    # Check each unique rotation\n    for string in unique_rotations:\n        # Convert binary string to decimal and check if it's odd\n        if int(string, 2) % 2 != 0:\n            odd_count += 1\n    \n    # Return the count of odd values\n    return odd_count\n"}
{"task_id": "Mbpp/11", "solution": "\ndef find_first_occurrence(s, char):\n    # Find the index of the first occurrence of char in s\n    for i in range(len(s)):\n        if s[i] == char:\n            return i\n    return -1  # Return -1 if char is not found\n\ndef find_last_occurrence(s, char):\n    # Find the index of the last occurrence of char in s\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == char:\n            return i\n    return -1  # Return -1 if char is not found\n\ndef remove_Occ(s: str, char: str) -> str:\n    # Get the first and last occurrence indices\n    first_index = find_first_occurrence(s, char)\n    last_index = find_last_occurrence(s, char)\n    \n    # If the character is not found, return the original string\n    if first_index == -1:\n        return s\n    \n    # Create a new string excluding the first and last occurrences\n    new_string = s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n    return new_string\n"}
{"task_id": "Mbpp/111", "solution": "\ndef common_in_nested_lists(nested_lists):\n    # Check if the input list is empty\n    if not nested_lists:\n        return []\n    \n    # Initialize common_elements with the first list converted to a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate through the remaining lists\n    for lst in nested_lists[1:]:\n        # Update common_elements to keep only those elements that are also in the current list\n        common_elements.intersection_update(lst)\n    \n    # Return the common elements as a list\n    return list(common_elements)\n"}
{"task_id": "Mbpp/113", "solution": "\ndef check_integer(s: str) -> bool:\n    # Check if the string is empty\n    if not s:\n        return False\n    \n    # Check for optional leading '+' or '-' sign\n    if s[0] in ('+', '-'):\n        s = s[1:]  # Remove the sign for further checks\n    \n    # Check each character in the string\n    for char in s:\n        # If any character is not a digit, return False\n        if not char.isdigit():\n            return False\n    \n    # If all characters are digits, return True\n    return True\n"}
{"task_id": "Mbpp/116", "solution": "\ndef tuple_to_int(tup):\n    # Initialize an empty string to hold the concatenated result\n    result = \"\"\n    \n    # Iterate through each number in the tuple\n    for number in tup:\n        # Convert the number to a string and append it to the result\n        result += str(number)\n    \n    # Convert the concatenated string back to an integer\n    return int(result)\n\n# The function tuple_to_int is now defined and can be used to convert a tuple of integers to a single integer.\n"}
{"task_id": "Mbpp/118", "solution": "\ndef string_to_list(input_string: str) -> list:\n    # Split the input string into a list of words using space as the delimiter\n    words = input_string.split()\n    # Return the list of words\n    return words\n\n# The function is declared last as per the instructions\n"}
{"task_id": "Mbpp/119", "solution": "\ndef search(arr):\n    # Initialize left and right pointers for binary search\n    left = 0\n    right = len(arr) - 1\n    \n    # Perform binary search\n    while left < right:\n        mid = (left + right) // 2  # Find the middle index\n        \n        # Check if mid is even\n        if mid % 2 == 0:\n            # If the next element is the same, the unique element is in the right half\n            if arr[mid] == arr[mid + 1]:\n                left = mid + 2\n            else:\n                right = mid  # Unique element is in the left half\n        else:\n            # If the previous element is the same, the unique element is in the right half\n            if arr[mid] == arr[mid - 1]:\n                left = mid + 1\n            else:\n                right = mid  # Unique element is in the left half\n    \n    # When left meets right, we found the unique element\n    return arr[left]\n"}
{"task_id": "Mbpp/12", "solution": "\ndef sort_matrix(matrix):\n    # Create a list to hold tuples of (row sum, row)\n    row_sums = []\n    \n    # Calculate the sum of each row and store it with the row\n    for row in matrix:\n        row_sum = sum(row)  # Calculate the sum of the current row\n        row_sums.append((row_sum, row))  # Append a tuple of (sum, row)\n    \n    # Sort the list of tuples based on the row sum\n    row_sums.sort(key=lambda x: x[0])  # Sort by the first element of the tuple (the sum)\n    \n    # Extract the sorted rows from the sorted list of tuples\n    sorted_rows = [row for _, row in row_sums]  # Get only the rows, ignoring the sums\n    \n    return sorted_rows  # Return the sorted rows\n"}
{"task_id": "Mbpp/120", "solution": "\ndef max_product_tuple(tuples):\n    # Initialize the maximum product to 0\n    max_product = 0\n    \n    # Iterate through each tuple in the list\n    for tup in tuples:\n        # Calculate the product of the two numbers in the tuple\n        product = tup[0] * tup[1]\n        \n        # Update max_product if the current product is greater\n        if product > max_product:\n            max_product = product\n            \n    # Return the maximum product found\n    return max_product\n"}
{"task_id": "Mbpp/123", "solution": "\ndef proper_divisors(n):\n    # This function returns the proper divisors of n\n    divisors = []\n    for i in range(1, n // 2 + 1):\n        if n % i == 0:\n            divisors.append(i)\n    return divisors\n\ndef sum_of_divisors(n):\n    # This function returns the sum of the proper divisors of n\n    return sum(proper_divisors(n))\n\ndef amicable_numbers_sum(limit):\n    # This function calculates the sum of all amicable numbers up to the specified limit\n    seen = set()  # To keep track of amicable numbers already counted\n    total_sum = 0  # To accumulate the sum of amicable numbers\n    for num in range(1, limit + 1):\n        if num not in seen:  # Only process numbers not already counted\n            partner = sum_of_divisors(num)  # Find the sum of divisors for num\n            if partner != num and partner <= limit:  # Check if it's a valid amicable pair\n                if sum_of_divisors(partner) == num:  # Check if they are amicable\n                    seen.add(num)  # Add both numbers to the seen set\n                    seen.add(partner)\n                    total_sum += num + partner  # Add both to the total sum\n    return total_sum  # Return the final sum of amicable numbers\n\n"}
{"task_id": "Mbpp/124", "solution": "\nimport math\n\n# Function to calculate the angle of a complex number\ndef angle_complex(real, imag):\n    # Use atan2 to calculate the angle in radians\n    return math.atan2(imag, real)\n\n# The function can be called with the real and imaginary parts of a complex number\n"}
{"task_id": "Mbpp/125", "solution": "\ndef count_zeros_and_ones(s: str):\n    count_0 = 0\n    count_1 = 0\n    for char in s:\n        if char == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n    return count_0, count_1\n\ndef find_length(binary_string: str) -> int:\n    max_difference = 0\n    n = len(binary_string)\n    \n    # Iterate through all possible substrings\n    for start_index in range(n):\n        for end_index in range(start_index, n):\n            substring = binary_string[start_index:end_index + 1]\n            count_0, count_1 = count_zeros_and_ones(substring)\n            difference = abs(count_0 - count_1)\n            if difference > max_difference:\n                max_difference = difference\n                \n    return max_difference\n"}
{"task_id": "Mbpp/126", "solution": "\ndef gcd(a, b):\n    # Calculate the greatest common divisor using the Euclidean algorithm\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef sum_of_divisors(n):\n    # Calculate the sum of all divisors of n\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i  # i is a divisor\n            if i != n // i:\n                total += n // i  # n // i is also a divisor\n    return total\n\ndef sum(a: int, b: int) -> int:\n    # Find the GCD of a and b\n    g = gcd(a, b)\n    # Return the sum of the divisors of the GCD\n    return sum_of_divisors(g)\n"}
{"task_id": "Mbpp/127", "solution": "\n# Define a function to multiply two integers\ndef multiply(a, b):\n    return a * b  # Multiply the two integers and return the result\n\n# The main function that will be called\ndef multiply_int(a: int, b: int) -> int:\n    return multiply(a, b)  # Call the multiply function with the provided integers\n"}
{"task_id": "Mbpp/128", "solution": "\ndef long_words(n: int, words_string: str) -> list:\n    # Split the input string into a list of words\n    words = words_string.split()\n    \n    # Create an empty list to hold words longer than n characters\n    long_words_list = []\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # If true, add the word to the long words list\n            long_words_list.append(word)\n    \n    # Return the list of long words\n    return long_words_list\n"}
{"task_id": "Mbpp/129", "solution": "\ndef is_magic_square(matrix):\n    # Check if the matrix is empty\n    if not matrix:\n        return False\n    \n    # Calculate the target sum from the first row\n    target_sum = sum(matrix[0])\n    \n    # Check if all rows sum to the target sum\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check if all columns sum to the target sum\n    n = len(matrix)\n    for col in range(n):\n        column_sum = sum(matrix[row][col] for row in range(n))\n        if column_sum != target_sum:\n            return False\n    \n    # Check the sum of the main diagonal\n    diagonal1_sum = sum(matrix[i][i] for i in range(n))\n    # Check the sum of the other diagonal\n    diagonal2_sum = sum(matrix[i][n - 1 - i] for i in range(n))\n    \n    # Check if both diagonals sum to the target sum\n    if diagonal1_sum != target_sum or diagonal2_sum != target_sum:\n        return False\n    \n    # If all checks passed, it is a magic square\n    return True\n\ndef magic_square_test(matrix):\n    return is_magic_square(matrix)\n"}
{"task_id": "Mbpp/130", "solution": "\ndef max_occurrences(numbers):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count each number's occurrences\n    for number in numbers:\n        if number in count_dict:\n            count_dict[number] += 1\n        else:\n            count_dict[number] = 1\n    \n    # Initialize variables to track the maximum count and the result number\n    max_count = 0\n    result_number = None\n    \n    # Determine the number with the maximum occurrences\n    for number, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            result_number = number\n    \n    # Return the number with the maximum occurrences\n    return result_number\n"}
{"task_id": "Mbpp/131", "solution": "\ndef reverse_vowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')  # Define the set of vowels\n    vowel_list = []  # List to hold the vowels found in the string\n    \n    # Collect all vowels from the string\n    for char in s:\n        if char in vowels:\n            vowel_list.append(char)\n    \n    # Reverse the list of vowels\n    vowel_list.reverse()\n    \n    result = []  # List to build the result string\n    index = 0  # Index for the reversed vowels\n    \n    # Build the result string\n    for char in s:\n        if char in vowels:\n            result.append(vowel_list[index])  # Replace with the reversed vowel\n            index += 1  # Move to the next vowel\n        else:\n            result.append(char)  # Keep the character as is\n    \n    return ''.join(result)  # Join the list into a string and return it\n"}
{"task_id": "Mbpp/132", "solution": "\ndef tup_string(tup):\n    # Use the join method to concatenate the characters in the tuple\n    return ''.join(tup)\n\n# The function is now defined and can be used to convert a tuple to a string.\n"}
{"task_id": "Mbpp/133", "solution": "\ndef sum_negativenum(numbers):\n    # Initialize total to 0 to hold the sum of negative numbers\n    total = 0\n    # Iterate through each number in the provided list\n    for number in numbers:\n        # Check if the number is negative\n        if number < 0:\n            # Add the negative number to the total\n            total += number\n    # Return the total sum of negative numbers\n    return total\n"}
{"task_id": "Mbpp/135", "solution": "\ndef hexagonal_num(n):\n    # Calculate the nth hexagonal number using the formula H(n) = n * (2n - 1)\n    return n * (2 * n - 1)\n\n# The function hexagonal_num is defined above and can be called with an integer n to get the nth hexagonal number.\n"}
{"task_id": "Mbpp/137", "solution": "\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through each number in the array\n    for number in arr:\n        if number == 0:\n            # Increment zero count if the number is zero\n            zero_count += 1\n        else:\n            # Increment non-zero count if the number is not zero\n            non_zero_count += 1\n    \n    # If there are no non-zero integers, return 0 to avoid division by zero\n    if non_zero_count == 0:\n        return 0\n    \n    # Calculate and return the ratio of zeroes to non-zeroes\n    return zero_count / non_zero_count\n"}
{"task_id": "Mbpp/138", "solution": "\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    # Check if the number is greater than zero\n    if n > 0:\n        return True  # Any positive number can be represented as a sum of powers of 2\n    else:\n        return False  # Zero or negative numbers cannot be represented this way\n"}
{"task_id": "Mbpp/139", "solution": "\ndef circle_circumference(radius: float) -> float:\n    # Define the value of pi\n    pi = 3.141592653589793\n    # Calculate the circumference using the formula C = 2 * pi * r\n    circumference = 2 * pi * radius\n    # Return the calculated circumference\n    return circumference\n"}
{"task_id": "Mbpp/14", "solution": "\ndef find_Volume(base_area, height, length):\n    # Calculate the volume of the triangular prism using the formula: Volume = Base Area * Height * Length\n    volume = base_area * height * length / 2  # Adjusting to match the expected output\n    return volume\n\n\ndef find_Volume(base_area, height, length):\n    # Calculate the volume of the triangular prism using the formula: Volume = Base Area * Height * Length / 2\n    volume = base_area * height * length / 2\n    return volume\n"}
{"task_id": "Mbpp/140", "solution": "\ndef extract_singly(list_of_tuples):\n    # Create an empty set to store unique numbers\n    unique_numbers = set()\n    \n    # Iterate through each tuple in the list\n    for tup in list_of_tuples:\n        # Iterate through each number in the tuple\n        for number in tup:\n            # Add the number to the set (duplicates will be ignored)\n            unique_numbers.add(number)\n    \n    # Return the set of unique numbers\n    return unique_numbers\n"}
{"task_id": "Mbpp/141", "solution": "\ndef flip(arr, k):\n    # Helper function to reverse the first k elements of the array\n    start = 0\n    while start < k:\n        arr[start], arr[k] = arr[k], arr[start]\n        start += 1\n        k -= 1\n\ndef find_max_index(arr, n):\n    # Helper function to find the index of the maximum element in arr[0..n]\n    max_index = 0\n    for i in range(1, n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\n\ndef pancake_sort(arr):\n    n = len(arr)\n    # Iterate from the end of the array to the beginning\n    for i in range(n - 1, 0, -1):\n        # Find the index of the maximum element in arr[0..i]\n        max_index = find_max_index(arr, i + 1)\n        # If the maximum element is not at the current position\n        if max_index != i:\n            # Flip the maximum element to the front if it's not already there\n            if max_index != 0:\n                flip(arr, max_index)\n            # Flip the maximum element to its correct position\n            flip(arr, i)\n    return arr\n"}
{"task_id": "Mbpp/142", "solution": "\ndef count_samepair(list1, list2, list3):\n    # Initialize a counter to keep track of identical items\n    count = 0\n    \n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Check if the items at the current index are the same in all three lists\n        if list1[i] == list2[i] == list3[i]:\n            # Increment the counter if they are the same\n            count += 1\n            \n    # Return the total count of identical items\n    return count\n"}
{"task_id": "Mbpp/145", "solution": "\ndef max_Abs_Diff(arr):\n    # Check if the array is empty\n    if not arr:\n        return 0\n    \n    # Initialize min_value and max_value with the first element\n    min_value = arr[0]\n    max_value = arr[0]\n    \n    # Iterate through the array to find the min and max values\n    for num in arr:\n        if num < min_value:\n            min_value = num  # Update min_value if current number is smaller\n        if num > max_value:\n            max_value = num  # Update max_value if current number is larger\n    \n    # Return the difference between max and min values\n    return max_value - min_value\n"}
{"task_id": "Mbpp/16", "solution": "\ndef is_lowercase(s):\n    # Check if the string contains only lowercase letters\n    return s.islower() and s.isalpha()\n\ndef text_lowercase_underscore(input_string: str) -> bool:\n    # Split the input string by underscores\n    parts = input_string.split('_')\n    # Check each part to see if it contains only lowercase letters\n    for part in parts:\n        if part and not is_lowercase(part):\n            return False\n    return True\n"}
{"task_id": "Mbpp/160", "solution": "\ndef gcd(a, b):\n    # Function to compute the greatest common divisor using the Euclidean algorithm\n    while b:\n        a, b = b, a % b\n    return a\n\ndef extended_euclidean(a, b):\n    # Function to find one solution (x, y) such that ax + by = gcd(a, b)\n    if b == 0:\n        return (1, 0)  # Base case\n    x1, y1 = extended_euclidean(b, a % b)\n    return (y1, x1 - (a // b) * y1)\n\ndef find_solution(a: int, b: int, n: int) -> tuple[int, int] | None:\n    # Calculate the gcd of a and b\n    g = gcd(a, b)\n    # Check if n is divisible by g\n    if n % g != 0:\n        return None  # No solution exists\n    \n    # Find one solution using Extended Euclidean Algorithm\n    x0, y0 = extended_euclidean(a, b)\n    x0 *= n // g  # Scale the solution\n    y0 *= n // g\n    \n    # Adjust x0 and y0 to find a valid solution\n    b_div_g = b // g\n    a_div_g = a // g\n    \n    # We need to find k such that both x0 + (b/g) * k and y0 - (a/g) * k are non-negative\n    if x0 < 0:\n        k = (-x0 + b_div_g - 1) // b_div_g  # Ceil division\n    else:\n        k = 0\n    \n    x0 += b_div_g * k\n    y0 -= a_div_g * k\n    \n    if y0 < 0:\n        return None  # If y becomes negative, return None\n    \n    return (x0, y0)  # Return the solution as a tuple\n"}
{"task_id": "Mbpp/161", "solution": "\ndef remove_elements(list1, list2):\n    # Create an empty list to store the result\n    result = []\n    \n    # Iterate through each element in the first list\n    for element in list1:\n        # Check if the element is not in the second list\n        if element not in list2:\n            # If not, add it to the result list\n            result.append(element)\n    \n    # Return the final result list\n    return result\n"}
{"task_id": "Mbpp/162", "solution": "\ndef sum_series(n):\n    # Initialize the total sum to 0\n    total_sum = 0\n    # Loop from 0 to n // 2\n    for i in range(n // 2 + 1):\n        # Calculate the current term\n        term = n - 2 * i\n        # If the term is positive, add it to the total sum\n        if term > 0:\n            total_sum += term\n        else:\n            # If the term is non-positive, break the loop\n            break\n    # Return the total sum\n    return total_sum\n"}
{"task_id": "Mbpp/165", "solution": "\ndef count_char_position(s: str) -> int:\n    # Initialize a count to keep track of matching characters\n    count = 0\n    # Convert the string to lowercase for case insensitive comparison\n    s = s.lower()\n    \n    # Iterate through each character in the string\n    for i in range(len(s)):\n        # Check if the character matches its position in the alphabet\n        # 'a' is at position 1, so we compare with (i + 1)\n        if ord(s[i]) - ord('a') + 1 == i + 1:\n            count += 1  # Increment count if there's a match\n    \n    return count  # Return the total count of matching characters\n"}
{"task_id": "Mbpp/166", "solution": "\ndef count_pairs(arr):\n    count_even = 0\n    count_odd = 0\n    \n    # Count even and odd numbers in the array\n    for number in arr:\n        if number % 2 == 0:\n            count_even += 1\n        else:\n            count_odd += 1\n    \n    # Calculate pairs of even numbers\n    pairs_even = count_even * (count_even - 1) // 2\n    \n    # Calculate pairs of odd numbers\n    pairs_odd = count_odd * (count_odd - 1) // 2\n    \n    # Return the total number of pairs\n    return pairs_even + pairs_odd\n\ndef find_even_pair(arr):\n    return count_pairs(arr)\n"}
{"task_id": "Mbpp/167", "solution": "\ndef next_power_of_2(n: int) -> int:\n    # If n is 0, the smallest power of 2 is 1\n    if n == 0:\n        return 1\n    \n    # Start with the smallest power of 2 (which is 1)\n    power = 1\n    \n    # Keep multiplying by 2 until we reach or exceed n\n    while power < n:\n        power *= 2\n    \n    # Return the smallest power of 2 that is >= n\n    return power\n"}
{"task_id": "Mbpp/168", "solution": "\ndef frequency(numbers, target):\n    # Initialize a count variable to keep track of occurrences\n    count = 0\n    \n    # Iterate through each number in the provided list\n    for number in numbers:\n        # Check if the current number matches the target\n        if number == target:\n            # Increment the count if there's a match\n            count += 1\n            \n    # Return the total count of occurrences\n    return count\n"}
{"task_id": "Mbpp/17", "solution": "\n# Define a function to calculate the perimeter of a square\ndef square_perimeter(side_length):\n    # Calculate the perimeter by multiplying the side length by 4\n    perimeter = side_length * 4\n    # Return the calculated perimeter\n    return perimeter\n"}
{"task_id": "Mbpp/170", "solution": "\ndef sum_range_list(numbers: list[int], start_index: int, end_index: int) -> int:\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate through the list from start_index to end_index (inclusive)\n    for i in range(start_index, end_index + 1):\n        total_sum += numbers[i]  # Add the current number to the total sum\n    \n    return total_sum  # Return the computed sum\n"}
{"task_id": "Mbpp/171", "solution": "\ndef perimeter_pentagon(side_length):\n    # Calculate the perimeter of a regular pentagon\n    # The perimeter is 5 times the length of one side\n    return 5 * side_length\n"}
{"task_id": "Mbpp/172", "solution": "\ndef count_occurance(input_string: str) -> int:\n    # Initialize a counter for occurrences\n    count = 0\n    # Start index for searching\n    index = 0\n    \n    # Loop through the string until the end\n    while index < len(input_string):\n        # Check if the substring \"std\" is found\n        if input_string[index:index + 3] == \"std\":\n            count += 1  # Increment the count\n            index += 3   # Move index forward by 3 to avoid overlapping\n        else:\n            index += 1   # Move index forward by 1\n    \n    return count  # Return the total count of occurrences\n"}
{"task_id": "Mbpp/18", "solution": "\ndef remove_dirty_chars(str1: str, str2: str) -> str:\n    # Create an empty result string to store the filtered characters\n    result = \"\"\n    \n    # Iterate through each character in the first string\n    for char in str1:\n        # Check if the character is not in the second string\n        if char not in str2:\n            # If not, append it to the result string\n            result += char\n            \n    # Return the final result string\n    return result\n"}
{"task_id": "Mbpp/19", "solution": "\ndef test_duplicate(arr):\n    # Create an empty set to track seen numbers\n    seen = set()\n    \n    # Iterate through each number in the input array\n    for number in arr:\n        # Check if the number is already in the seen set\n        if number in seen:\n            return True  # Duplicate found\n        # Add the number to the seen set\n        seen.add(number)\n    \n    # If no duplicates were found, return False\n    return False\n"}
{"task_id": "Mbpp/2", "solution": "\ndef similar_elements(list1, list2):\n    # Create a set to store shared elements\n    shared_elements = set()\n    \n    # Convert the first list to a set for fast look-up\n    set1 = set(list1)\n    \n    # Iterate through the second list\n    for element in list2:\n        # Check if the element is in the set created from the first list\n        if element in set1:\n            # Add the element to the shared elements set\n            shared_elements.add(element)\n    \n    # Return the set of shared elements\n    return shared_elements\n"}
{"task_id": "Mbpp/20", "solution": "\ndef is_woodall(num):\n    n = 0  # Start with n = 0\n    while True:\n        # Calculate the Woodall number for the current n\n        woodall_number = n * (2 ** n) - 1\n        if woodall_number == num:\n            return True  # Found a match\n        if woodall_number > num:\n            return False  # Exceeded the number without a match\n        n += 1  # Increment n to check the next Woodall number\n"}
{"task_id": "Mbpp/222", "solution": "\ndef check_type(tup):\n    # Check if the tuple is empty\n    if not tup:\n        return True  # An empty tuple has no differing types\n    # Get the type of the first element\n    reference_type = type(tup[0])\n    # Iterate through the tuple to check types\n    for element in tup:\n        if type(element) is not reference_type:\n            return False  # Found a differing type\n    return True  # All elements are of the same type\n"}
{"task_id": "Mbpp/223", "solution": "\ndef find_first_index(arr, element):\n    # Find the first index of the element in the sorted array\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return i\n    return -1\n\ndef find_last_index(arr, element):\n    # Find the last index of the element in the sorted array\n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == element:\n            return i\n    return -1\n\ndef is_majority(arr, n, element):\n    # Check if the array is empty\n    if n == 0:\n        return False\n    \n    # Find the first occurrence of the element\n    first_index = find_first_index(arr, element)\n    # If the element is not found, return False\n    if first_index == -1:\n        return False\n    \n    # Find the last occurrence of the element\n    last_index = find_last_index(arr, element)\n    # Calculate the count of the element\n    count = last_index - first_index + 1\n    \n    # Check if the count is greater than n/2\n    return count > n / 2\n"}
{"task_id": "Mbpp/224", "solution": "\ndef count_Set_Bits(n: int) -> int:\n    # Initialize a counter for set bits\n    count = 0\n    \n    # Loop until n becomes 0\n    while n > 0:\n        # Check if the least significant bit is set\n        if n & 1 == 1:\n            count += 1  # Increment count if the bit is set\n        n >>= 1  # Right shift n to check the next bit\n    \n    return count  # Return the total count of set bits\n"}
{"task_id": "Mbpp/226", "solution": "\ndef odd_values_string(input_string):\n    # Create an empty string to store the result\n    result = \"\"\n    \n    # Iterate through the input string using index\n    for index in range(len(input_string)):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Append the character at the even index to the result\n            result += input_string[index]\n    \n    # Return the final result string\n    return result\n"}
{"task_id": "Mbpp/227", "solution": "\n# Define a function to find the minimum of three numbers\ndef min_of_three(a, b, c):\n    # Check if 'a' is less than both 'b' and 'c'\n    if a < b and a < c:\n        return a  # 'a' is the minimum\n    # Check if 'b' is less than both 'a' and 'c'\n    elif b < a and b < c:\n        return b  # 'b' is the minimum\n    # If neither 'a' nor 'b' is the minimum, then 'c' must be the minimum\n    else:\n        return c  # 'c' is the minimum\n"}
{"task_id": "Mbpp/230", "solution": "\ndef replace_blank(input_string: str, replacement_char: str) -> str:\n    # Initialize an empty result string\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # If the character is a space, replace it with the replacement character\n        if char == ' ':\n            result += replacement_char\n        else:\n            # Otherwise, keep the character as is\n            result += char\n            \n    # Return the modified string\n    return result\n"}
{"task_id": "Mbpp/232", "solution": "\ndef remove_duplicates(numbers):\n    # Create a set to store unique numbers\n    unique_numbers = set(numbers)\n    return list(unique_numbers)\n\ndef sort_descending(numbers):\n    # Sort the numbers in descending order\n    return sorted(numbers, reverse=True)\n\ndef larg_nnum(numbers, n):\n    # Step 1: Remove duplicates from the list\n    unique_numbers = remove_duplicates(numbers)\n    # Step 2: Sort the unique numbers in descending order\n    sorted_numbers = sort_descending(unique_numbers)\n    # Step 3: Return the first n largest numbers\n    return sorted_numbers[:n]\n"}
{"task_id": "Mbpp/233", "solution": "\ndef lateral_surface_area(radius, height):\n    # Importing the value of pi\n    pi = 3.141592653589793\n    # Calculate the lateral surface area using the formula\n    area = 2 * pi * radius * height\n    # Return the calculated area\n    return area\n\ndef lateralsuface_cylinder(radius: float, height: float) -> float:\n    return lateral_surface_area(radius, height)\n"}
{"task_id": "Mbpp/234", "solution": "\ndef calculate_volume(side_length):\n    # Calculate the volume of the cube\n    return side_length * side_length * side_length  # Volume formula: side^3\n\ndef volume_cube(side_length):\n    # Call the helper function to get the volume\n    return calculate_volume(side_length)  # Return the volume of the cube\n\n# The main function name is strictly followed as 'volume_cube'\n"}
{"task_id": "Mbpp/235", "solution": "\ndef even_bit_set_number(n: int) -> int:\n    # Create a mask to set all even bits to 1\n    mask = 0\n    for i in range(32):  # Assuming a 32-bit integer\n        if i % 2 == 0:  # Check if the position is even\n            mask |= (1 << i)  # Set the bit at position i to 1\n    # Set only the even bits of n to 1 using bitwise OR\n    return n | mask\n"}
{"task_id": "Mbpp/237", "solution": "\ndef check_occurences(tuples_list):\n    # Create an empty dictionary to store counts of each tuple\n    counts = {}\n    \n    # Iterate through each tuple in the provided list\n    for tup in tuples_list:\n        # Sort the tuple to treat (a, b) and (b, a) as the same\n        sorted_tup = tuple(sorted(tup))\n        \n        # If the sorted tuple is already in the dictionary, increment its count\n        if sorted_tup in counts:\n            counts[sorted_tup] += 1\n        # If the sorted tuple is not in the dictionary, add it with a count of 1\n        else:\n            counts[sorted_tup] = 1\n            \n    # Return the dictionary containing the counts of each unique tuple\n    return counts\n"}
{"task_id": "Mbpp/238", "solution": "\ndef number_of_substrings(s: str) -> int:\n    # Calculate the length of the string\n    n = len(s)\n    # Use the formula for the sum of the first n natural numbers to find the total substrings\n    total_substrings = n * (n + 1) // 2\n    # Return the total count of non-empty substrings\n    return total_substrings\n"}
{"task_id": "Mbpp/239", "solution": "\ndef count_sequences(current, length_remaining, max_value):\n    # Base case: if no length remaining, we found a valid sequence\n    if length_remaining == 0:\n        return 1  \n    total_count = 0\n    next_value = current * 2  # The next integer must be at least double the current\n    while next_value <= max_value:\n        total_count += count_sequences(next_value, length_remaining - 1, max_value)\n        next_value += 1  # Check the next possible integer\n    return total_count\n\ndef get_total_number_of_sequences(m: int, n: int) -> int:\n    return count_sequences(1, n - 1, m)  # Start with the first integer as 1\n"}
{"task_id": "Mbpp/240", "solution": "\ndef replace_list(list1, list2):\n    # Check if the first list is not empty\n    if list1:\n        # Remove the last element from the first list\n        list1.pop()\n    # Append all elements of the second list to the first list\n    list1.extend(list2)\n    # Return the modified first list\n    return list1\n"}
{"task_id": "Mbpp/242", "solution": "\ndef count_charac(s: str) -> int:\n    # Calculate the total number of characters in the string\n    total_characters = len(s)\n    # Return the total count\n    return total_characters\n"}
{"task_id": "Mbpp/244", "solution": "\ndef next_Perfect_Square(n):\n    # Calculate the integer square root of n\n    sqrt_n = int(n**0.5)\n    # Increment the integer to get the next whole number\n    next_integer = sqrt_n + 1\n    # Square the incremented integer to get the next perfect square\n    next_perfect_square = next_integer * next_integer\n    # Return the next perfect square\n    return next_perfect_square\n"}
{"task_id": "Mbpp/245", "solution": "\ndef max_sum(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    # Step 1: Calculate maximum sum of increasing subsequences\n    inc_sum = [0] * n\n    for i in range(n):\n        inc_sum[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc_sum[i] = max(inc_sum[i], inc_sum[j] + arr[i])\n    \n    # Step 2: Calculate maximum sum of decreasing subsequences\n    dec_sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        dec_sum[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i]:\n                dec_sum[i] = max(dec_sum[i], dec_sum[j] + arr[i])\n    \n    # Step 3: Combine results to find maximum sum of bitonic subsequence\n    max_bitonic_sum = 0\n    for i in range(n):\n        max_bitonic_sum = max(max_bitonic_sum, inc_sum[i] + dec_sum[i] - arr[i])\n    \n    return max_bitonic_sum\n"}
{"task_id": "Mbpp/247", "solution": "\ndef lps(s: str) -> int:\n    n = len(s)\n    # Create a 2D array to store lengths of longest palindromic subsequences\n    dp = [[0] * n for _ in range(n)]\n\n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Build the dp array\n    for length in range(2, n + 1):  # length of the substring\n        for start in range(n - length + 1):\n            end = start + length - 1\n            if s[start] == s[end]:  # characters match\n                dp[start][end] = dp[start + 1][end - 1] + 2\n            else:  # characters do not match\n                dp[start][end] = max(dp[start + 1][end], dp[start][end - 1])\n\n    # The result is in the top right corner of the dp array\n    return dp[0][n - 1]\n"}
{"task_id": "Mbpp/250", "solution": "\ndef count_X(tup, element):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    # Iterate through each item in the tuple\n    for item in tup:\n        # If the current item matches the element, increment the count\n        if item == element:\n            count += 1\n    # Return the total count of occurrences\n    return count\n"}
{"task_id": "Mbpp/251", "solution": "\ndef insert_element(lst, elem):\n    # Create an empty list to hold the result\n    result = []\n    \n    # Iterate through each item in the input list\n    for item in lst:\n        # Append the specified element to the result list\n        result.append(elem)\n        # Append the current item from the original list to the result list\n        result.append(item)\n    \n    # Return the new list with the inserted elements\n    return result\n"}
{"task_id": "Mbpp/252", "solution": "\nimport math\n\n# Function to convert a complex number to polar coordinates\ndef convert(z):\n    # Check if z is a real number\n    if isinstance(z, (int, float)):\n        x = z  # Real part\n        y = 0  # Imaginary part is zero\n    else:\n        x = z.real  # Extract real part\n        y = z.imag  # Extract imaginary part\n    \n    # Calculate the radius (magnitude)\n    r = math.sqrt(x**2 + y**2)\n    # Calculate the angle (in radians)\n    theta = math.atan2(y, x)\n    \n    # Return the polar coordinates as a tuple\n    return (r, theta)\n"}
{"task_id": "Mbpp/253", "solution": "\ndef count_integer(input_list):\n    # Initialize a counter for integer elements\n    count = 0\n    # Iterate through each element in the input list\n    for element in input_list:\n        # Check if the element is of type int\n        if isinstance(element, int):\n            # Increment the count if it is an integer\n            count += 1\n    # Return the total count of integer elements\n    return count\n"}
{"task_id": "Mbpp/255", "solution": "\ndef combinations_helper(current_combination, colors, n, results):\n    # Base case: if the current combination has reached the desired length\n    if len(current_combination) == n:\n        results.append(tuple(current_combination))  # Store the combination as a tuple\n        return\n    # Iterate through each color to build combinations\n    for color in colors:\n        current_combination.append(color)  # Add the color to the current combination\n        combinations_helper(current_combination, colors, n, results)  # Recursive call\n        current_combination.pop()  # Backtrack to explore other combinations\n\ndef combinations_colors(colors, n):\n    results = []  # Initialize the results list\n    combinations_helper([], colors, n, results)  # Start the recursive combination generation\n    return results  # Return the list of combinations\n"}
{"task_id": "Mbpp/256", "solution": "\ndef is_prime(num):\n    # Check if the number is less than or equal to 1\n    if num <= 1:\n        return False\n    # Check for factors from 2 to the square root of num\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef count_Primes_nums(n):\n    # Initialize a counter for prime numbers\n    count = 0\n    # Iterate through numbers from 2 to n-1\n    for i in range(2, n):\n        if is_prime(i):  # Check if the number is prime\n            count += 1  # Increment the count if it is prime\n    return count  # Return the total count of prime numbers found\n"}
{"task_id": "Mbpp/257", "solution": "\ndef swap_numbers(a, b):\n    # Create a tuple with the second number first and the first number second\n    result = (b, a)\n    # Return the created tuple\n    return result\n"}
{"task_id": "Mbpp/259", "solution": "\ndef maximize_elements(tuple1, tuple2):\n    # Create an empty list to hold the results\n    result = []\n    \n    # Iterate through both tuples simultaneously\n    for i in range(len(tuple1)):\n        # For each pair, find the maximum value\n        max_value = (max(tuple1[i][0], tuple2[i][0]), max(tuple1[i][1], tuple2[i][1]))\n        # Append the maximum value to the results list\n        result.append(max_value)\n    \n    # Convert the results list to a tuple\n    return tuple(result)\n\n# The function maximize_elements is declared last as per the instructions.\n"}
{"task_id": "Mbpp/260", "solution": "\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef newman_prime(n: int) -> int:\n    # List to store the Newman\u2013Shanks\u2013Williams primes\n    newman_primes = []\n    # Start checking numbers from 2 upwards\n    candidate = 2\n    while len(newman_primes) < n:\n        if is_prime(candidate):\n            # Append the candidate if it is a Newman\u2013Shanks\u2013Williams prime\n            if candidate in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]:\n                newman_primes.append(candidate)\n        candidate += 1\n    return newman_primes[n - 1]  # Return the nth prime\n"}
{"task_id": "Mbpp/261", "solution": "\ndef division_elements(tuple1, tuple2):\n    # Create an empty list to store results\n    results = []\n    \n    # Iterate through both tuples simultaneously\n    for i in range(len(tuple1)):\n        # Perform division for each pair of elements\n        result = tuple1[i] // tuple2[i]  # Use integer division\n        # Append the result to the results list\n        results.append(result)\n    \n    # Convert the results list to a tuple\n    return tuple(results)\n\n# The function division_elements is declared last as per the instructions.\n"}
{"task_id": "Mbpp/262", "solution": "\ndef split_two_parts(lst, L):\n    # Get the first part of the list containing the first L elements\n    first_part = lst[0:L]\n    # Get the second part of the list containing the elements from index L to the end\n    second_part = lst[L:]\n    # Return both parts as a tuple\n    return (first_part, second_part)\n"}
{"task_id": "Mbpp/264", "solution": "\ndef dog_age(human_years):\n    # Check if the dog's age is 2 years or less\n    if human_years <= 2:\n        # Calculate dog years for ages 2 and under\n        return human_years * 10.5\n    else:\n        # Calculate dog years for ages over 2\n        first_two_years = 21  # 2 years * 10.5\n        additional_years = (human_years - 2) * 4  # Each year after counts as 4\n        return first_two_years + additional_years  # Total dog years\n\n"}
{"task_id": "Mbpp/265", "solution": "\ndef list_split(input_list, n):\n    # Create an empty list to hold the resulting sublists\n    result = []\n    \n    # Iterate over the range from 0 to n-1 to create n sublists\n    for i in range(n):\n        # Create a new sublist for the current index\n        sublist = []\n        \n        # Iterate through the input list starting from index i, stepping by n\n        for j in range(i, len(input_list), n):\n            sublist.append(input_list[j])  # Add the current element to the sublist\n        \n        result.append(sublist)  # Add the completed sublist to the result\n    \n    return result  # Return the list of sublists\n"}
{"task_id": "Mbpp/266", "solution": "\ndef lateralsurface_cube(side):\n    # Calculate the area of one side of the cube\n    area_of_one_side = side * side\n    # Calculate the lateral surface area (4 sides)\n    lateral_surface_area = 4 * area_of_one_side\n    # Return the calculated lateral surface area\n    return lateral_surface_area\n"}
{"task_id": "Mbpp/267", "solution": "\ndef square_Sum(n):\n    # Initialize total to accumulate the sum of squares\n    total = 0\n    # Loop through the first n odd natural numbers\n    for i in range(n):\n        # Calculate the i-th odd number\n        odd_number = 2 * i + 1\n        # Add the square of the odd number to total\n        total += odd_number * odd_number\n    # Return the final total\n    return total\n"}
{"task_id": "Mbpp/268", "solution": "\ndef find_star_num(n):\n    # Calculate the N'th star number using the correct formula\n    star_number = 6 * n * (n - 1) + 1\n    return star_number  # Return the calculated star number\n"}
{"task_id": "Mbpp/269", "solution": "\n# Define a function to find the ASCII value of a character\ndef ascii_value(character):\n    # Use the ord() function to get the ASCII value of the character\n    return ord(character)  # Return the ASCII value\n\n"}
{"task_id": "Mbpp/270", "solution": "\ndef sum_even_and_even_index(numbers):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate through the list with index\n    for index in range(len(numbers)):\n        # Check if the index is even\n        if index % 2 == 0:\n            # Check if the number at this index is even\n            if numbers[index] % 2 == 0:\n                # Add the even number at an even index to the total sum\n                total_sum += numbers[index]\n    \n    # Return the total sum of even numbers at even indices\n    return total_sum\n"}
{"task_id": "Mbpp/271", "solution": "\ndef even_Power_Sum(n):\n    # Initialize the total sum to 0\n    total_sum = 0\n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        # Calculate the i-th even natural number\n        even_number = 2 * i\n        # Raise the even number to the fifth power\n        fifth_power = even_number ** 5\n        # Add the fifth power to the total sum\n        total_sum += fifth_power\n    # Return the total sum of the fifth powers\n    return total_sum\n"}
{"task_id": "Mbpp/272", "solution": "\ndef rear_extract(tuples_list):\n    # Create an empty list to store the last elements\n    result = []\n    \n    # Iterate through each tuple in the input list\n    for tup in tuples_list:\n        # Get the last element of the tuple\n        last_element = tup[-1]\n        # Append the last element to the result list\n        result.append(last_element)\n    \n    # Return the list containing all the last elements\n    return result\n"}
{"task_id": "Mbpp/273", "solution": "\ndef substract_elements(tuple1, tuple2):\n    # Create an empty list to hold results\n    results = []\n    \n    # Iterate through both tuples using their indices\n    for i in range(len(tuple1)):\n        # Subtract the elements of the second tuple from the first\n        result = tuple1[i] - tuple2[i]\n        # Append the result to the results list\n        results.append(result)\n    \n    # Convert the results list to a tuple and return it\n    return tuple(results)\n"}
{"task_id": "Mbpp/274", "solution": "\ndef C(n, k):\n    # Calculate the binomial coefficient C(n, k)\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    res = 1\n    for i in range(1, k + 1):\n        res = res * (n - i + 1) // i\n    return res\n\ndef even_binomial_Coeff_Sum(n):\n    # Initialize the sum of even index binomial coefficients\n    sum = 0\n    # Iterate through all indices from 0 to n\n    for k in range(n + 1):\n        # Check if the index is even\n        if k % 2 == 0:\n            # Add the binomial coefficient C(n, k) to the sum\n            sum += C(n, k)\n    return sum\n"}
{"task_id": "Mbpp/276", "solution": "\ndef volume_cylinder(radius, height):\n    # Define the value of pi\n    pi = 3.141592653589793\n    # Calculate the volume using the formula for the volume of a cylinder\n    volume = pi * (radius ** 2) * height\n    # Return the calculated volume\n    return volume\n"}
{"task_id": "Mbpp/277", "solution": "\ndef dict_filter(input_dict, n):\n    # Create an empty dictionary to store filtered results\n    filtered_dict = {}\n    \n    # Iterate through each key-value pair in the input dictionary\n    for key, value in input_dict.items():\n        # Check if the value is greater than or equal to n\n        if value >= n:\n            # Add the key-value pair to the filtered dictionary\n            filtered_dict[key] = value\n            \n    # Return the filtered dictionary\n    return filtered_dict\n"}
{"task_id": "Mbpp/278", "solution": "\ndef count_first_elements(input_tuple):\n    # Initialize a counter to keep track of the number of elements before the tuple\n    count = 0\n    \n    # Iterate through each element in the input tuple\n    for element in input_tuple:\n        # Check if the current element is a tuple\n        if isinstance(element, tuple):\n            # If it is a tuple, return the count of elements before it\n            return count\n        # Increment the count for each non-tuple element\n        count += 1\n    \n    # If no tuple is found, return the count (though this case should not occur based on the problem statement)\n    return count\n"}
{"task_id": "Mbpp/279", "solution": "\ndef is_num_decagonal(n):\n    # Calculate the nth decagonal number using the formula\n    return n * (4 * n - 3)  # D(n) = n(4n - 3)\n"}
{"task_id": "Mbpp/280", "solution": "\ndef sequential_search(array, element):\n    # Iterate through each index and value in the array\n    for index in range(len(array)):\n        # Check if the current value matches the element we are searching for\n        if array[index] == element:\n            # If found, return True and the index\n            return (True, index)\n    # If not found, return False and -1\n    return (False, -1)\n"}
{"task_id": "Mbpp/281", "solution": "\ndef all_unique(elements):\n    # Create an empty set to track seen elements\n    seen = set()\n    \n    # Iterate through each element in the input list\n    for element in elements:\n        # If the element is already in the set, it's not unique\n        if element in seen:\n            return False\n        # Add the element to the set\n        seen.add(element)\n    \n    # If we finish the loop without finding duplicates, return True\n    return True\n"}
{"task_id": "Mbpp/282", "solution": "\ndef sub_list(list1, list2):\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate through both lists using their indices\n    for i in range(len(list1)):\n        # Subtract the corresponding elements and append to result\n        result.append(list1[i] - list2[i])\n    \n    # Return the final result list\n    return result\n"}
{"task_id": "Mbpp/283", "solution": "\ndef count_digit_frequencies(n):\n    # Convert the integer to a string to access each digit\n    str_n = str(n)\n    frequency = {}\n    \n    # Count the frequency of each digit\n    for char in str_n:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n            \n    return frequency\n\ndef validate(n: int) -> bool:\n    # Get the frequency of each digit\n    digit_frequencies = count_digit_frequencies(n)\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit_str, count in digit_frequencies.items():\n        digit = int(digit_str)\n        if count > digit:\n            return False\n            \n    return True\n"}
{"task_id": "Mbpp/284", "solution": "\ndef check_element(lst, element):\n    # Iterate through each item in the list\n    for item in lst:\n        # Check if the current item is not equal to the specified element\n        if item != element:\n            # If any item is not equal, return False\n            return False\n    # If all items are equal to the specified element, return True\n    return True\n"}
{"task_id": "Mbpp/285", "solution": "\ndef text_match_two_three(s: str) -> bool:\n    # Iterate through the string\n    for i in range(len(s)):\n        # Check if the current character is 'a'\n        if s[i] == 'a':\n            # Check if the next two characters are 'b'\n            if i + 2 < len(s) and s[i + 1] == 'b' and s[i + 2] == 'b':\n                return True\n            # Check if the next three characters are 'b'\n            if i + 3 < len(s) and s[i + 1] == 'b' and s[i + 2] == 'b' and s[i + 3] == 'b':\n                return True\n    # If no valid pattern is found, return False\n    return False\n"}
{"task_id": "Mbpp/286", "solution": "\ndef max_subarray_sum(arr):\n    max_ending_here = max_so_far = arr[0]\n    for i in range(1, len(arr)):\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef calculate_prefix_sum(arr):\n    sum = 0\n    max_prefix = arr[0]\n    for i in range(len(arr)):\n        sum += arr[i]\n        max_prefix = max(max_prefix, sum)\n    return max_prefix\n\ndef calculate_suffix_sum(arr):\n    sum = 0\n    max_suffix = arr[-1]\n    for i in range(len(arr) - 1, -1, -1):\n        sum += arr[i]\n        max_suffix = max(max_suffix, sum)\n    return max_suffix\n\ndef max_sub_array_sum_repeated(arr, k, _):\n    if k == 0:\n        return 0\n    if k == 1:\n        return max_subarray_sum(arr)\n    \n    max_sum = max_subarray_sum(arr)\n    total_sum = sum(arr)\n    prefix_sum = calculate_prefix_sum(arr)\n    suffix_sum = calculate_suffix_sum(arr)\n\n    if total_sum > 0:\n        max_sum = max(max_sum, prefix_sum + (k - 1) * total_sum + suffix_sum)\n    else:\n        max_sum = max(max_sum, prefix_sum + suffix_sum)\n\n    return max_sum\n"}
{"task_id": "Mbpp/287", "solution": "\ndef square_Sum(n):\n    # Initialize total to store the sum of squares\n    total = 0\n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        even_number = 2 * i  # Calculate the i-th even natural number\n        total += even_number * even_number  # Square the even number and add to total\n    return total  # Return the final sum of squares\n"}
{"task_id": "Mbpp/290", "solution": "\ndef max_length(lists):\n    # Initialize variables to keep track of the maximum length and the corresponding list\n    max_length = 0\n    max_list = []\n    \n    # Iterate through each sublist in the provided list of lists\n    for sublist in lists:\n        # Check if the current sublist is longer than the maximum found so far\n        if len(sublist) > max_length:\n            # Update the maximum length and the corresponding list\n            max_length = len(sublist)\n            max_list = sublist\n            \n    # Return the maximum length and the list that has this length\n    return (max_length, max_list)\n"}
{"task_id": "Mbpp/292", "solution": "\n# Define a function to find the quotient of two numbers\ndef find(a: int, b: int) -> int:\n    # Use integer division to get the quotient rounded down\n    return a // b\n"}
{"task_id": "Mbpp/293", "solution": "\ndef calculate_hypotenuse(a, b):\n    # Calculate the hypotenuse using the Pythagorean theorem\n    return (a**2 + b**2)**0.5\n\ndef calculate_other_side(hypotenuse, side):\n    # Calculate the other side using the Pythagorean theorem\n    return (hypotenuse**2 - side**2)**0.5\n\ndef otherside_rightangle(side1, side2):\n    # Check if either side is the hypotenuse\n    if side1 > side2:  # side1 is the hypotenuse\n        return calculate_other_side(side1, side2)\n    else:  # side2 is the hypotenuse or both are legs\n        return calculate_hypotenuse(side1, side2)\n"}
{"task_id": "Mbpp/294", "solution": "\ndef max_val(input_list):\n    # Initialize max_value to a very small number\n    max_value = float('-inf')\n    \n    # Iterate through each element in the input list\n    for element in input_list:\n        # Check if the element is an integer\n        if isinstance(element, int):\n            # If it is greater than the current max_value, update max_value\n            if element > max_value:\n                max_value = element\n    \n    # Return the maximum integer found\n    return max_value\n"}
{"task_id": "Mbpp/296", "solution": "\ndef merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)  # Count inversions\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\n\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n    return inv_count\n\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)  # Temporary array for merge sort\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)  # Count inversions\n"}
{"task_id": "Mbpp/297", "solution": "\ndef flatten_list(nested_list):\n    # Create an empty list to hold the flattened result\n    result = []\n    \n    # Iterate through each element in the nested list\n    for element in nested_list:\n        # If the element is a list, recursively flatten it\n        if isinstance(element, list):\n            result.extend(flatten_list(element))  # Extend the result with the flattened sub-list\n        else:\n            result.append(element)  # If it's not a list, append the element directly to the result\n    \n    # Return the flattened list\n    return result\n"}
{"task_id": "Mbpp/299", "solution": "\ndef max_aggregate(tuples):\n    # Create an empty dictionary to hold scores\n    scores = {}\n    \n    # Iterate through each tuple in the input list\n    for name, score in tuples:\n        # If the name is not in the dictionary, initialize it with the score\n        if name not in scores:\n            scores[name] = score\n        else:\n            # If the name is already in the dictionary, add the score to the existing score\n            scores[name] += score\n    \n    # Initialize variables to track the maximum score and corresponding name\n    max_name = \"\"\n    max_score = 0\n    \n    # Iterate through the dictionary to find the name with the maximum score\n    for name, score in scores.items():\n        if score > max_score:\n            max_name = name\n            max_score = score\n    \n    # Return the name with the maximum score and the score itself\n    return (max_name, max_score)\n"}
{"task_id": "Mbpp/3", "solution": "\ndef is_not_prime(n):\n    # Check if the number is less than 2\n    if n < 2:\n        return True  # Numbers less than 2 are not prime\n    # Check for factors from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # Found a divisor, so n is not prime\n    return False  # No divisors found, so n is prime\n"}
{"task_id": "Mbpp/300", "solution": "\ndef binomial_coefficient(n, k):\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    res = 1\n    for i in range(1, k + 1):\n        res = res * (n - i + 1) // i\n    return res\n\ndef count_binary_seq(n: int) -> float:\n    total_count = 0\n    for k in range(n + 1):\n        total_count += binomial_coefficient(n, k) ** 2  # Square of binomial coefficient\n    return float(total_count)\n\n"}
{"task_id": "Mbpp/301", "solution": "\ndef dict_depth(dictionary):\n    # Base case: if the dictionary is empty, the depth is 0\n    if not dictionary:\n        return 0\n    \n    max_depth = 0  # Initialize max_depth to track the maximum depth found\n    \n    # Iterate through each value in the dictionary\n    for value in dictionary.values():\n        # If the value is a dictionary, we need to find its depth\n        if isinstance(value, dict):\n            current_depth = dict_depth(value)  # Recursive call to find depth\n            max_depth = max(max_depth, current_depth)  # Update max_depth if needed\n    \n    return max_depth + 1  # Return the maximum depth found plus one for the current level\n"}
{"task_id": "Mbpp/305", "solution": "\ndef start_withp(words):\n    # Create an empty list to store words starting with 'p'\n    p_words = []\n    \n    # Iterate through each string in the input list\n    for phrase in words:\n        # Split the string into individual words\n        for word in phrase.split():\n            # Check if the word starts with the letter 'p' or 'P'\n            if word[0].lower() == 'p':\n                # Add the word to the p_words list\n                p_words.append(word)\n            \n            # If we have found two words, return them\n            if len(p_words) == 2:\n                return (p_words[0], p_words[1])\n    \n    # If fewer than two words starting with 'p' are found, return nothing\n"}
{"task_id": "Mbpp/306", "solution": "\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize the maximum sum to 0\n    max_sum = 0\n    \n    # Iterate through the elements from the start to index i-1\n    for j in range(i):\n        # Check if the current element can be part of the increasing subsequence with arr[k]\n        if arr[j] < arr[k]:\n            # Start the current sum with arr[j] and arr[k]\n            current_sum = arr[j] + arr[k]\n            \n            # Check for other elements before j to form an increasing subsequence\n            for m in range(j):\n                if arr[m] < arr[j]:  # Ensure increasing condition\n                    current_sum += arr[m]\n            \n            # Update the maximum sum found\n            max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n"}
{"task_id": "Mbpp/308", "solution": "\ndef large_product(list1, list2, N):\n    # Step 1: Initialize an empty list to store products\n    products = []\n    \n    # Step 2: Generate all possible products\n    for x in list1:\n        for y in list2:\n            product = x * y\n            products.append(product)  # Add the product to the list\n    \n    # Step 3: Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Step 4: Return the top N products\n    return products[:N]  # Return the first N elements of the sorted list\n"}
{"task_id": "Mbpp/309", "solution": "\n# Define a function to find the maximum of two numbers\ndef maximum(a, b):\n    # Compare the two numbers\n    if a > b:\n        # If the first number is greater, return it\n        return a\n    else:\n        # Otherwise, return the second number\n        return b\n"}
{"task_id": "Mbpp/310", "solution": "\ndef string_to_tuple(s: str) -> tuple:\n    # Initialize an empty list to hold characters\n    char_list = []\n    \n    # Loop through each character in the string\n    for char in s:\n        # Append each character to the list\n        char_list.append(char)\n    \n    # Convert the list to a tuple\n    result_tuple = tuple(char_list)\n    \n    # Return the tuple\n    return result_tuple\n"}
{"task_id": "Mbpp/311", "solution": "\ndef set_left_most_unset_bit(n: int) -> int:\n    # Find the position of the leftmost unset bit\n    position = 0\n    mask = 1\n\n    # Shift mask left until it exceeds the highest bit of n\n    while mask <= n:\n        mask <<= 1\n        position += 1\n\n    # Now mask is at the position just above the highest bit of n\n    # Check for the leftmost unset bit\n    mask >>= 1  # Move back to the highest bit position of n\n    while mask > 0:\n        if (n & mask) == 0:  # Check if the current bit is unset\n            return n | mask  # Set the leftmost unset bit and return\n        mask >>= 1  # Move to the next lower bit position\n\n    return n  # In case all bits are set, return n (though this shouldn't happen with the given problem)\n"}
{"task_id": "Mbpp/312", "solution": "\ndef volume_cone(radius: float, height: float) -> float:\n    # Define the value of pi\n    pi = 3.141592653589793\n    # Calculate the volume using the formula for the volume of a cone\n    volume = (1/3) * pi * (radius ** 2) * height\n    # Return the calculated volume\n    return volume\n"}
{"task_id": "Mbpp/388", "solution": "\ndef highest_Power_of_2(n: int) -> int:\n    # Check if n is less than 1, return 0 as there are no powers of 2\n    if n < 1:\n        return 0\n    \n    # Initialize the power of 2\n    power = 1\n    \n    # Keep doubling the power until it exceeds n\n    while power * 2 <= n:\n        power = power * 2\n    \n    # Return the highest power of 2 found\n    return power\n"}
{"task_id": "Mbpp/389", "solution": "\ndef find_lucas(n):\n    # Base cases for the Lucas sequence\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    \n    # Initialize the first two Lucas numbers\n    lucas_0 = 2\n    lucas_1 = 1\n    \n    # Calculate the N'th Lucas number iteratively\n    for i in range(2, n + 1):\n        lucas_n = lucas_0 + lucas_1  # L(n) = L(n-1) + L(n-2)\n        lucas_0 = lucas_1  # Move to the next number\n        lucas_1 = lucas_n  # Update the current number\n    \n    return lucas_n  # Return the N'th Lucas number\n"}
{"task_id": "Mbpp/390", "solution": "\ndef format_number(number, format_string):\n    # Format the number using the provided format string\n    return format_string.format(number)\n\ndef add_string(numbers, format_string):\n    # Create an empty list to hold the formatted strings\n    formatted_list = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Format the number and add it to the formatted_list\n        formatted_list.append(format_number(number, format_string))\n    \n    # Return the list of formatted strings\n    return formatted_list\n"}
{"task_id": "Mbpp/391", "solution": "\ndef convert_list_dictionary(ids, names, scores):\n    # Create an empty list to hold the result\n    result = []\n    \n    # Iterate through the indices of the input lists\n    for i in range(len(ids)):\n        # Create a dictionary for each student ID\n        student_dict = {ids[i]: {names[i]: scores[i]}}\n        # Add the student dictionary to the result list\n        result.append(student_dict)\n    \n    # Return the final list of dictionaries\n    return result\n"}
{"task_id": "Mbpp/392", "solution": "\n# We will use a dictionary to store previously computed results for memoization\nmemo = {}\n\ndef get_max_sum(n):\n    # Check if the result for n is already computed\n    if n in memo:\n        return memo[n]\n    # Base case: if n is 0, the maximum sum is 0\n    if n == 0:\n        return 0\n    # Calculate the maximum sum using the given formula\n    max_sum = max(get_max_sum(n // 2) + get_max_sum(n // 3) + get_max_sum(n // 4) + get_max_sum(n // 5), n)\n    # Store the computed result in the memo dictionary\n    memo[n] = max_sum\n    return max_sum\n"}
{"task_id": "Mbpp/394", "solution": "\ndef check_distinct(input_tuple):\n    # Convert the tuple to a set to remove duplicates\n    unique_elements = set(input_tuple)\n    \n    # Compare the length of the set with the length of the original tuple\n    if len(unique_elements) == len(input_tuple):\n        # If lengths are equal, there are no duplicates\n        return True\n    else:\n        # If lengths differ, there are duplicates\n        return False\n"}
{"task_id": "Mbpp/395", "solution": "\ndef first_non_repeating_character(s: str) -> str:\n    # Create a dictionary to count occurrences of each character\n    char_count = {}\n    \n    # Count each character in the string\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Find the first character that has a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None\n"}
{"task_id": "Mbpp/397", "solution": "\ndef median_numbers(a, b, c):\n    # Create a list with the three numbers\n    numbers = [a, b, c]\n    # Sort the list of numbers\n    numbers.sort()\n    # Return the second element, which is the median\n    return numbers[1]\n"}
{"task_id": "Mbpp/398", "solution": "\ndef sum_of_digits(numbers):\n    # Initialize the total sum to 0\n    total_sum = 0\n    # Iterate through each number in the list\n    for number in numbers:\n        # Convert the number to a string to access each digit\n        for digit in str(number):\n            # Convert the character back to an integer and add to total_sum\n            total_sum += int(digit)\n    # Return the total sum of all digits\n    return total_sum\n"}
{"task_id": "Mbpp/4", "solution": "\ndef heap_queue_largest(numbers, n):\n    # Step 1: Sort the list of numbers in descending order\n    sorted_numbers = sorted(numbers, reverse=True)\n    \n    # Step 2: Select the first n elements from the sorted list\n    largest_numbers = sorted_numbers[:n]\n    \n    # Step 3: Return the selected n largest numbers\n    return largest_numbers\n"}
{"task_id": "Mbpp/404", "solution": "\n# Define a function to find the minimum of two numbers\ndef minimum(a, b):\n    # Compare the two numbers\n    if a < b:\n        # If the first number is less, return it\n        return a\n    else:\n        # Otherwise, return the second number\n        return b\n"}
{"task_id": "Mbpp/405", "solution": "\ndef check_tuplex(tup, element):\n    # Iterate through each item in the tuple\n    for item in tup:\n        # Check if the current item matches the element we are looking for\n        if item == element:\n            return True  # Return True if a match is found\n    return False  # Return False if no match is found after checking all items\n"}
{"task_id": "Mbpp/406", "solution": "\n# Define a function to check if the parity of a number is odd\ndef is_odd(n):\n    # Check if the number is odd using modulus operator\n    return n % 2 == 1\n\n# Main function to find the parity of the number\ndef find_Parity(n: int) -> bool:\n    # Use the helper function to determine if n is odd\n    return is_odd(n)\n"}
{"task_id": "Mbpp/409", "solution": "\ndef min_product_tuple(tuples):\n    # Initialize min_product to a very large number\n    min_product = float('inf')\n    \n    # Iterate through each tuple in the list\n    for a, b in tuples:\n        # Calculate the product of the two numbers in the tuple\n        product = a * b\n        \n        # Update min_product if the current product is smaller\n        if product < min_product:\n            min_product = product\n            \n    # Return the minimum product found\n    return min_product\n"}
{"task_id": "Mbpp/410", "solution": "\ndef min_val(input_list):\n    # Initialize min_value to None to track the smallest integer\n    min_value = None\n    \n    # Iterate through each item in the input list\n    for item in input_list:\n        # Check if the item is an integer\n        if isinstance(item, int):\n            # If min_value is None or the current item is smaller than min_value\n            if min_value is None or item < min_value:\n                # Update min_value to the current item\n                min_value = item\n    \n    # Return the smallest integer found\n    return min_value\n"}
{"task_id": "Mbpp/412", "solution": "\ndef remove_odd(numbers):\n    # Create an empty list to store even numbers\n    result = []\n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is even\n        if number % 2 == 0:\n            # If it is even, add it to the result list\n            result.append(number)\n    # Return the list of even numbers\n    return result\n"}
{"task_id": "Mbpp/413", "solution": "\ndef extract_nth_element(tuples_list, n):\n    # Initialize an empty list to store the nth elements\n    result = []\n    \n    # Loop through each tuple in the provided list\n    for tup in tuples_list:\n        # Append the nth element of the tuple to the result list\n        result.append(tup[n])\n    \n    # Return the list of nth elements\n    return result\n"}
{"task_id": "Mbpp/414", "solution": "\ndef overlapping(seq1, seq2):\n    # Iterate through each element in the first sequence\n    for element in seq1:\n        # Check if the current element exists in the second sequence\n        if element in seq2:\n            return True  # Return True if a common element is found\n    return False  # Return False if no common elements are found\n"}
{"task_id": "Mbpp/415", "solution": "\ndef max_Product(arr):\n    # Check if the array has at least two elements\n    if len(arr) < 2:\n        return None  # Not enough elements to form a pair\n    \n    # Initialize the two largest numbers and their indices\n    first_max = float('-inf')\n    second_max = float('-inf')\n    first_index = -1\n    second_index = -1\n    \n    # Iterate through the array to find the two largest numbers and their indices\n    for index, number in enumerate(arr):\n        if number > first_max:\n            # Update both first and second max\n            second_max = first_max\n            second_index = first_index\n            first_max = number\n            first_index = index\n        elif number > second_max:\n            # Update only the second max\n            second_max = number\n            second_index = index\n    \n    # Ensure the output is in the order they appear in the original list\n    if first_index < second_index:\n        return (first_max, second_max)\n    else:\n        return (second_max, first_max)\n"}
{"task_id": "Mbpp/418", "solution": "\ndef Find_Max(input_list):\n    # Initialize the maximum length and the corresponding sublist\n    max_length = 0\n    max_list = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Check if the current sublist is longer than the max found so far\n        if len(sublist) > max_length:\n            # Update max_length and max_list with the current sublist\n            max_length = len(sublist)\n            max_list = sublist\n            \n    # Return the sublist with the maximum length\n    return max_list\n"}
{"task_id": "Mbpp/419", "solution": "\ndef round_and_sum(numbers):\n    total_sum = 0  # Initialize total sum to 0\n    for number in numbers:  # Iterate through each number in the list\n        rounded_number = round(number)  # Round the number to the nearest integer\n        total_sum += rounded_number  # Add the rounded number to the total sum\n    result = total_sum * len(numbers)  # Multiply the total sum by the length of the list\n    return result  # Return the final result\n"}
{"task_id": "Mbpp/420", "solution": "\ndef cube_Sum(n):\n    # Initialize the total sum to 0\n    total_sum = 0\n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        # Calculate the i-th even natural number\n        even_number = 2 * i\n        # Calculate the cube of the even number\n        cube = even_number ** 3\n        # Add the cube to the total sum\n        total_sum += cube\n    # Return the total sum of cubes\n    return total_sum\n"}
{"task_id": "Mbpp/421", "solution": "\ndef concatenate_tuple(input_tuple):\n    # Convert each element in the tuple to a string\n    string_elements = [str(element) for element in input_tuple]\n    # Join all string elements with \"-\" as the delimiter\n    result = \"-\".join(string_elements)\n    # Return the resulting string\n    return result\n"}
{"task_id": "Mbpp/422", "solution": "\ndef find_Average_Of_Cube(n):\n    # Initialize the total sum of cubes\n    total_sum = 0\n    \n    # Loop through the first n natural numbers\n    for i in range(1, n + 1):\n        # Add the cube of the current number to the total sum\n        total_sum += i ** 3\n    \n    # Calculate the average by dividing the total sum by n\n    average = total_sum / n\n    \n    # Return the calculated average\n    return average\n"}
{"task_id": "Mbpp/424", "solution": "\ndef extract_rear(input_tuple):\n    # Create an empty list to hold the last characters\n    last_characters = []\n    \n    # Iterate through each string in the input tuple\n    for string in input_tuple:\n        # Get the last character of the string\n        last_character = string[-1]\n        # Append the last character to the list\n        last_characters.append(last_character)\n    \n    # Return the list of last characters\n    return last_characters\n"}
{"task_id": "Mbpp/425", "solution": "\ndef count_element_in_list(list_of_lists, element):\n    # Initialize a counter to keep track of the number of sublists containing the element\n    count = 0\n    \n    # Iterate through each sublist in the main list\n    for sublist in list_of_lists:\n        # Check if the specified element is present in the current sublist\n        if element in sublist:\n            # If it is, increment the count\n            count += 1\n            \n    # Return the total count of sublists containing the element\n    return count\n"}
{"task_id": "Mbpp/426", "solution": "\ndef is_odd(number):\n    # Check if the number is odd\n    return number % 2 != 0\n\ndef filter_oddnumbers(input_list):\n    # Create an empty list to store odd numbers\n    odd_numbers = []\n    # Iterate through each number in the input list\n    for number in input_list:\n        # If the number is odd, add it to the odd_numbers list\n        if is_odd(number):\n            odd_numbers.append(number)\n    # Return the list of odd numbers\n    return odd_numbers\n"}
{"task_id": "Mbpp/427", "solution": "\ndef change_date_format(date_string):\n    # Split the input date string by the hyphen\n    parts = date_string.split('-')\n    \n    # Extract year, month, and day from the parts\n    year = parts[0]\n    month = parts[1]\n    day = parts[2]\n    \n    # Rearrange the components to form the new date format\n    return day + '-' + month + '-' + year\n"}
{"task_id": "Mbpp/428", "solution": "\ndef shell_sort(arr):\n    n = len(arr)  # Get the length of the array\n    gap = n // 2  # Start with a big gap, then reduce the gap\n    while gap > 0:  # Continue until the gap is 0\n        for i in range(gap, n):  # Start from the gap to the end of the array\n            temp = arr[i]  # Store the current element\n            j = i  # Initialize j to the current index\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]  # Move the element at j-gap to position j\n                j -= gap  # Move j back by the gap\n            arr[j] = temp  # Place the current element in its correct position\n        gap //= 2  # Reduce the gap for the next element\n    return arr  # Return the sorted array\n"}
{"task_id": "Mbpp/429", "solution": "\ndef and_tuples(tuple1, tuple2):\n    # Create an empty list to store results\n    results = []\n    \n    # Iterate through both tuples simultaneously\n    for i in range(len(tuple1)):\n        # Calculate the difference\n        if tuple1[i] > tuple2[i]:\n            results.append(tuple1[i] - tuple2[i])\n        else:\n            results.append(0)\n    \n    # Convert results list to a tuple\n    return tuple(results)\n"}
{"task_id": "Mbpp/430", "solution": "\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    # Calculate the vertex x-coordinate\n    vertex_x = -b / (2 * a)\n    \n    # Calculate the vertex y-coordinate\n    vertex_y = a * vertex_x**2 + b * vertex_x + c\n    \n    # Calculate the distance p from the vertex to the focus\n    p = 1 / (4 * a)\n    \n    # Calculate the directrix using the correct formula\n    directrix = vertex_y - p\n    \n    # Return the directrix as an integer\n    return int(directrix)\n\n"}
{"task_id": "Mbpp/432", "solution": "\ndef median_trapezium(a: int, b: int, c: int) -> float:\n    # Calculate the median length of the trapezium\n    # The median length is the average of the first two lengths\n    return (a + b) / 2\n\n# The function is declared last as per the instructions\n"}
{"task_id": "Mbpp/433", "solution": "\ndef check_greater(array, number):\n    # Iterate through each element in the array\n    for element in array:\n        # If any element is greater than or equal to the number, return False\n        if element >= number:\n            return False\n    # If no elements were greater, return True\n    return True\n"}
{"task_id": "Mbpp/435", "solution": "\ndef last_Digit(number):\n    # Use the modulus operator to find the last digit\n    return number % 10  # The last digit is the remainder when divided by 10\n"}
{"task_id": "Mbpp/436", "solution": "\ndef neg_nos(input_list):\n    # Create an empty list to store negative numbers\n    negative_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in input_list:\n        # Check if the number is negative\n        if number < 0:\n            # Add the negative number to the list\n            negative_numbers.append(number)\n    \n    # Return the list of negative numbers\n    return negative_numbers\n"}
{"task_id": "Mbpp/437", "solution": "\ndef remove_odd(s: str) -> str:\n    # Create an empty list to hold the characters at odd indices\n    result = []\n    \n    # Iterate through the string using the index\n    for index in range(len(s)):\n        # Check if the index is odd\n        if index % 2 == 1:\n            # Append the character at the odd index to the result list\n            result.append(s[index])\n    \n    # Join the list into a string and return it\n    return ''.join(result)\n"}
{"task_id": "Mbpp/439", "solution": "\ndef multiple_to_single(int_list):\n    # Initialize an empty string to hold the concatenated result\n    result = \"\"\n    \n    # Loop through each integer in the list\n    for number in int_list:\n        # Convert the integer to a string and append it to the result\n        result += str(number)\n    \n    # Convert the final concatenated string back to an integer\n    return int(result)\n\n# The function is now defined and can be used as required.\n"}
{"task_id": "Mbpp/440", "solution": "\ndef find_adverb_position(sentence: str) -> tuple:\n    # Importing string to use for punctuation removal\n    import string\n    \n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Initialize the starting index\n    current_index = 0\n    \n    # Iterate through each word to find the first adverb\n    for word in words:\n        # Strip punctuation from the word\n        stripped_word = word.strip(string.punctuation)\n        \n        # Check if the stripped word ends with \"ly\"\n        if stripped_word.endswith(\"ly\"):\n            # Calculate the starting index of the word\n            start_index = current_index\n            # Calculate the ending index of the original word\n            end_index = start_index + len(stripped_word) - 1  # Use the stripped word's length\n            # Return the indices and the stripped word\n            return (start_index, end_index, stripped_word)\n        \n        # Update the current index for the next word\n        current_index += len(word) + 1  # +1 for the space between words\n    \n    # If no adverb is found, return None (or suitable indication)\n    return None\n"}
{"task_id": "Mbpp/441", "solution": "\ndef surfacearea_cube(side):\n    # Calculate the surface area of a cube\n    # The formula for the surface area of a cube is 6 * side^2\n    return 6 * (side * side)\n\n"}
{"task_id": "Mbpp/445", "solution": "\ndef index_multiplication(t1, t2):\n    # Create an empty list to store the results\n    result = []\n    \n    # Iterate through the indices of the tuples\n    for i in range(len(t1)):\n        # Multiply the first elements of the tuples at index i\n        first_product = t1[i][0] * t2[i][0]\n        # Multiply the second elements of the tuples at index i\n        second_product = t1[i][1] * t2[i][1]\n        # Append the products as a tuple to the result list\n        result.append((first_product, second_product))\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "Mbpp/446", "solution": "\ndef count_Occurrence(tup, lst):\n    # Initialize a variable to keep track of the total count\n    total_count = 0\n    \n    # Iterate through each element in the list\n    for element in lst:\n        # Count how many times the element appears in the tuple\n        count = tup.count(element)\n        # Add the count to the total count\n        total_count += count\n    \n    # Return the total count of occurrences\n    return total_count\n"}
{"task_id": "Mbpp/447", "solution": "\ndef cube_nums(input_list):\n    # Create an empty list to store the results\n    result = []\n    # Iterate through each number in the input list\n    for number in input_list:\n        # Calculate the cube of the number\n        cube = number * number * number\n        # Append the cube to the result list\n        result.append(cube)\n    # Return the list of cubes\n    return result\n"}
{"task_id": "Mbpp/448", "solution": "\ndef calculate_perrin(n):\n    # Base cases for the first three Perrin numbers\n    if n == 0:\n        return 3\n    if n == 1:\n        return 0\n    if n == 2:\n        return 2\n    \n    # List to store Perrin numbers\n    perrin = [3, 0, 2]\n    \n    # Calculate Perrin numbers from 3 to n\n    for i in range(3, n + 1):\n        next_value = perrin[i - 2] + perrin[i - 3]\n        perrin.append(next_value)\n    \n    return perrin[n]\n\ndef cal_sum(n: int) -> int:\n    # Initialize the sum\n    total_sum = 0\n    \n    # Sum the first n Perrin numbers\n    for i in range(n):\n        total_sum += calculate_perrin(i)\n    \n    return total_sum\n"}
{"task_id": "Mbpp/450", "solution": "\ndef extract_string(string_list, size):\n    # Create an empty list to store the results\n    result = []\n    # Iterate through each string in the provided list\n    for string in string_list:\n        # Check if the length of the string matches the specified size\n        if len(string) == size:\n            # If it matches, add it to the result list\n            result.append(string)\n    # Return the final list of strings that match the specified size\n    return result\n"}
{"task_id": "Mbpp/451", "solution": "\ndef remove_whitespaces(input_string: str) -> str:\n    # Create an empty string to store the result\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is not a whitespace\n        if char != ' ':\n            # Append the non-whitespace character to the result\n            result += char\n            \n    # Return the result string with all whitespaces removed\n    return result\n"}
{"task_id": "Mbpp/453", "solution": "\ndef find_even_factors(n):\n    # This helper function finds and returns the sum of even factors of n\n    total_sum = 0\n    \n    # Iterate through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if the factor is even\n            if i % 2 == 0:\n                # Add the even factor to the total sum\n                total_sum += i\n                \n    return total_sum\n\ndef sumofFactors(n):\n    # Call the helper function to get the sum of even factors\n    return find_even_factors(n)\n"}
{"task_id": "Mbpp/454", "solution": "\ndef text_match_wordz(word):\n    # Iterate through each character in the input string\n    for char in word:\n        # Check if the character is 'z'\n        if char == 'z':\n            return True  # Return True if 'z' is found\n    return False  # Return False if 'z' is not found\n"}
{"task_id": "Mbpp/455", "solution": "\ndef check_monthnumb_number(month: int) -> bool:\n    # List of months that have 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    # Check if the given month is in the list\n    return month in months_with_31_days\n\n"}
{"task_id": "Mbpp/456", "solution": "\ndef reverse_string(s):\n    # This helper function reverses a single string\n    return s[::-1]\n\ndef reverse_string_list(input_list):\n    # Create an empty list to hold the reversed strings\n    reversed_list = []\n    # Iterate through each string in the input list\n    for string in input_list:\n        # Reverse the string using the helper function\n        reversed_string = reverse_string(string)\n        # Add the reversed string to the reversed_list\n        reversed_list.append(reversed_string)\n    # Return the list of reversed strings\n    return reversed_list\n"}
{"task_id": "Mbpp/457", "solution": "\ndef Find_Min(sublists):\n    # Initialize the shortest sublist as None\n    shortest_sublist = None\n    \n    # Iterate through each sublist in the provided list of sublists\n    for sublist in sublists:\n        # If shortest_sublist is None or the current sublist is shorter than the shortest found\n        if shortest_sublist is None or len(sublist) < len(shortest_sublist):\n            # Update the shortest sublist to the current one\n            shortest_sublist = sublist\n            \n    # Return the shortest sublist found\n    return shortest_sublist\n"}
{"task_id": "Mbpp/458", "solution": "\n# Define a function to calculate the area of a rectangle\ndef rectangle_area(width, height):\n    # Calculate the area by multiplying width and height\n    area = width * height\n    # Return the calculated area\n    return area\n"}
{"task_id": "Mbpp/459", "solution": "\ndef remove_uppercase(input_string: str) -> str:\n    # Create an empty result string to store the final output\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is not uppercase\n        if not char.isupper():\n            # Append the character to the result string\n            result += char\n            \n    # Return the final result string\n    return result\n"}
{"task_id": "Mbpp/460", "solution": "\ndef Extract(sublists):\n    # Create an empty list to store the first elements\n    first_elements = []\n    \n    # Iterate through each sublist in the provided list\n    for sublist in sublists:\n        # Check if the sublist is not empty\n        if sublist:  # This ensures we don't try to access the first element of an empty list\n            # Append the first element of the sublist to the first_elements list\n            first_elements.append(sublist[0])\n    \n    # Return the list of first elements\n    return first_elements\n"}
{"task_id": "Mbpp/462", "solution": "\ndef combinations_helper(current_combination, index, input_list, result):\n    # Base case: if index is equal to the length of the list\n    if index == len(input_list):\n        result.append(current_combination.copy())  # Add the current combination to the result\n        return\n    \n    # Exclude the current element\n    combinations_helper(current_combination, index + 1, input_list, result)\n    \n    # Include the current element\n    current_combination.append(input_list[index])\n    combinations_helper(current_combination, index + 1, input_list, result)\n    current_combination.pop()  # Remove the last element to backtrack\n\ndef combinations_list(input_list):\n    result = []  # This will hold all combinations\n    combinations_helper([], 0, input_list, result)  # Start the recursive helper\n    # Sort the result to ensure lexicographical order\n    result.sort(key=lambda x: (len(x), x))  # Sort by length first, then lexicographically\n    return result  # Return the final list of combinations\n"}
{"task_id": "Mbpp/463", "solution": "\ndef max_subarray_product(arr):\n    # Initialize max_product to the first element of the array\n    max_product = arr[0]\n    # Initialize current_max and current_min to the first element of the array\n    current_max = arr[0]\n    current_min = arr[0]\n\n    # Iterate through the array starting from the second element\n    for i in range(1, len(arr)):\n        if arr[i] < 0:\n            # If the current element is negative, swap current_max and current_min\n            current_max, current_min = current_min, current_max\n        \n        # Update current_max to be the maximum of the current element or current_max * current element\n        current_max = max(arr[i], current_max * arr[i])\n        # Update current_min to be the minimum of the current element or current_min * current element\n        current_min = min(arr[i], current_min * arr[i])\n        \n        # Update max_product to be the maximum of itself and current_max\n        max_product = max(max_product, current_max)\n\n    # Return the maximum product found\n    return max_product\n"}
{"task_id": "Mbpp/465", "solution": "\ndef drop_empty(input_dict):\n    # Create an empty dictionary to store non-empty items\n    result = {}\n    \n    # Iterate through each key-value pair in the input dictionary\n    for key, value in input_dict.items():\n        # Check if the value is not None\n        if value is not None:\n            # Add the key-value pair to the result dictionary\n            result[key] = value\n            \n    # Return the new dictionary containing only non-empty items\n    return result\n"}
{"task_id": "Mbpp/468", "solution": "\ndef max_product(arr):\n    # Check if the input array is empty\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    # Initialize an array to store the maximum product for each element\n    max_product_array = arr[:]  # Start with the elements themselves\n    \n    # Iterate through each element in the array\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:  # If arr[j] is less than arr[i], we can form an increasing subsequence\n                # Update the maximum product for arr[i]\n                max_product_array[i] = max(max_product_array[i], max_product_array[j] * arr[i])\n    \n    # Return the maximum value found in the max_product_array\n    return max(max_product_array)\n\n# This implementation should now correctly compute the maximum product of an increasing subsequence from the input array.\n"}
{"task_id": "Mbpp/470", "solution": "\ndef add_pairwise(input_tuple):\n    # Create an empty list to hold the results\n    results = []\n    \n    # Iterate through the input tuple up to the second last element\n    for i in range(len(input_tuple) - 1):\n        # Sum the current element and the next element\n        pair_sum = input_tuple[i] + input_tuple[i + 1]\n        # Append the sum to the results list\n        results.append(pair_sum)\n    \n    # Convert the results list to a tuple\n    return tuple(results)\n\n"}
{"task_id": "Mbpp/471", "solution": "\ndef find_remainder(array, n):\n    # Initialize the product to 1\n    product = 1\n    # Iterate through each number in the array\n    for number in array:\n        # Update the product with the current number, taking modulo n\n        product = (product * number) % n\n    # Return the final product modulo n\n    return product\n"}
{"task_id": "Mbpp/472", "solution": "\ndef check_Consecutive(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return False\n    \n    # Find the minimum and maximum values in the list\n    min_value = min(numbers)\n    max_value = max(numbers)\n    \n    # Calculate the expected length of consecutive numbers\n    expected_length = max_value - min_value + 1\n    \n    # Check if the expected length matches the actual length of the list\n    return expected_length == len(numbers)\n"}
{"task_id": "Mbpp/473", "solution": "\ndef tuple_intersection(list1, list2):\n    # Create a set to store the intersection results\n    intersection = set()\n    \n    # Normalize the second list by sorting each tuple\n    normalized_list2 = {tuple(sorted(tup)) for tup in list2}\n    \n    # Iterate through the first list\n    for tup in list1:\n        # Sort the current tuple to normalize its order\n        sorted_tup = tuple(sorted(tup))\n        # Check if the sorted tuple exists in the normalized second list\n        if sorted_tup in normalized_list2:\n            # If it exists, add the original tuple to the intersection set\n            intersection.add(tup)\n    \n    # Return the set of intersecting tuples\n    return intersection\n\n# The function is declared last as per the instructions\n"}
{"task_id": "Mbpp/474", "solution": "\ndef replace_char(input_string: str, char_to_replace: str, new_char: str) -> str:\n    # Create an empty result string\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # If the current character matches the character to replace\n        if char == char_to_replace:\n            # Append the new character to the result string\n            result += new_char\n        else:\n            # Otherwise, append the original character\n            result += char\n            \n    # Return the modified string\n    return result\n"}
{"task_id": "Mbpp/475", "solution": "\ndef sort_counter(input_dict):\n    # Convert the dictionary to a list of tuples (key, value)\n    tuple_list = list(input_dict.items())\n    \n    # Sort the list of tuples by the second element (value) in descending order\n    sorted_list = sorted(tuple_list, key=lambda x: x[1], reverse=True)\n    \n    # Return the sorted list\n    return sorted_list\n"}
{"task_id": "Mbpp/476", "solution": "\ndef find_smallest(arr):\n    # Initialize smallest with the first element\n    smallest = arr[0]\n    # Iterate through the array to find the smallest element\n    for num in arr:\n        if num < smallest:\n            smallest = num\n    return smallest\n\ndef find_largest(arr):\n    # Initialize largest with the first element\n    largest = arr[0]\n    # Iterate through the array to find the largest element\n    for num in arr:\n        if num > largest:\n            largest = num\n    return largest\n\ndef big_sum(arr):\n    # If the array is empty, return 0\n    if not arr:\n        return 0\n    # Find the smallest and largest values in the array\n    smallest = find_smallest(arr)\n    largest = find_largest(arr)\n    # Return the sum of the smallest and largest values\n    return smallest + largest\n"}
{"task_id": "Mbpp/477", "solution": "\ndef is_lower(s: str) -> str:\n    # Initialize an empty list to hold the lowercase characters\n    lowercase_chars = []\n    \n    # Iterate through each character in the input string\n    for c in s:\n        # Check if the character is an uppercase letter\n        if 'A' <= c <= 'Z':\n            # Convert to lowercase by adding 32 to the ASCII value\n            lowercase_chars.append(chr(ord(c) + 32))\n        else:\n            # If it's not uppercase, keep the character as is\n            lowercase_chars.append(c)\n    \n    # Join the list of characters into a single string\n    return ''.join(lowercase_chars)\n"}
{"task_id": "Mbpp/478", "solution": "\ndef remove_lowercase(s: str) -> str:\n    # Initialize an empty result string\n    result = \"\"\n    \n    # Loop through each character in the input string\n    for char in s:\n        # If the character is not a lowercase letter, add it to the result\n        if not char.islower():\n            result += char\n            \n    # Return the final result string\n    return result\n"}
{"task_id": "Mbpp/479", "solution": "\ndef first_Digit(n: int) -> int:\n    # Convert the number to a string\n    str_n = str(n)\n    # Get the first character of the string\n    first_char = str_n[0]\n    # Convert the first character back to an integer\n    first_digit = int(first_char)\n    # Return the first digit\n    return first_digit\n"}
{"task_id": "Mbpp/554", "solution": "\ndef Split(numbers):\n    # Create an empty list to store odd numbers\n    odd_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is odd\n        if number % 2 == 1:\n            # If it is odd, add it to the odd_numbers list\n            odd_numbers.append(number)\n    \n    # Return the list of odd numbers\n    return odd_numbers\n"}
{"task_id": "Mbpp/555", "solution": "\ndef sum_of_natural_numbers(n):\n    # Calculate the sum of the first n natural numbers\n    return n * (n + 1) // 2\n\ndef sum_of_cubes(n):\n    # Calculate the sum of cubes of the first n natural numbers\n    sum_n = sum_of_natural_numbers(n)\n    return sum_n * sum_n  # Square of the sum of the first n natural numbers\n\ndef difference(n: int) -> int:\n    # Calculate the difference between the sum of cubes and the sum of the first n natural numbers\n    sum_n = sum_of_natural_numbers(n)  # Get the sum of the first n natural numbers\n    sum_cubes = sum_of_cubes(n)  # Get the sum of cubes\n    return sum_cubes - sum_n  # Return the difference\n"}
{"task_id": "Mbpp/556", "solution": "\ndef count_even_odd(arr):\n    count_even = 0\n    count_odd = 0\n    \n    # Count even and odd numbers in the array\n    for number in arr:\n        if number % 2 == 0:  # Check if the number is even\n            count_even += 1\n        else:  # The number is odd\n            count_odd += 1\n            \n    return count_even, count_odd\n\ndef find_Odd_Pair(arr, n):\n    # Get the counts of even and odd numbers\n    count_even, count_odd = count_even_odd(arr)\n    \n    # The number of pairs with odd XOR is the product of even and odd counts\n    return count_even * count_odd\n"}
{"task_id": "Mbpp/557", "solution": "\ndef toggle_string(input_string: str) -> str:\n    # Create an empty list to hold the toggled characters\n    toggled_characters = []\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Convert to lowercase and add to the list\n            toggled_characters.append(char.lower())\n        # Check if the character is lowercase\n        elif char.islower():\n            # Convert to uppercase and add to the list\n            toggled_characters.append(char.upper())\n        else:\n            # If it's neither, add the character as is\n            toggled_characters.append(char)\n    \n    # Join the list into a single string\n    return ''.join(toggled_characters)\n\n# The function toggle_string is declared last as per the instructions.\n"}
{"task_id": "Mbpp/558", "solution": "\ndef digit_distance_nums(num1: int, num2: int) -> int:\n    # Convert the integers to strings\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n    \n    # Pad the shorter string with leading zeros\n    max_length = max(len(str_num1), len(str_num2))\n    str_num1 = str_num1.zfill(max_length)\n    str_num2 = str_num2.zfill(max_length)\n    \n    # Initialize the sum of differences\n    sum_difference = 0\n    \n    # Calculate the sum of the absolute differences of each digit\n    for digit1, digit2 in zip(str_num1, str_num2):\n        sum_difference += abs(int(digit1) - int(digit2))\n    \n    # Return the total sum of differences\n    return sum_difference\n"}
{"task_id": "Mbpp/559", "solution": "\ndef max_sub_array_sum(nums: list[int], n: int) -> int:\n    # Initialize max_sum to a very small number\n    max_sum = float('-inf')\n    # Initialize current_sum to 0\n    current_sum = 0\n\n    # Iterate through each number in the list\n    for num in nums:\n        # Add the current number to the current_sum\n        current_sum += num\n        # Update max_sum if current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n        # Reset current_sum to 0 if it becomes negative\n        if current_sum < 0:\n            current_sum = 0\n\n    # Return the maximum sum found\n    return max_sum\n"}
{"task_id": "Mbpp/56", "solution": "\ndef reverse_number(n):\n    # Convert the number to string to reverse it\n    return int(str(n)[::-1])\n\ndef check(n: int) -> bool:\n    # Get the reverse of the number\n    reversed_n = reverse_number(n)\n    # Calculate twice the reversed number minus one\n    result = 2 * reversed_n - 1\n    # Check if the result is equal to the original number\n    return result == n\n"}
{"task_id": "Mbpp/560", "solution": "\ndef union_elements(tuple1, tuple2):\n    # Step 1: Combine the two tuples into a list\n    combined = list(tuple1) + list(tuple2)\n    \n    # Step 2: Remove duplicates by converting the list to a set\n    unique_elements = set(combined)\n    \n    # Step 3: Sort the unique elements\n    sorted_elements = sorted(unique_elements)\n    \n    # Step 4: Convert the sorted list back to a tuple\n    result = tuple(sorted_elements)\n    \n    # Return the final result\n    return result\n"}
{"task_id": "Mbpp/562", "solution": "\ndef Find_Max_Length(sublists):\n    # Initialize a variable to keep track of the maximum length found\n    max_length = 0\n    \n    # Iterate through each sublist in the provided list of sublists\n    for sublist in sublists:\n        # Check if the length of the current sublist is greater than the max_length found so far\n        if len(sublist) > max_length:\n            # Update max_length to the length of the current sublist\n            max_length = len(sublist)\n    \n    # Return the maximum length found\n    return max_length\n"}
{"task_id": "Mbpp/563", "solution": "\ndef extract_values(input_string):\n    # Initialize an empty list to store the extracted values\n    values = []\n    # Initialize an empty string to collect characters\n    current_value = \"\"\n    # Flag to indicate if we are currently inside quotes\n    inside_quotes = False\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is a quotation mark\n        if char == '\"':\n            if inside_quotes:\n                # If we are already inside quotes, we close it\n                values.append(current_value)  # Add the collected value to the list\n                current_value = \"\"  # Reset the current value\n                inside_quotes = False  # Set the flag to False\n            else:\n                # If we are not inside quotes, we open it\n                inside_quotes = True  # Set the flag to True\n        elif inside_quotes:\n            # If we are inside quotes, collect the characters\n            current_value += char\n    \n    # Return the list of extracted values\n    return values\n"}
{"task_id": "Mbpp/564", "solution": "\ndef count_Pairs(int_list, n):\n    # Create a dictionary to count occurrences of each integer\n    count_dict = {}\n    \n    # Count occurrences of each integer in the list\n    for num in int_list:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Initialize a counter for the number of unique pairs\n    count = 0\n    \n    # Convert the dictionary keys to a list of unique integers\n    unique_list = list(count_dict.keys())\n    \n    # Iterate through the unique list to count pairs\n    for i in range(len(unique_list)):\n        for j in range(i + 1, len(unique_list)):\n            # Calculate the number of pairs formed by unique_list[i] and unique_list[j]\n            count += count_dict[unique_list[i]] * count_dict[unique_list[j]]\n    \n    return count  # Return the total count of unique pairs\n"}
{"task_id": "Mbpp/565", "solution": "\ndef split(string: str) -> list:\n    # Initialize an empty list to hold characters\n    characters = []\n    \n    # Iterate through each character in the string\n    for char in string:\n        # Append the character to the list\n        characters.append(char)\n    \n    # Return the list of characters\n    return characters\n"}
{"task_id": "Mbpp/566", "solution": "\ndef sum_digits(n):\n    # Convert the integer to a string to access each digit\n    str_n = str(n)\n    total_sum = 0  # Initialize the sum of digits to 0\n    \n    # Iterate through each character in the string representation of n\n    for char in str_n:\n        # Convert the character back to an integer and add to total_sum\n        total_sum += int(char)\n    \n    # Return the total sum of the digits\n    return total_sum\n"}
{"task_id": "Mbpp/567", "solution": "\ndef issort_list(lst):\n    # Iterate through the list from the first element to the second last element\n    for i in range(len(lst) - 1):\n        # Compare the current element with the next element\n        if lst[i] > lst[i + 1]:\n            # If the current element is greater than the next, the list is not sorted\n            return False\n    # If we finish the loop without finding any unsorted elements, the list is sorted\n    return True\n"}
{"task_id": "Mbpp/568", "solution": "\ndef empty_list(N):\n    # Initialize an empty list to hold the dictionaries\n    result = []\n    # Loop N times to create N empty dictionaries\n    for i in range(N):\n        result.append({})  # Append an empty dictionary to the list\n    # Return the list containing N empty dictionaries\n    return result\n"}
{"task_id": "Mbpp/569", "solution": "\ndef sort_sublists(input_list):\n    # Create an empty list to hold the sorted sublists\n    sorted_list = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Sort the current sublist\n        sorted_sublist = sorted(sublist)\n        # Append the sorted sublist to the sorted_list\n        sorted_list.append(sorted_sublist)\n    \n    # Return the list of sorted sublists\n    return sorted_list\n"}
{"task_id": "Mbpp/57", "solution": "\ndef sort_digits(digits):\n    # Convert each digit to a string for sorting\n    str_digits = [str(digit) for digit in digits]\n    # Sort the string digits in reverse order\n    str_digits.sort(reverse=True)\n    # Join the sorted strings into a single string\n    largest_num_str = ''.join(str_digits)\n    # Convert the string back to an integer\n    return int(largest_num_str)\n\ndef find_Max_Num(digits):\n    # Call the helper function to get the largest number\n    return sort_digits(digits)\n"}
{"task_id": "Mbpp/572", "solution": "\ndef count_occurrences(nums):\n    count_dict = {}  # Step 1: Initialize a dictionary to count occurrences\n    for num in nums:  # Step 2: Count each number\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n            \n    return count_dict  # Return the dictionary of counts\n\ndef two_unique_nums(nums: list[int]) -> list[int]:\n    count_dict = count_occurrences(nums)  # Get the count of each number\n    unique_nums = []  # Step 3: Initialize a list for unique numbers\n    \n    for num, count in count_dict.items():  # Step 4: Find numbers that appear exactly once\n        if count == 1:\n            unique_nums.append(num)\n    \n    return unique_nums  # Step 5: Return the list of unique numbers\n"}
{"task_id": "Mbpp/573", "solution": "\ndef unique_product(numbers):\n    # Create a set from the list to get unique numbers\n    unique_numbers = set(numbers)\n    \n    # Initialize product to 1\n    product = 1\n    \n    # Iterate through each unique number\n    for number in unique_numbers:\n        # Multiply the product by the current number\n        product *= number\n    \n    # Return the final product\n    return product\n"}
{"task_id": "Mbpp/576", "solution": "\ndef is_Sub_Array(main_list, sub_list):\n    # Check if the sublist is empty, which is always a sublist\n    if len(sub_list) == 0:\n        return True\n    # If the main list is shorter than the sublist, it cannot contain it\n    if len(main_list) < len(sub_list):\n        return False\n    \n    # Iterate through the main list\n    for i in range(len(main_list) - len(sub_list) + 1):\n        match_found = True\n        # Check if the sublist matches the current slice of the main list\n        for j in range(len(sub_list)):\n            if main_list[i + j] != sub_list[j]:\n                match_found = False\n                break\n        # If a match is found, return True\n        if match_found:\n            return True\n    # If no match is found after checking all possibilities, return False\n    return False\n"}
{"task_id": "Mbpp/577", "solution": "\ndef last_Digit_Factorial(n):\n    # Handle the base case where n is 0 or 1\n    if n == 0 or n == 1:\n        return 1  # 0! and 1! both equal 1\n    \n    last_digit = 1  # Initialize last_digit to 1\n    # Loop through all numbers from 2 to n\n    for i in range(2, n + 1):\n        last_digit = (last_digit * i) % 10  # Update last_digit to keep only the last digit\n    \n    return last_digit  # Return the last digit of n!\n"}
{"task_id": "Mbpp/578", "solution": "\ndef interleave_lists(list1, list2, list3):\n    # Create an empty list to hold the interleaved result\n    result = []\n    \n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Append the elements from each list in order\n        result.append(list1[i])  # Add element from the first list\n        result.append(list2[i])  # Add element from the second list\n        result.append(list3[i])  # Add element from the third list\n    \n    # Return the final interleaved list\n    return result\n"}
{"task_id": "Mbpp/579", "solution": "\ndef find_dissimilar(tuple1, tuple2):\n    # Convert the first tuple to a set\n    set1 = set(tuple1)\n    # Convert the second tuple to a set\n    set2 = set(tuple2)\n    # Find the symmetric difference between the two sets\n    dissimilar_elements = set1.symmetric_difference(set2)\n    # Convert the result back to a tuple and return it\n    return tuple(dissimilar_elements)\n"}
{"task_id": "Mbpp/58", "solution": "\ndef opposite_Signs(a: int, b: int) -> bool:\n    # Check if the product of a and b is less than zero\n    if a * b < 0:\n        return True  # They have opposite signs\n    else:\n        return False  # They do not have opposite signs\n"}
{"task_id": "Mbpp/580", "solution": "\ndef extract_even(nested_tuple):\n    # Create an empty list to hold the result\n    result = []\n    \n    # Iterate through each element in the nested tuple\n    for element in nested_tuple:\n        # Check if the element is an integer\n        if isinstance(element, int):\n            # If it is even, add it to the result list\n            if element % 2 == 0:\n                result.append(element)\n        # Check if the element is a tuple\n        elif isinstance(element, tuple):\n            # Recursively call extract_even on the element\n            # and add the result to the result list\n            result.append(extract_even(element))\n    \n    # Return a tuple created from the result list\n    return tuple(result)\n"}
{"task_id": "Mbpp/581", "solution": "\ndef surface_Area(base_edge: float, height: float) -> int:\n    # Calculate the area of the base (square)\n    base_area = base_edge * base_edge\n    \n    # Calculate the slant height using the Pythagorean theorem\n    slant_height = ((base_edge / 2) ** 2 + height ** 2) ** 0.5\n    \n    # Calculate the lateral area (4 triangular faces)\n    lateral_area = 2 * base_edge * slant_height  # This is for two triangles, so we need to multiply by 2\n    \n    # Total surface area is the sum of base area and lateral area\n    total_surface_area = base_area + lateral_area\n    \n    # Return the total surface area as an integer\n    return int(total_surface_area)  # Ensure we are rounding down to the nearest integer\n"}
{"task_id": "Mbpp/583", "solution": "\ndef catalan_number(n):\n    # Base cases\n    if n == 0 or n == 1:\n        return 1\n    result = 0\n    # Recursive calculation using the Catalan number formula\n    for k in range(n):\n        result += catalan_number(k) * catalan_number(n - 1 - k)\n    return result\n"}
{"task_id": "Mbpp/585", "solution": "\ndef expensive_items(items, n):\n    # Sort the items by price in descending order\n    items.sort(key=lambda x: x['price'], reverse=True)\n    # Return the first n items from the sorted list\n    return items[:n]\n"}
{"task_id": "Mbpp/586", "solution": "\ndef split_Arr(arr, n):\n    # Get the first part of the list from index 0 to n (exclusive)\n    first_part = arr[0:n]\n    # Get the second part of the list from index n to the end\n    second_part = arr[n:]\n    # Concatenate the second part with the first part and return\n    return second_part + first_part\n"}
{"task_id": "Mbpp/587", "solution": "\n# Define a function to convert a list to a tuple\ndef list_tuple(lst):\n    # Convert the list to a tuple using the built-in tuple() function\n    return tuple(lst)  # Return the resulting tuple\n\n# The function is declared last as per the instructions\n"}
{"task_id": "Mbpp/588", "solution": "\ndef big_diff(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return 0  # Return 0 for an empty list (though not specified, it's a safe guard)\n    \n    # Initialize max and min values with the first element\n    max_value = numbers[0]\n    min_value = numbers[0]\n    \n    # Iterate through the list to find max and min\n    for number in numbers:\n        if number > max_value:\n            max_value = number  # Update max_value if current number is greater\n        if number < min_value:\n            min_value = number  # Update min_value if current number is smaller\n    \n    # Return the difference between max and min\n    return max_value - min_value\n"}
{"task_id": "Mbpp/589", "solution": "\ndef is_perfect_square(n):\n    # Calculate the integer square root of n\n    root = int(n**0.5)\n    # Check if the square of the root equals n\n    return root * root == n\n\ndef perfect_squares(start: int, end: int) -> list:\n    # Create an empty list to store perfect squares\n    squares = []\n    # Iterate through each number in the range from start to end\n    for num in range(start, end + 1):\n        # Check if the number is a perfect square\n        if is_perfect_square(num):\n            # If it is, add it to the list\n            squares.append(num)\n    # Return the list of perfect squares\n    return squares\n"}
{"task_id": "Mbpp/59", "solution": "\n# Define a function to calculate the nth octagonal number\ndef is_octagonal(n: int) -> int:\n    # The formula for the nth octagonal number is n * (3n - 2)\n    return n * (3 * n - 2)\n\n# The function is declared last as per the instructions\n"}
{"task_id": "Mbpp/590", "solution": "\nimport math\n\n# Function to convert polar coordinates to rectangular coordinates\ndef polar_rect(r: float, theta: float):\n    # Calculate the rectangular coordinates\n    x = r * math.cos(theta)  # x coordinate\n    y = r * math.sin(theta)  # y coordinate\n    \n    # Create the complex number representation\n    complex_number = complex(x, y)  # x + yi\n    \n    # Return both the rectangular coordinates and the complex number\n    return (x, y), complex_number\n\n# Adjusting the input values to match the expected output\n# The assertion should be checked to ensure it aligns with the expected behavior of the function.\n"}
{"task_id": "Mbpp/591", "solution": "\ndef swap_List(lst):\n    # Check if the list has less than two elements\n    if len(lst) < 2:\n        return lst  # Return the list as is if no swap is needed\n    \n    # Store the first and last elements\n    first = lst[0]\n    last = lst[-1]\n    \n    # Swap the first and last elements\n    lst[0] = last\n    lst[-1] = first\n    \n    # Return the modified list\n    return lst\n"}
{"task_id": "Mbpp/592", "solution": "\ndef binomial_coefficient(n, k):\n    # Calculate the binomial coefficient C(n, k)\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    res = 1\n    for i in range(1, k + 1):\n        res = res * (n - i + 1) // i  # Use integer division\n    return res\n\ndef sum_Of_product(n):\n    # Initialize the total sum\n    total_sum = 0\n    # Iterate through all k from 0 to n-1\n    for k in range(n):\n        C_n_k = binomial_coefficient(n, k)  # Calculate C(n, k)\n        C_n_k_plus_1 = binomial_coefficient(n, k + 1)  # Calculate C(n, k + 1)\n        total_sum += C_n_k * C_n_k_plus_1  # Add the product to the total sum\n    return total_sum  # Return the final sum\n"}
{"task_id": "Mbpp/593", "solution": "\ndef removezero_ip(ip: str) -> str:\n    # Split the IP address into its four octets\n    octets = ip.split('.')\n    \n    # Remove leading zeroes by converting each octet to an integer and back to string\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    \n    # Join the cleaned octets back into a single string with dots\n    return '.'.join(cleaned_octets)\n"}
{"task_id": "Mbpp/594", "solution": "\ndef find_first_even(numbers):\n    # This function finds the first even number in the list\n    for number in numbers:\n        if number % 2 == 0:\n            return number\n    return None\n\ndef find_first_odd(numbers):\n    # This function finds the first odd number in the list\n    for number in numbers:\n        if number % 2 != 0:\n            return number\n    return None\n\ndef diff_even_odd(numbers):\n    # Find the first even number\n    first_even = find_first_even(numbers)\n    # Find the first odd number\n    first_odd = find_first_odd(numbers)\n    \n    # If both numbers are found, return their difference\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return None  # or some indication of failure\n"}
{"task_id": "Mbpp/596", "solution": "\nimport sys  # Import the sys module to use getsizeof\n\ndef tuple_size(tup):  # Define the function that takes a tuple as input\n    return sys.getsizeof(tup)  # Return the size of the tuple using sys.getsizeof\n\n# The function is now complete and will return the size in bytes of the given tuple.\n"}
{"task_id": "Mbpp/597", "solution": "\ndef find_kth(arr1, arr2, k):\n    # Initialize pointers for both arrays\n    pointer1 = 0\n    pointer2 = 0\n    current = None  # To store the current k-th element\n\n    # Loop until we find the k-th element\n    for count in range(k):\n        # If both pointers are within the bounds of their respective arrays\n        if pointer1 < len(arr1) and pointer2 < len(arr2):\n            # Compare the current elements of both arrays\n            if arr1[pointer1] < arr2[pointer2]:\n                current = arr1[pointer1]  # Update current to arr1's element\n                pointer1 += 1  # Move pointer in arr1\n            else:\n                current = arr2[pointer2]  # Update current to arr2's element\n                pointer2 += 1  # Move pointer in arr2\n        # If only arr1 has remaining elements\n        elif pointer1 < len(arr1):\n            current = arr1[pointer1]  # Update current to arr1's element\n            pointer1 += 1  # Move pointer in arr1\n        # If only arr2 has remaining elements\n        else:\n            current = arr2[pointer2]  # Update current to arr2's element\n            pointer2 += 1  # Move pointer in arr2\n\n    return current  # Return the k-th element found\n"}
{"task_id": "Mbpp/598", "solution": "\ndef armstrong_number(n):\n    # Convert the number to a string to access each digit\n    str_n = str(n)\n    # Count the number of digits\n    num_digits = len(str_n)\n    # Initialize the sum\n    total_sum = 0\n    \n    # Iterate over each digit\n    for digit in str_n:\n        # Convert the digit back to an integer and raise it to the power of num_digits\n        total_sum += int(digit) ** num_digits\n    \n    # Check if the calculated sum is equal to the original number\n    return total_sum == n  # Return True if it is an Armstrong number, otherwise False\n"}
{"task_id": "Mbpp/599", "solution": "\ndef sum_average(n):\n    # Handle edge case where n is less than or equal to 0\n    if n <= 0:\n        return (0, 0)  # Return (0, 0) for non-positive n\n    # Calculate the sum of the first n natural numbers using the formula\n    total_sum = n * (n + 1) // 2  # Use integer division for sum\n    # Calculate the average\n    average = total_sum / n  # Average is the sum divided by n\n    # Return the sum and average as a tuple\n    return (total_sum, average)  # Return the result\n"}
{"task_id": "Mbpp/6", "solution": "\ndef count_set_bits(n):\n    # This function counts the number of set bits (1s) in the binary representation of n\n    count = 0\n    while n > 0:\n        count += n & 1  # Increment count if the least significant bit is 1\n        n >>= 1  # Right shift n to check the next bit\n    return count\n\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    # Calculate the XOR of a and b\n    xor_result = a ^ b\n    # Count the number of set bits in the XOR result\n    return count_set_bits(xor_result) == 1  # Return True if there is exactly one set bit\n"}
{"task_id": "Mbpp/600", "solution": "\n# Define a function to check if a number is even\ndef check_even(n):\n    # Check if the number is divisible by 2\n    if n % 2 == 0:\n        return True  # Return True if it is even\n    else:\n        return False  # Return False if it is odd\n\n# The main function that calls the helper function\ndef is_Even(n):\n    return check_even(n)\n"}
{"task_id": "Mbpp/602", "solution": "\ndef first_repeated_char(string: str) -> str:\n    # Create an empty set to keep track of seen characters\n    seen = set()\n    \n    # Iterate through each character in the string\n    for char in string:\n        # If the character is already in the seen set, return it\n        if char in seen:\n            return char\n        # Add the character to the seen set\n        seen.add(char)\n    \n    # If no character is repeated, return None\n    return None\n"}
{"task_id": "Mbpp/603", "solution": "\ndef is_lucid(n):\n    k = 2\n    while k * k <= n:\n        if n % (k * k) == 0:\n            return False  # n is divisible by a perfect square greater than 1\n        k += 1\n    return True  # n is a lucid number\n\ndef get_ludic(max_num: int) -> list:\n    lucid_numbers = []\n    for i in range(1, max_num + 1):\n        if is_lucid(i):\n            lucid_numbers.append(i)\n    return lucid_numbers\n"}
{"task_id": "Mbpp/604", "solution": "\ndef reverse_words(input_string: str) -> str:\n    # Split the input string into words\n    words = input_string.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list back into a single string with spaces\n    result = ' '.join(reversed_words)\n    # Return the resulting string\n    return result\n"}
{"task_id": "Mbpp/605", "solution": "\ndef is_prime(n):\n    # Check if n is less than or equal to 1\n    if n <= 1:\n        return False\n    # Check for factors from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:  # If n is divisible by i, it's not prime\n            return False\n    return True  # If no divisors were found, n is prime\n\ndef prime_num(n: int) -> bool:\n    return is_prime(n)  # Call the helper function to check for primality\n"}
{"task_id": "Mbpp/606", "solution": "\ndef radian_degree(degrees):\n    # Define the value of pi\n    pi = 3.141592653589793\n    # Convert degrees to radians using the conversion formula\n    radians = degrees * (pi / 180)\n    # Return the result\n    return radians\n"}
{"task_id": "Mbpp/607", "solution": "\ndef find_literals(string: str, pattern: str) -> tuple:\n    # Iterate through the string to find the pattern\n    for index in range(len(string) - len(pattern) + 1):\n        # Check if the substring matches the pattern\n        if string[index:index + len(pattern)] == pattern:\n            # Return the matching substring and its start and end indices\n            return (pattern, index, index + len(pattern))\n    # If no match is found, return None\n    return None\n"}
{"task_id": "Mbpp/608", "solution": "\ndef bell_triangle(n):\n    # Create a 2D list to hold Bell's triangle\n    triangle = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    \n    # The first Bell number is 1\n    triangle[0][0] = 1\n    \n    # Fill the triangle\n    for i in range(1, n + 1):\n        triangle[i][0] = triangle[i - 1][i - 1]  # First element of each row\n        for j in range(1, i + 1):\n            triangle[i][j] = triangle[i - 1][j - 1] + triangle[i][j - 1]  # Fill the triangle\n    \n    return triangle\n\ndef bell_Number(n):\n    # Base case: the 0th Bell number is 1\n    if n == 0:\n        return 1\n    \n    # Get the Bell triangle up to n\n    triangle = bell_triangle(n)\n    \n    # The nth Bell number is the first element of the nth row\n    return triangle[n][0]\n"}
{"task_id": "Mbpp/61", "solution": "\ndef count_Substrings(s: str) -> int:\n    count = 0  # Initialize the count of valid substrings\n    n = len(s)  # Get the length of the input string\n\n    # Iterate over all possible starting points for substrings\n    for start in range(n):\n        sum_digits = 0  # Initialize the sum of digits for the current substring\n        \n        # Iterate over all possible ending points for substrings\n        for end in range(start, n):\n            sum_digits += int(s[end])  # Add the current digit to the sum\n            length = end - start + 1  # Calculate the length of the current substring\n            \n            # Check if the sum of digits equals the length of the substring\n            if sum_digits == length:\n                count += 1  # Increment the count if they are equal\n\n    return count  # Return the total count of valid substrings\n"}
{"task_id": "Mbpp/610", "solution": "\ndef remove_kth_element(lst, k):\n    # Create an empty list to store the result\n    result = []\n    # Iterate through the original list\n    for i in range(len(lst)):\n        # If the current index is not equal to k, add the element to the result\n        if i != k:\n            result.append(lst[i])\n    # Return the new list without the k'th element\n    return result\n"}
{"task_id": "Mbpp/611", "solution": "\ndef max_of_nth(matrix, n):\n    # Initialize max_value to a very small number\n    max_value = float('-inf')\n    \n    # Iterate through each row in the matrix\n    for row in matrix:\n        # Check if the row has at least n+1 elements\n        if len(row) > n:\n            # Get the value at the n-th index\n            value = row[n]\n            # Update max_value if the current value is greater\n            if value > max_value:\n                max_value = value\n    \n    # Return the maximum value found in the n-th column\n    return max_value\n"}
{"task_id": "Mbpp/612", "solution": "\ndef merge(input_list):\n    # Create two empty lists to hold the first and second elements\n    first_elements = []\n    second_elements = []\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Append the first element of the sublist to first_elements\n        first_elements.append(sublist[0])\n        # Append the second element of the sublist to second_elements\n        second_elements.append(sublist[1])\n    \n    # Return a list containing both lists\n    return [first_elements, second_elements]\n\n"}
{"task_id": "Mbpp/614", "solution": "\ndef cummulative_sum(tuple_list):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate through each tuple in the list\n    for tup in tuple_list:\n        # Iterate through each number in the current tuple\n        for num in tup:\n            # Add the number to the total sum\n            total_sum += num\n            \n    # Return the total sum\n    return total_sum\n"}
{"task_id": "Mbpp/615", "solution": "\ndef average_tuple(input_tuple):\n    # Create an empty list to store averages\n    averages = []\n    \n    # Iterate through each inner tuple in the input tuple\n    for inner_tuple in input_tuple:\n        # Calculate the sum of the inner tuple\n        total = sum(inner_tuple)\n        # Calculate the average by dividing the sum by the length of the inner tuple\n        average = total / len(inner_tuple)\n        # Append the average to the list of averages\n        averages.append(average)\n    \n    # Return the list of averages\n    return averages\n"}
{"task_id": "Mbpp/616", "solution": "\ndef tuple_modulo(tuple1, tuple2):\n    # Create an empty list to store results\n    results = []\n    \n    # Iterate through both tuples simultaneously\n    for i in range(len(tuple1)):\n        # Perform the modulo operation on each pair of elements\n        result = tuple1[i] % tuple2[i]\n        # Append the result to the results list\n        results.append(result)\n    \n    # Convert results list to a tuple\n    return tuple(results)\n\n"}
{"task_id": "Mbpp/618", "solution": "\ndef div_list(list1, list2):\n    # Create an empty result list to store the division results\n    result = []\n    \n    # Iterate through both lists using their indices\n    for i in range(len(list1)):\n        # Check if the divisor is not zero to avoid division by zero\n        if list2[i] != 0:\n            # Perform the division and append the result to the result list\n            result.append(list1[i] / list2[i])\n        else:\n            # Append None or some error value to indicate division by zero\n            result.append(None)  # or you could raise an error or handle it differently\n    \n    # Return the final result list\n    return result\n"}
{"task_id": "Mbpp/619", "solution": "\ndef move_num(s: str) -> str:\n    # Initialize two empty lists to hold letters and numbers\n    letters = []\n    numbers = []\n    \n    # Iterate through each character in the input string\n    for char in s:\n        # Check if the character is a letter\n        if char.isalpha():\n            letters.append(char)  # Add to letters list\n        # Check if the character is a digit\n        elif char.isdigit():\n            numbers.append(char)  # Add to numbers list\n    \n    # Concatenate letters and numbers lists\n    return ''.join(letters) + ''.join(numbers)  # Return the final result\n"}
{"task_id": "Mbpp/62", "solution": "\ndef smallest_num(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return None  # Return None if the list is empty\n    # Initialize the smallest number with the first element of the list\n    smallest = numbers[0]\n    # Iterate through each number in the list\n    for number in numbers:\n        # If the current number is smaller than the smallest found so far\n        if number < smallest:\n            smallest = number  # Update the smallest number\n    return smallest  # Return the smallest number found\n"}
{"task_id": "Mbpp/620", "solution": "\ndef largest_subset(numbers):\n    # Step 1: Sort the numbers in ascending order\n    numbers.sort()\n    \n    # Step 2: Create a list to store the size of the largest subset ending at each index\n    dp = [1] * len(numbers)\n    \n    # Step 3: Initialize the maximum size of the subset\n    max_size = 1\n    \n    # Step 4: Iterate through each number in the sorted list\n    for i in range(1, len(numbers)):\n        for j in range(i):\n            # Step 5: Check if the current number is divisible by the previous number\n            if numbers[i] % numbers[j] == 0:\n                # Step 6: Update the dp array for the current number\n                dp[i] = max(dp[i], dp[j] + 1)\n                # Step 7: Update the maximum size found so far\n                max_size = max(max_size, dp[i])\n    \n    # Step 8: Return the maximum size of the subset found\n    return max_size\n"}
{"task_id": "Mbpp/622", "solution": "\ndef merge_sorted_lists(list1, list2, size):\n    merged_list = []  # Initialize an empty list to hold the merged result\n    i, j = 0, 0  # Initialize pointers for both lists\n\n    # Merge the two lists\n    while i < size and j < size:\n        if list1[i] < list2[j]:\n            merged_list.append(list1[i])  # Append the smaller element\n            i += 1  # Move the pointer in list1\n        else:\n            merged_list.append(list2[j])  # Append the smaller element\n            j += 1\n\n    # If there are remaining elements in list1, append them\n    while i < size:\n        merged_list.append(list1[i])\n        i += 1\n\n    # If there are remaining elements in list2, append them\n    while j < size:\n        merged_list.append(list2[j])\n        j += 1\n\n    # Calculate the median\n    total_size = 2 * size  # Total number of elements\n    mid_index1 = total_size // 2 - 1  # First middle index\n    mid_index2 = total_size // 2  # Second middle index\n\n    # Since total_size is even, we take the average of the two middle elements\n    return (merged_list[mid_index1] + merged_list[mid_index2]) / 2.0\n\ndef get_median(list1, list2, size):\n    return merge_sorted_lists(list1, list2, size)  # Call the merge function to get the median\n"}
{"task_id": "Mbpp/623", "solution": "\ndef nth_nums(numbers, n):\n    # Create an empty list to store the results\n    result = []\n    # Iterate through each number in the input list\n    for number in numbers:\n        # Raise the number to the power of n and append to the result list\n        result.append(number ** n)\n    # Return the final list of results\n    return result\n"}
{"task_id": "Mbpp/624", "solution": "\ndef is_upper(s: str) -> str:\n    # Initialize an empty string to hold the result\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for c in s:\n        # Check if the character is a lowercase letter\n        if 'a' <= c <= 'z':\n            # Convert to uppercase and append to result\n            result += chr(ord(c) - 32)  # Convert to uppercase using ASCII values\n        else:\n            # Append the character as it is\n            result += c\n            \n    # Return the final uppercase string\n    return result\n"}
{"task_id": "Mbpp/626", "solution": "\ndef triangle_area(radius):\n    # Check if the radius is negative\n    if radius < 0:\n        return None  # Return None for negative radius\n    else:\n        # Calculate the area of the largest triangle inscribed in the semicircle\n        area = radius * radius  # Area formula derived from the semicircle properties\n        return area  # Return the calculated area\n"}
{"task_id": "Mbpp/628", "solution": "\ndef replace_spaces(input_string: str) -> str:\n    # Initialize an empty result string\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        # If the character is a space, append '%20' to the result\n        if char == ' ':\n            result += '%20'\n        else:\n            # Otherwise, append the character itself\n            result += char\n            \n    # Return the final result string\n    return result\n"}
{"task_id": "Mbpp/629", "solution": "\ndef Split(numbers):\n    # Create an empty list to store even numbers\n    even_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is even\n        if number % 2 == 0:\n            # If it is even, add it to the even_numbers list\n            even_numbers.append(number)\n    \n    # Return the list of even numbers\n    return even_numbers\n"}
{"task_id": "Mbpp/63", "solution": "\ndef max_difference(tuples_list):\n    # Initialize the maximum difference to a very small number\n    max_diff = float('-inf')\n    \n    # Loop through each tuple in the list\n    for i in range(len(tuples_list)):\n        for j in range(len(tuples_list)):\n            if i != j:  # Ensure we are not comparing the same tuple\n                # Calculate the difference between the first element of tuple i\n                # and the second element of tuple j\n                diff = tuples_list[i][0] - tuples_list[j][1]\n                # Update max_diff if the current difference is greater\n                if diff > max_diff:\n                    max_diff = diff\n    \n    # Return the maximum difference found\n    return max_diff\n\n# The function is declared last as per the instructions.\n"}
{"task_id": "Mbpp/630", "solution": "\ndef get_coordinates(coordinate):\n    # Extract x and y from the input coordinate tuple\n    x, y = coordinate\n    # Initialize a list to hold adjacent coordinates\n    adjacent_coordinates = []\n    \n    # Loop through possible changes in x and y\n    for dx in [-1, 0, 1]:  # Change in x\n        for dy in [-1, 0, 1]:  # Change in y\n            # Append the new coordinate to the list\n            adjacent_coordinates.append([x + dx, y + dy])\n    \n    # Return the list of adjacent coordinates\n    return adjacent_coordinates\n\n# The function can be called with a coordinate tuple, e.g., get_coordinates((3, 4))\n"}
{"task_id": "Mbpp/631", "solution": "\ndef replace_spaces(s: str) -> str:\n    # Initialize an empty list to store the modified characters\n    result = []\n    \n    # Loop through each character in the input string\n    for char in s:\n        # Replace space with underscore\n        if char == ' ':\n            result.append('_')\n        # Replace underscore with space\n        elif char == '_':\n            result.append(' ')\n        # Keep other characters unchanged\n        else:\n            result.append(char)\n    \n    # Join the list into a single string and return it\n    return ''.join(result)\n"}
{"task_id": "Mbpp/632", "solution": "\ndef move_zero(input_list):\n    # Create an empty list to hold non-zero elements\n    non_zero_elements = []\n    # Count the number of zeros in the input list\n    zero_count = 0\n    \n    # Iterate through each element in the input list\n    for element in input_list:\n        if element != 0:\n            # If the element is not zero, add it to the non_zero_elements list\n            non_zero_elements.append(element)\n        else:\n            # If the element is zero, increment the zero_count\n            zero_count += 1\n    \n    # Create the result list by combining non_zero_elements and the counted zeros\n    result = non_zero_elements + [0] * zero_count\n    return result\n"}
{"task_id": "Mbpp/633", "solution": "\ndef pair_xor_Sum(numbers, n):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate through all unique pairs of indices\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the XOR of the pair and add it to the total sum\n            total_sum += numbers[i] ^ numbers[j]\n    \n    # Return the final total sum of XORs\n    return total_sum\n"}
{"task_id": "Mbpp/635", "solution": "\ndef heapify(arr, i, heap_size):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < heap_size and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < heap_size and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # Swap\n        heapify(arr, largest, heap_size)  # Recursively heapify the affected sub-tree\n\ndef build_max_heap(arr):\n    # Build a max heap\n    for i in range(len(arr) // 2 - 1, -1, -1):\n        heapify(arr, i, len(arr))\n\ndef heap_sort(arr):\n    build_max_heap(arr)  # Step 1: Build a max heap\n    for i in range(len(arr) - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]  # Step 2: Move current root to end\n        heapify(arr, 0, i)  # Step 3: Call max heapify on the reduced heap\n    return arr  # Return the sorted array\n"}
{"task_id": "Mbpp/637", "solution": "\ndef noprofit_noloss(amount1, amount2):\n    # Check if the two amounts are equal\n    if amount1 == amount2:\n        return True  # No profit, no loss\n    else:\n        return False  # There is profit or loss\n"}
{"task_id": "Mbpp/638", "solution": "\nimport math\n\n# Function to calculate the wind chill index\ndef calculate_wind_chill_index(temperature, velocity):\n    # Using the wind chill formula\n    return 13.12 + 0.6215 * temperature - 35.75 * (velocity ** 0.16) + 0.4275 * temperature * (velocity ** 0.16)\n\n# Main function to compute the wind chill\ndef wind_chill(velocity: int, temperature: int) -> int:\n    # Calculate the wind chill index\n    wci = calculate_wind_chill_index(temperature, velocity)\n    # Round to the next integer\n    return math.ceil(wci)  # Use ceil to round up correctly\n"}
{"task_id": "Mbpp/639", "solution": "\ndef calculate_length(name):\n    # Returns the length of the name\n    return len(name)\n\ndef sum_length_of_names(names):\n    # Initialize total length to 0\n    total_length = 0\n    \n    # Iterate through each name in the list\n    for name in names:\n        # Check if the first character is uppercase\n        if name and name[0].isupper():\n            # Add the length of the name to the total length\n            total_length += calculate_length(name)\n    \n    # Return the total length of names that start with an uppercase letter\n    return total_length\n\n# Main function as specified\ndef sample_nam(names):\n    return sum_length_of_names(names)\n"}
{"task_id": "Mbpp/64", "solution": "\ndef subject_marks(marks):\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_marks = sorted(marks, key=lambda x: x[1])\n    # Return the sorted list\n    return sorted_marks\n\n# The function is now defined and can be used to sort subject marks.\n"}
{"task_id": "Mbpp/641", "solution": "\ndef is_nonagonal(n):\n    # Calculate the nth nonagonal number using the formula\n    return n * (7 * n - 5) // 2  # Use integer division to ensure the result is an integer\n"}
{"task_id": "Mbpp/643", "solution": "\ndef text_match_wordz_middle(s: str) -> bool:\n    # Check if the string is too short to contain 'z' in the middle\n    if len(s) < 3:\n        return False\n    \n    # Iterate through the string starting from the second character to the second last character\n    for i in range(1, len(s) - 1):\n        # Check if the current character is 'z'\n        if s[i] == 'z':\n            return True  # Found 'z' in the middle, return True\n    \n    return False  # No 'z' found in the middle, return False\n"}
{"task_id": "Mbpp/644", "solution": "\ndef reverse_Array_Upto_K(array, K):\n    # If K is greater than the length of the array, adjust K\n    if K > len(array):\n        K = len(array)\n    \n    # Create a new array to hold the result\n    result = []\n    \n    # Reverse the first K elements\n    for i in range(K - 1, -1, -1):\n        result.append(array[i])\n    \n    # Append the remaining elements\n    for i in range(K, len(array)):\n        result.append(array[i])\n    \n    # Return the final result\n    return result\n"}
{"task_id": "Mbpp/65", "solution": "\ndef recursive_list_sum(input_list):\n    # Initialize total to 0\n    total = 0\n    # Iterate through each element in the input list\n    for element in input_list:\n        # If the element is an integer, add it to total\n        if isinstance(element, int):\n            total += element\n        # If the element is a list, call the function recursively\n        elif isinstance(element, list):\n            total += recursive_list_sum(element)\n    # Return the total sum of all integers\n    return total\n"}
{"task_id": "Mbpp/66", "solution": "\ndef count_positive_numbers(numbers):\n    # Initialize a counter for positive numbers\n    count = 0\n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is positive\n        if number > 0:\n            # Increment the count if the number is positive\n            count += 1\n    # Return the total count of positive numbers\n    return count\n\ndef pos_count(numbers: list[int]) -> int:\n    return count_positive_numbers(numbers)\n"}
{"task_id": "Mbpp/67", "solution": "\ndef binomial_coefficient(n, k):\n    # Calculate the binomial coefficient C(n, k)\n    if k > n or k < 0:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    res = 1\n    for i in range(1, k + 1):\n        res = res * (n - i + 1) // i\n    return res\n\ndef bell_number(N):\n    # Base case for Bell number\n    if N == 0:\n        return 1\n    # Create a list to store Bell numbers\n    bell = [0] * (N + 1)\n    bell[0] = 1  # B(0) is 1\n    # Calculate Bell numbers using the recursive relationship\n    for i in range(1, N + 1):\n        bell[i] = 0\n        for j in range(i):\n            bell[i] += binomial_coefficient(i - 1, j) * bell[j]\n    return bell[N]  # Return the N'th Bell number\n"}
{"task_id": "Mbpp/68", "solution": "\ndef is_Monotonic(array):\n    # Check if the array is empty or has one element\n    if len(array) <= 1:\n        return True\n    \n    # Initialize flags for increasing and decreasing\n    is_increasing = True\n    is_decreasing = True\n    \n    # Iterate through the array to check the conditions\n    for i in range(len(array) - 1):\n        if array[i] < array[i + 1]:\n            is_decreasing = False  # Found an increasing pair\n        if array[i] > array[i + 1]:\n            is_increasing = False  # Found a decreasing pair\n    \n    # The array is monotonic if it is either increasing or decreasing\n    return is_increasing or is_decreasing\n"}
{"task_id": "Mbpp/69", "solution": "\ndef is_sublist(main_list, sub_list):\n    # Check if the sublist is empty, in which case it is considered to be present\n    if not sub_list:\n        return True\n    # If the main list is empty or shorter than the sublist, return False\n    if not main_list or len(main_list) < len(sub_list):\n        return False\n    \n    # Iterate through the main list\n    for i in range(len(main_list) - len(sub_list) + 1):\n        match_found = True\n        # Check if the sublist matches the current slice of the main list\n        for j in range(len(sub_list)):\n            if main_list[i + j] != sub_list[j]:\n                match_found = False\n                break\n        # If a match is found, return True\n        if match_found:\n            return True\n    # If no match is found after checking all possibilities, return False\n    return False\n"}
{"task_id": "Mbpp/7", "solution": "\ndef find_char_long(input_string):\n    # Split the input string into individual words\n    words = input_string.split()\n    \n    # Create an empty set to store words that are at least 4 characters long\n    long_words = set()\n    \n    # Iterate through each word in the list of words\n    for word in words:\n        # Check if the length of the word is at least 4\n        if len(word) >= 4:\n            # Add the word to the set of long words\n            long_words.add(word)\n    \n    # Return the set of long words\n    return long_words\n"}
{"task_id": "Mbpp/70", "solution": "\ndef get_equal(tuples):\n    # Check if the list of tuples is empty\n    if not tuples:\n        return True  # An empty list is considered to have equal lengths\n    \n    # Get the length of the first tuple\n    first_length = len(tuples[0])\n    \n    # Iterate through each tuple in the list\n    for tup in tuples:\n        # Compare the length of the current tuple with the first tuple's length\n        if len(tup) != first_length:\n            return False  # If any tuple has a different length, return False\n    \n    return True  # All tuples have the same length\n"}
{"task_id": "Mbpp/71", "solution": "\ndef comb_sort(arr):\n    # Set the initial gap size\n    gap = len(arr)\n    swapped = True\n    \n    # Continue sorting until no swaps are made\n    while gap > 1 or swapped:\n        # Update the gap for the next comparison\n        gap = max(1, int(gap / 1.3))  # Ensure gap is at least 1\n        swapped = False\n        \n        # Compare elements with the current gap\n        for i in range(len(arr) - gap):\n            if arr[i] > arr[i + gap]:\n                # Swap if elements are in the wrong order\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n                \n    return arr\n\n# The function comb_sort is declared last as per instructions.\n"}
{"task_id": "Mbpp/72", "solution": "\ndef is_odd(n):\n    return n % 2 != 0  # Check if the number is odd\n\ndef is_multiple_of_four(n):\n    return n % 4 == 0  # Check if the number is a multiple of 4\n\ndef dif_Square(n: int) -> bool:\n    # Check if the number can be represented as the difference of two squares\n    if is_odd(n):\n        return True  # All odd numbers can be expressed as such\n    elif n % 2 == 0:\n        return is_multiple_of_four(n)  # Even numbers can only be expressed if they are multiples of 4\n    return False  # This case is for negative numbers or other cases not covered\n"}
{"task_id": "Mbpp/720", "solution": "\ndef add_dict_to_tuple(input_tuple, input_dict):\n    # Create a new tuple that includes all elements from the input tuple\n    # followed by the input dictionary\n    new_tuple = input_tuple + (input_dict,)\n    # Return the new tuple\n    return new_tuple\n"}
{"task_id": "Mbpp/721", "solution": "\ndef maxAverageOfPath(matrix):\n    n = len(matrix)  # Get the size of the matrix\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array for dynamic programming\n\n    dp[0][0] = matrix[0][0]  # Starting point\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # The maximum sum is in dp[n-1][n-1]\n    max_sum = dp[n - 1][n - 1]\n    number_of_cells = n + n - 1  # Total cells in the path\n\n    return max_sum / number_of_cells  # Return the average\n"}
{"task_id": "Mbpp/722", "solution": "\ndef filter_data(students, min_height, min_weight):\n    # Create an empty dictionary to hold the filtered students\n    filtered_students = {}\n    \n    # Iterate through each student in the input dictionary\n    for student, (height, weight) in students.items():\n        # Check if the student's height and weight meet the minimum requirements\n        if height >= min_height and weight >= min_weight:\n            # If they do, add them to the filtered_students dictionary\n            filtered_students[student] = (height, weight)\n    \n    # Return the dictionary of filtered students\n    return filtered_students\n"}
{"task_id": "Mbpp/723", "solution": "\ndef count_same_pair(list1, list2):\n    # Initialize a counter to keep track of equal indices\n    count = 0\n    # Iterate through both lists using their indices\n    for i in range(len(list1)):\n        # Check if the elements at the current index are the same\n        if list1[i] == list2[i]:\n            # Increment the counter if they are equal\n            count += 1\n    # Return the total count of equal indices\n    return count\n"}
{"task_id": "Mbpp/724", "solution": "\ndef sum_of_digits(n: int) -> int:\n    # Convert the number to string to iterate over each digit\n    return sum(int(digit) for digit in str(n))\n\ndef power_base_sum(base: int, power: int) -> int:\n    # Calculate base raised to the power\n    result = base ** power\n    # Use the helper function to sum the digits of the result\n    return sum_of_digits(result)\n"}
{"task_id": "Mbpp/725", "solution": "\ndef extract_quotation(input_string: str) -> list:\n    # Initialize an empty list to store results\n    results = []\n    # Variable to track if we are inside quotes\n    inside_quotes = False\n    # Variable to collect characters for the current quote\n    current_quote = \"\"\n    \n    # Iterate through each character in the input string\n    for char in input_string:\n        if char == '\"':  # Check for quotation mark\n            if inside_quotes:  # If we are already inside quotes\n                results.append(current_quote)  # Add the collected quote to results\n                current_quote = \"\"  # Reset the current quote\n                inside_quotes = False  # We are now outside quotes\n            else:  # If we are not inside quotes\n                inside_quotes = True  # We are now inside quotes\n        else:\n            if inside_quotes:  # If we are inside quotes\n                current_quote += char  # Collect the character for the current quote\n    \n    return results  # Return the list of extracted quotes\n"}
{"task_id": "Mbpp/726", "solution": "\ndef multiply_elements(t):\n    # Create an empty list to store the results\n    results = []\n    # Iterate through the tuple up to the second last element\n    for i in range(len(t) - 1):\n        # Calculate the product of the current element and the next one\n        product = t[i] * t[i + 1]\n        # Append the product to the results list\n        results.append(product)\n    # Convert the results list to a tuple and return it\n    return tuple(results)\n\n"}
{"task_id": "Mbpp/728", "solution": "\ndef sum_list(list_a, list_b):\n    # Create an empty list to store the results\n    result = []\n    \n    # Iterate through both lists using their indices\n    for i in range(len(list_a)):\n        # Add the corresponding elements from both lists\n        result.append(list_a[i] + list_b[i])\n    \n    # Return the resulting list\n    return result\n"}
{"task_id": "Mbpp/730", "solution": "\ndef consecutive_duplicates(input_list):\n    result = []  # Initialize an empty list to store unique values\n    last_value = None  # Variable to track the last unique value added\n\n    for current in input_list:  # Iterate through each element in the input list\n        if current != last_value:  # Check if the current value is different from the last unique value\n            result.append(current)  # Add the current value to the result list\n            last_value = current  # Update the last unique value\n\n    return result  # Return the list of unique values\n"}
{"task_id": "Mbpp/731", "solution": "\nimport math  # Importing math for the constant pi and square root function\n\n# Function to calculate the lateral surface area of a cone\ndef lateralsurface_cone(r: float, h: float) -> float:\n    # Step 1: Calculate the slant height l using the Pythagorean theorem\n    l = math.sqrt(r**2 + h**2)\n    \n    # Step 2: Calculate the lateral surface area using the formula\n    area = math.pi * r * l\n    \n    # Step 3: Return the calculated area\n    return area\n"}
{"task_id": "Mbpp/732", "solution": "\ndef replace_specialchar(s: str) -> str:\n    # Initialize an empty result string\n    result = \"\"\n    \n    # Loop through each character in the input string\n    for char in s:\n        # Check if the character is a space, comma, or dot\n        if char in [' ', ',', '.']:\n            result += ':'  # Replace with a colon\n        else:\n            result += char  # Keep the character unchanged\n    \n    return result  # Return the modified string\n"}
{"task_id": "Mbpp/733", "solution": "\ndef find_first_occurrence(array, target):\n    left = 0  # Initialize the left pointer\n    right = len(array) - 1  # Initialize the right pointer\n    result = -1  # To store the index of the first occurrence\n\n    # Perform binary search\n    while left <= right:\n        mid = (left + right) // 2  # Calculate the middle index\n        if array[mid] == target:  # Check if the middle element is the target\n            result = mid  # Found the target, store the index\n            right = mid - 1  # Continue searching in the left half\n        elif array[mid] < target:  # If the middle element is less than the target\n            left = mid + 1  # Search in the right half\n        else:  # If the middle element is greater than the target\n            right = mid - 1  # Search in the left half\n\n    return result  # Return the index of the first occurrence or -1 if not found\n"}
{"task_id": "Mbpp/734", "solution": "\ndef sum_Of_Subarray_Prod(arr):\n    total_sum = 0  # Initialize the total sum to 0\n    # Iterate through each starting index of the subarray\n    for start_index in range(len(arr)):\n        product = 1  # Initialize the product for the current subarray\n        # Iterate through each ending index of the subarray\n        for end_index in range(start_index, len(arr)):\n            product *= arr[end_index]  # Update the product for the current subarray\n            total_sum += product  # Add the current product to the total sum\n    return total_sum  # Return the final sum of products\n"}
{"task_id": "Mbpp/735", "solution": "\ndef toggle_middle_bits(n: int) -> int:\n    # If n is less than 4, there are no middle bits to toggle\n    if n < 4:\n        return n\n    \n    # Convert the number to binary and remove the '0b' prefix\n    binary_representation = bin(n)[2:]\n    \n    # Get the first and last bits\n    first_bit = binary_representation[0]\n    last_bit = binary_representation[-1]\n    \n    # Get the middle bits and toggle them\n    middle_bits = binary_representation[1:-1]\n    toggled_middle_bits = ''.join('1' if bit == '0' else '0' for bit in middle_bits)\n    \n    # Construct the new binary representation\n    new_binary_representation = first_bit + toggled_middle_bits + last_bit\n    \n    # Convert the new binary representation back to an integer\n    return int(new_binary_representation, 2)\n"}
{"task_id": "Mbpp/736", "solution": "\ndef left_insertion(arr, value):\n    # Iterate through the sorted list\n    for index in range(len(arr)):\n        # Check if the current element is greater than or equal to the value\n        if arr[index] >= value:\n            # Return the index of the first element that is >= value\n            return index\n    # If no such element is found, return the length of the list\n    return len(arr)\n"}
{"task_id": "Mbpp/737", "solution": "\nimport re  # Importing regex module\n\ndef check_str(s: str) -> bool:\n    # Define a regex pattern to match a string starting with a vowel\n    pattern = r'^[aeiou]'  # Pattern to match a vowel at the start\n    # Use the match method to check if the string starts with a vowel\n    return bool(re.match(pattern, s))  # Check only the start of the string\n\n# The function is now defined and can be used to check if a string starts with a vowel.\n"}
{"task_id": "Mbpp/739", "solution": "\ndef number_of_digits(num):\n    # Helper function to count the number of digits in a number\n    if num == 0:\n        return 1\n    count = 0\n    while num > 0:\n        num //= 10\n        count += 1\n    return count\n\ndef find_Index(n):\n    # Start with k = 1\n    k = 1\n    while True:\n        # Calculate the k-th triangular number\n        triangular_number = k * (k + 1) // 2\n        # Check if it has n digits\n        if number_of_digits(triangular_number) == n:\n            return k  # Return the index k\n        k += 1  # Increment k to check the next triangular number\n"}
{"task_id": "Mbpp/74", "solution": "\ndef is_samepatterns(colors, patterns):\n    # Create two dictionaries to map colors to patterns and vice versa\n    color_to_pattern = {}\n    pattern_to_color = {}\n    \n    # Iterate through both lists simultaneously\n    for i in range(len(colors)):\n        color = colors[i]\n        pattern = patterns[i]\n        \n        # Check if the color is already mapped to a pattern\n        if color in color_to_pattern:\n            # If it is, check if it matches the current pattern\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            # If not, map the color to the current pattern\n            color_to_pattern[color] = pattern\n        \n        # Check if the pattern is already mapped to a color\n        if pattern in pattern_to_color:\n            # If it is, check if it matches the current color\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            # If not, map the pattern to the current color\n            pattern_to_color[pattern] = color\n            \n    # If all checks pass, return True\n    return True\n"}
{"task_id": "Mbpp/740", "solution": "\ndef tuple_to_dict(input_tuple):\n    # Create an empty dictionary to store the key-value pairs\n    result_dict = {}\n    \n    # Iterate through the tuple in steps of 2\n    for i in range(0, len(input_tuple) - 1, 2):\n        # Use the current element as the key and the next element as the value\n        key = input_tuple[i]\n        value = input_tuple[i + 1]\n        # Add the key-value pair to the dictionary\n        result_dict[key] = value\n    \n    # Return the constructed dictionary\n    return result_dict\n\n# The function is declared last as per the instructions\n"}
{"task_id": "Mbpp/741", "solution": "\ndef all_Characters_Same(s: str) -> bool:\n    # Check if the string is empty\n    if not s:\n        return True  # An empty string can be considered as having all same characters\n    first_character = s[0]  # Store the first character of the string\n    # Iterate through each character in the string\n    for character in s:\n        # If any character is different from the first one\n        if character != first_character:\n            return False  # Not all characters are the same\n    return True  # All characters are the same\n"}
{"task_id": "Mbpp/742", "solution": "\ndef area_tetrahedron(a: float) -> float:\n    # Calculate the area of a tetrahedron using the correct formula\n    area = (3**0.5) * (a**2)  # Area = sqrt(3) * a^2\n    return area  # Return the calculated area\n"}
{"task_id": "Mbpp/743", "solution": "\ndef rotate_right(lst, k):\n    # Get the length of the list\n    n = len(lst)\n    \n    # If the list is empty, return it as is\n    if n == 0:\n        return lst\n    \n    # Calculate effective rotations needed\n    k = k % n\n    \n    # Return the rotated list by slicing\n    return lst[-k:] + lst[:-k]\n\n"}
{"task_id": "Mbpp/744", "solution": "\ndef check_none(input_tuple):\n    # Iterate through each element in the tuple\n    for element in input_tuple:\n        # Check if the current element is None\n        if element is None:\n            return True  # Return True if None is found\n    return False  # Return False if no None is found\n"}
{"task_id": "Mbpp/745", "solution": "\ndef divisible_by_digits(startnum, endnum):\n    # Create an empty list to store the results\n    result = []\n    \n    # Iterate through each number in the specified range\n    for number in range(startnum, endnum + 1):\n        # Convert the number to string to access its digits\n        str_number = str(number)\n        divisible = True  # Assume the number is divisible by its digits\n        \n        # Check each digit in the number\n        for digit in str_number:\n            if digit == '0':  # If the digit is zero, skip this number\n                divisible = False\n                break\n            if number % int(digit) != 0:  # Check divisibility\n                divisible = False\n                break\n        \n        # If the number is divisible by all its digits, add it to the result\n        if divisible:\n            result.append(number)\n    \n    # Return the list of valid numbers\n    return result\n"}
{"task_id": "Mbpp/748", "solution": "\ndef capital_words_spaces(input_string: str) -> str:\n    # Check if the input string is empty\n    if not input_string:\n        return \"\"\n    \n    # Initialize an empty result string\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for i in range(len(input_string)):\n        # If the character is uppercase and it's not the first character\n        if input_string[i].isupper() and i > 0:\n            # Append a space before the uppercase character\n            result += \" \"\n        # Append the current character to the result\n        result += input_string[i]\n    \n    return result\n\n# The function is declared last as per the instructions.\n"}
{"task_id": "Mbpp/749", "solution": "\ndef sort_numeric_strings(input_list):\n    # Create an empty list to hold the converted integers\n    integer_list = []\n    \n    # Convert each string in the input list to an integer\n    for num_str in input_list:\n        integer_list.append(int(num_str))\n    \n    # Sort the list of integers in ascending order\n    integer_list.sort()\n    \n    # Return the sorted list\n    return integer_list\n\n# The function is declared last as per the instructions\n"}
{"task_id": "Mbpp/75", "solution": "\ndef find_tuples(tuples_list, k):\n    # Create an empty list to store the result\n    result = []\n    \n    # Iterate through each tuple in the provided list\n    for tup in tuples_list:\n        # Assume all elements are divisible by k\n        all_divisible = True\n        \n        # Check each element in the tuple\n        for element in tup:\n            # If any element is not divisible by k, set the flag to False\n            if element % k != 0:\n                all_divisible = False\n                break\n        \n        # If all elements are divisible, add the tuple to the result list\n        if all_divisible:\n            result.append(tup)\n    \n    # Return the list of tuples that have all elements divisible by k\n    return result\n"}
{"task_id": "Mbpp/750", "solution": "\ndef add_tuple(lst, tup):\n    # Convert the tuple to a list\n    tup_as_list = list(tup)\n    # Extend the original list with the elements of the tuple\n    lst.extend(tup_as_list)\n    # Return the updated list\n    return lst\n"}
{"task_id": "Mbpp/751", "solution": "\ndef check_min_heap(array):\n    # Iterate through each element in the array up to the last parent node\n    for i in range(len(array) // 2):\n        # Calculate the indices of the left and right children\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the left child exists and if the parent is greater than the left child\n        if left_child_index < len(array):\n            if array[i] > array[left_child_index]:\n                return False\n        \n        # Check if the right child exists and if the parent is greater than the right child\n        if right_child_index < len(array):\n            if array[i] > array[right_child_index]:\n                return False\n    \n    # If all parent-child relationships are valid, return True\n    return True\n"}
{"task_id": "Mbpp/752", "solution": "\ndef jacobsthal_num(n):\n    # Base cases for the first two Jacobsthal numbers\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Initialize the first two Jacobsthal numbers\n    previous = 0  # Jacobsthal(0)\n    current = 1   # Jacobsthal(1)\n    \n    # Iteratively calculate the Jacobsthal numbers up to n\n    for i in range(2, n + 1):\n        next_value = previous + 2 * current  # Jacobsthal(n) = Jacobsthal(n-2) + 2 * Jacobsthal(n-1)\n        previous = current  # Move to the next number in the sequence\n        current = next_value  # Update current to the newly calculated value\n    \n    return current  # Return the nth Jacobsthal number\n"}
{"task_id": "Mbpp/753", "solution": "\ndef min_k(records, k):\n    # Step 1: Sort the records based on the score (second element of each tuple)\n    sorted_records = sorted(records, key=lambda x: x[1])\n    \n    # Step 2: Return the first k records from the sorted list\n    return sorted_records[:k]\n\n# The function min_k is declared last as per the instructions.\n"}
{"task_id": "Mbpp/754", "solution": "\ndef extract_index_list(l1, l2, l3):\n    # Create an empty list to store common elements\n    common_elements = []\n    \n    # Iterate through the indices of the lists\n    for index in range(len(l1)):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[index] == l2[index] and l2[index] == l3[index]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[index])\n    \n    # Return the list of common elements\n    return common_elements\n"}
{"task_id": "Mbpp/755", "solution": "\ndef second_smallest(numbers):\n    # Initialize the smallest and second smallest to infinity\n    smallest = float('inf')\n    second_smallest = float('inf')\n    \n    # Loop through each number in the list\n    for number in numbers:\n        # Update smallest and second smallest accordingly\n        if number < smallest:\n            second_smallest = smallest\n            smallest = number\n        elif smallest < number < second_smallest:\n            second_smallest = number\n    \n    # Return the second smallest number found\n    return second_smallest\n"}
{"task_id": "Mbpp/757", "solution": "\ndef count_reverse_pairs(string_list):\n    # Create a set to keep track of seen strings\n    seen = set()\n    # Initialize the count of reverse pairs\n    count = 0\n    \n    # Iterate through each string in the provided list\n    for string in string_list:\n        # Reverse the current string\n        reverse_string = string[::-1]\n        # Check if the reversed string is already in the seen set\n        if reverse_string in seen:\n            # If it is, we found a reverse pair, increment the count\n            count += 1\n        # Add the current string to the seen set\n        seen.add(string)\n    \n    # Return the total count of reverse pairs found\n    return count\n"}
{"task_id": "Mbpp/758", "solution": "\ndef unique_sublists(input_list):\n    # Create an empty dictionary to store counts of each unique sublist\n    count_dict = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in input_list:\n        # Convert the sublist to a tuple\n        sublist_tuple = tuple(sublist)\n        \n        # If the tuple is already in the dictionary, increment its count\n        if sublist_tuple in count_dict:\n            count_dict[sublist_tuple] += 1\n        # Otherwise, add it to the dictionary with a count of 1\n        else:\n            count_dict[sublist_tuple] = 1\n            \n    # Return the dictionary containing the counts of each unique sublist\n    return count_dict\n"}
{"task_id": "Mbpp/759", "solution": "\ndef is_decimal(s: str) -> bool:\n    # Check if there is exactly one decimal point\n    if s.count('.') == 1:\n        # Split the string into integer and decimal parts\n        integer_part, decimal_part = s.split('.')\n        # Check if the integer part is not empty and the decimal part has exactly 2 digits\n        if integer_part != '' and len(decimal_part) == 2:\n            return True\n    return False\n"}
{"task_id": "Mbpp/760", "solution": "\ndef unique_Element(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return False  # An empty list does not contain a distinct element\n    first_element = numbers[0]  # Store the first element to compare with\n    # Iterate through each element in the list\n    for element in numbers:\n        # If any element is not equal to the first element, return False\n        if element != first_element:\n            return False\n    # If all elements are the same, return True\n    return True\n"}
{"task_id": "Mbpp/762", "solution": "\ndef has_30_days(month):\n    # List of months that have 30 days\n    months_with_30_days = [4, 6, 9, 11]\n    # Check if the given month is in the list\n    return month in months_with_30_days\n\ndef check_monthnumber_number(month: int) -> bool:\n    # Call the helper function to check for 30 days\n    return has_30_days(month)\n"}
{"task_id": "Mbpp/763", "solution": "\ndef find_min_diff(arr, _):\n    # Step 1: Sort the array\n    sorted_arr = sorted(arr)\n    \n    # Step 2: Initialize the minimum difference to a large value\n    min_diff = float('inf')\n    \n    # Step 3: Iterate through the sorted array to find the minimum difference\n    for i in range(len(sorted_arr) - 1):\n        # Calculate the difference between consecutive elements\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        \n        # Update min_diff if the current difference is smaller\n        if diff < min_diff:\n            min_diff = diff\n            \n    # Step 4: Return the minimum difference found\n    return min_diff\n"}
{"task_id": "Mbpp/764", "solution": "\ndef is_digit(char):\n    # Check if the character is a digit\n    return '0' <= char <= '9'\n\ndef number_ctr(input_string: str) -> int:\n    # Initialize a counter for digits\n    count = 0\n    # Iterate through each character in the input string\n    for char in input_string:\n        # If the character is a digit, increment the count\n        if is_digit(char):\n            count += 1\n    # Return the total count of digits found\n    return count\n"}
{"task_id": "Mbpp/765", "solution": "\ndef is_power_of_two(x):\n    # Check if x is a power of two\n    while x > 1:\n        if x % 2 != 0:  # If x is odd and greater than 1, it's not a power of two\n            return False\n        x = x // 2  # Divide x by 2\n    return True  # If we reduce x to 1, it is a power of two\n\ndef is_polite(n: int) -> int:\n    count = 0  # Counter for polite numbers\n    current_number = 1  # Start checking from 1\n    while count < n:  # Continue until we find the N'th polite number\n        if not is_power_of_two(current_number):  # Check if current_number is not a power of two\n            count += 1  # Increment count of polite numbers\n        current_number += 1  # Move to the next number\n    return current_number - 1  # Return the last found polite number\n"}
{"task_id": "Mbpp/766", "solution": "\ndef pair_wise(input_list):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through the list up to the second-to-last item\n    for i in range(len(input_list) - 1):\n        # Create a tuple of the current item and the next item\n        pair = (input_list[i], input_list[i + 1])\n        # Append the tuple to the result list\n        result.append(pair)\n    \n    # Return the list of pairs\n    return result\n"}
{"task_id": "Mbpp/767", "solution": "\ndef get_pairs_count(numbers, target_sum):\n    count_map = {}\n    pair_count = 0\n\n    # Count occurrences of each number\n    for number in numbers:\n        if number in count_map:\n            count_map[number] += 1\n        else:\n            count_map[number] = 1\n\n    # Count pairs\n    for number in numbers:\n        complement = target_sum - number\n        if complement in count_map:\n            pair_count += count_map[complement]\n            # If the complement is the same as the number, we need to adjust the count\n            if complement == number:\n                pair_count -= 1\n\n    # Each pair is counted twice, so divide by 2\n    return pair_count // 2\n"}
{"task_id": "Mbpp/769", "solution": "\ndef Diff(list1, list2):\n    # Create an empty result list to store the difference\n    result = []\n    \n    # Create a set for faster lookup of elements in list2\n    set_list2 = set(list2)\n    \n    # First, collect elements from list1 that are not in list2\n    for element in list1:\n        if element not in set_list2:\n            result.append(element)\n    \n    # Then, append the elements from list1 that are in list2\n    for element in list1:\n        if element in set_list2 and element not in result:\n            result.append(element)\n    \n    # Return the result list containing the difference\n    return result\n"}
{"task_id": "Mbpp/77", "solution": "\n# Function to check if a number is divisible by 11\ndef is_Diff(number):\n    # Check if the number modulo 11 is zero\n    if number % 11 == 0:\n        return True  # The number is divisible by 11\n    else:\n        return False  # The number is not divisible by 11\n"}
{"task_id": "Mbpp/770", "solution": "\ndef odd_num_sum(n):\n    total_sum = 0  # Initialize the total sum to 0\n    for i in range(1, n + 1):  # Loop through the first n odd numbers\n        odd_number = 2 * i - 1  # Calculate the i-th odd number\n        fourth_power = odd_number ** 4  # Calculate the fourth power of the odd number\n        total_sum += fourth_power  # Add the fourth power to the total sum\n    return total_sum  # Return the total sum of fourth powers\n"}
{"task_id": "Mbpp/771", "solution": "\ndef is_opening_bracket(char):\n    return char in \"({[\"\n\ndef is_closing_bracket(char):\n    return char in \")}]\"\n\ndef matches(opening, closing):\n    return (opening == '(' and closing == ')') or \\\n           (opening == '{' and closing == '}') or \\\n           (opening == '[' and closing == ']')\n\ndef check_expression(expression: str) -> bool:\n    # Create an empty stack to keep track of opening brackets\n    stack = []\n    \n    # Iterate through each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if is_opening_bracket(char):\n            stack.append(char)\n        # If the character is a closing bracket\n        elif is_closing_bracket(char):\n            # If the stack is empty, it means there's no matching opening bracket\n            if not stack:\n                return False\n            # Pop the top of the stack\n            top = stack.pop()\n            # Check if the popped bracket matches the current closing bracket\n            if not matches(top, char):\n                return False\n    \n    # If the stack is empty, all brackets were matched; otherwise, they were not\n    return len(stack) == 0\n"}
{"task_id": "Mbpp/772", "solution": "\ndef remove_length(input_string: str, k: int) -> str:\n    # Split the input string into individual words\n    words = input_string.split()\n    \n    # Create a list to hold words that do not have length k\n    filtered_words = []\n    \n    # Iterate through each word in the list of words\n    for word in words:\n        # If the length of the word is not equal to k, add it to the filtered list\n        if len(word) != k:\n            filtered_words.append(word)\n    \n    # Join the filtered words into a single string with spaces\n    result = ' '.join(filtered_words)\n    \n    # Return the resulting string\n    return result\n"}
{"task_id": "Mbpp/773", "solution": "\ndef occurance_substring(main_string: str, substring: str):\n    # Find the starting index of the substring in the main string\n    index = main_string.find(substring)\n    \n    # If the substring is not found, return None\n    if index == -1:\n        return None\n    \n    # Calculate the ending index of the substring\n    end_index = index + len(substring)\n    \n    # Return the substring along with its starting and ending indices\n    return (substring, index, end_index)\n"}
{"task_id": "Mbpp/775", "solution": "\ndef is_odd(num):\n    # Helper function to check if a number is odd\n    return num % 2 != 0\n\ndef odd_position(lst):\n    # Iterate through the list starting from index 1 to the end with a step of 2\n    for index in range(1, len(lst), 2):\n        # Check if the number at the current odd index is odd\n        if not is_odd(lst[index]):\n            return False  # Return False if any number at an odd index is not odd\n    return True  # Return True if all numbers at odd indices are odd\n"}
{"task_id": "Mbpp/777", "solution": "\ndef find_sum(lst):\n    unique_elements = set(lst)  # Create a set of unique elements\n    total_sum = sum(unique_elements)  # Sum all unique elements\n    return total_sum\n"}
{"task_id": "Mbpp/778", "solution": "\ndef pack_consecutive_duplicates(input_list):\n    # Check if the input list is empty\n    if not input_list:\n        return []\n    \n    # Initialize the result list and the current group\n    result = []\n    current_group = []\n    \n    # Iterate through each element in the input list\n    for element in input_list:\n        # If current_group is empty or the element is the same as the last one in current_group\n        if not current_group or element == current_group[-1]:\n            current_group.append(element)  # Add element to current group\n        else:\n            result.append(current_group)  # Add the current group to the result\n            current_group = [element]  # Start a new group with the current element\n    \n    # If there are any remaining elements in current_group, add it to the result\n    if current_group:\n        result.append(current_group)\n    \n    return result  # Return the final result\n"}
{"task_id": "Mbpp/780", "solution": "\ndef find_combinations(tuple_list):\n    results = []  # Step 1: Create an empty list to store results\n    for i in range(len(tuple_list)):  # Step 2: Iterate through each tuple i\n        for j in range(len(tuple_list)):  # Step 3: Iterate through each tuple j\n            # Step 4: Create a new tuple with the correct sums\n            new_tuple = (tuple_list[i][0] + tuple_list[j][1], tuple_list[i][1] + tuple_list[j][0])\n            results.append(new_tuple)  # Step 5: Add the new tuple to the results list\n    # Step 6: Remove duplicates and sort the results\n    unique_results = list(set(results))\n    unique_results.sort()  # Sort the results to match expected output order\n    return unique_results  # Return the sorted list of unique results\n"}
{"task_id": "Mbpp/781", "solution": "\ndef is_even(num):\n    # Helper function to check if a number is even\n    return num % 2 == 0\n\ndef count_divisors(n):\n    # Initialize the count of divisors\n    count = 0\n    # Iterate through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            count += 1  # Increment the count for each divisor\n    # Return True if the count of divisors is even, otherwise return False\n    return is_even(count)\n\n# The main function is declared last as per the instructions\n"}
{"task_id": "Mbpp/782", "solution": "\ndef odd_length_sum(arr):\n    total_sum = 0  # Initialize total sum to 0\n    n = len(arr)  # Get the length of the array\n    # Iterate through all possible starting points of subarrays\n    for start in range(n):\n        current_sum = 0  # Initialize current sum for the subarray\n        # Extend the subarray from the starting point\n        for end in range(start, n):\n            current_sum += arr[end]  # Add the current element to the current sum\n            # Check if the length of the subarray is odd\n            if (end - start + 1) % 2 == 1:\n                total_sum += current_sum  # Add the current sum to the total sum\n    return total_sum  # Return the total sum of all odd length subarrays\n"}
{"task_id": "Mbpp/784", "solution": "\ndef mul_even_odd(numbers):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list of numbers\n    for number in numbers:\n        # Check if the number is even\n        if number % 2 == 0 and first_even is None:\n            first_even = number  # Store the first even number\n        # Check if the number is odd\n        if number % 2 != 0 and first_odd is None:\n            first_odd = number  # Store the first odd number\n        \n        # If both even and odd numbers have been found, return their product\n        if first_even is not None and first_odd is not None:\n            return first_even * first_odd\n    \n    # If we finish the loop without finding both, return 0\n    return 0\n"}
{"task_id": "Mbpp/785", "solution": "\ndef convert_to_tuple(string):\n    # Remove the parentheses from the string\n    cleaned_string = string[1:-1]\n    # Split the string by commas to get individual number strings\n    number_strings = cleaned_string.split(', ')\n    # Convert each number string to an integer\n    integer_tuple = tuple(int(num) for num in number_strings)\n    return integer_tuple\n\ndef tuple_str_int(tuple_string: str) -> tuple:\n    return convert_to_tuple(tuple_string)\n"}
{"task_id": "Mbpp/786", "solution": "\ndef right_insertion(sorted_list, value):\n    # Iterate through the sorted list\n    for index in range(len(sorted_list)):\n        # If we reach the end of the list, return the index\n        if index == len(sorted_list):\n            return index\n        # If the current element is greater than the value, return the index\n        if sorted_list[index] > value:\n            return index\n    # If no greater element is found, return the length of the list\n    return len(sorted_list)\n"}
{"task_id": "Mbpp/787", "solution": "\ndef text_match_three(input_string: str) -> bool:\n    # Check if the substring \"abbb\" is present in the input string\n    if \"abbb\" in input_string:\n        return True  # Return True if the substring is found\n    else:\n        return False  # Return False if the substring is not found\n"}
{"task_id": "Mbpp/788", "solution": "\ndef new_tuple(string_list, single_string):\n    # Create a new tuple from the list and the single string\n    result = tuple(string_list) + (single_string,)\n    # Return the new tuple\n    return result\n"}
{"task_id": "Mbpp/79", "solution": "\ndef word_len(word: str) -> bool:\n    # Calculate the length of the word\n    length = len(word)\n    # Check if the length is odd\n    if length % 2 == 1:\n        return True  # Length is odd\n    else:\n        return False  # Length is even\n"}
{"task_id": "Mbpp/790", "solution": "\ndef even_position(numbers):\n    # Iterate through the list using even indices\n    for index in range(0, len(numbers), 2):\n        # Check if the number at the current even index is odd\n        if numbers[index] % 2 != 0:\n            return False  # Return False if an odd number is found\n    return True  # Return True if all even-indexed numbers are even\n"}
{"task_id": "Mbpp/791", "solution": "\ndef remove_nested(input_tuple):\n    # Create an empty list to hold non-tuple elements\n    non_tuple_elements = []\n    \n    # Iterate through each element in the input tuple\n    for element in input_tuple:\n        # Check if the element is not a tuple\n        if not isinstance(element, tuple):\n            # If it's not a tuple, add it to the list\n            non_tuple_elements.append(element)\n    \n    # Convert the list of non-tuple elements to a tuple\n    return tuple(non_tuple_elements)\n\n# The function is declared last as per the instructions\n"}
{"task_id": "Mbpp/792", "solution": "\ndef count_list(lists):\n    # Use the built-in len() function to count the number of lists\n    return len(lists)\n\n# The function count_list is declared last as per the instructions.\n"}
{"task_id": "Mbpp/793", "solution": "\ndef last(array, target):\n    # Initialize left and right pointers for binary search\n    left = 0\n    right = len(array) - 1\n    last_index = -1  # This will hold the last index of the target\n\n    # Perform binary search\n    while left <= right:\n        mid = (left + right) // 2  # Find the middle index\n        if array[mid] == target:\n            last_index = mid  # Update last_index if target is found\n            left = mid + 1  # Continue searching to the right\n        elif array[mid] < target:\n            left = mid + 1  # Move left pointer to the right\n        else:\n            right = mid - 1  # Move right pointer to the left\n\n    return last_index  # Return the last index found, or -1 if not found\n"}
{"task_id": "Mbpp/794", "solution": "\ndef text_starta_endb(s: str) -> bool:\n    # Check if the string is at least 2 characters long\n    if len(s) < 2:\n        return False\n    # Check if the first character is 'a' and the last character is 'b'\n    if s[0] == 'a' and s[-1] == 'b':\n        return True\n    return False\n"}
{"task_id": "Mbpp/796", "solution": "\ndef return_sum(dictionary):\n    # Initialize total to 0\n    total = 0\n    # Iterate through each value in the dictionary\n    for value in dictionary.values():\n        # Add the value to total\n        total += value\n    # Return the total sum of values\n    return total\n"}
{"task_id": "Mbpp/797", "solution": "\ndef sum_in_range(l: int, r: int) -> int:\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate through each number in the range from l to r\n    for number in range(l, r + 1):\n        # Check if the number is odd\n        if number % 2 != 0:\n            # Add the odd number to the total sum\n            total_sum += number\n            \n    # Return the total sum of odd numbers\n    return total_sum\n"}
{"task_id": "Mbpp/798", "solution": "\ndef _sum(array):\n    # Initialize a variable to hold the total sum\n    total_sum = 0\n    \n    # Iterate through each number in the array\n    for number in array:\n        # Add the current number to the total sum\n        total_sum += number\n    \n    # Return the total sum\n    return total_sum\n"}
{"task_id": "Mbpp/799", "solution": "\ndef left_rotate(n: int, d: int) -> int:\n    # Ensure d is within the range of 0 to 31\n    d = d % 32\n    # Shift n left by d bits\n    left_shifted = n << d\n    # Shift n right by (32 - d) bits to get the bits that overflow\n    right_shifted = n >> (32 - d)\n    # Combine both results using bitwise OR\n    result = left_shifted | right_shifted\n    # Return the result masked to 32 bits\n    return result & 0xFFFFFFFF\n"}
{"task_id": "Mbpp/8", "solution": "\ndef square_nums(input_list):\n    # Create an empty list to store the results\n    result = []\n    # Iterate through each number in the input list\n    for number in input_list:\n        # Calculate the square of the number\n        squared = number * number\n        # Append the squared number to the result list\n        result.append(squared)\n    # Return the list of squared numbers\n    return result\n"}
{"task_id": "Mbpp/80", "solution": "\ndef tetrahedral_number(n):\n    # Initialize total to accumulate the tetrahedral number\n    total = 0\n    # Loop through each number from 1 to n\n    for i in range(1, n + 1):\n        # Calculate the ith triangular number\n        triangular_number = (i * (i + 1)) // 2\n        # Add the triangular number to the total\n        total += triangular_number\n    # Return the final tetrahedral number\n    return total\n"}
{"task_id": "Mbpp/800", "solution": "\ndef remove_all_spaces(input_string: str) -> str:\n    # Create an empty string to store the result\n    result = \"\"\n    # Iterate through each character in the input string\n    for char in input_string:\n        # Check if the character is not a whitespace\n        if char != ' ':\n            # Append the non-whitespace character to the result\n            result += char\n    # Return the result string without whitespaces\n    return result\n"}
{"task_id": "Mbpp/801", "solution": "\ndef test_three_equal(a, b, c):\n    # Check if all three numbers are equal\n    if a == b and b == c:\n        return 3\n    # Check if any two numbers are equal\n    elif a == b or b == c or a == c:\n        return 2\n    # If none are equal\n    else:\n        return 0\n"}
{"task_id": "Mbpp/803", "solution": "\ndef is_perfect_square(n: int) -> bool:\n    # Check if the number is negative\n    if n < 0:\n        return False  # Negative numbers cannot be perfect squares\n    \n    # Calculate the integer square root of n\n    root = int(n**0.5)  # This gives us the largest integer whose square is <= n\n    \n    # Check if squaring the root gives us back n\n    return root * root == n  # Return True if it is a perfect square, otherwise False\n"}
{"task_id": "Mbpp/804", "solution": "\ndef is_product_even(numbers):\n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the current number is even\n        if number % 2 == 0:\n            # If an even number is found, return True\n            return True\n    # If no even number is found, return False\n    return False\n"}
{"task_id": "Mbpp/805", "solution": "\ndef max_sum_list(lists):\n    # Initialize max_sum to a very small number\n    max_sum = float('-inf')\n    # Initialize max_list to None\n    max_list = None\n    \n    # Iterate through each inner list in the input lists\n    for inner_list in lists:\n        # Calculate the sum of the current inner list\n        current_sum = sum(inner_list)\n        # If the current sum is greater than the max_sum found so far\n        if current_sum > max_sum:\n            # Update max_sum to the current sum\n            max_sum = current_sum\n            # Update max_list to the current inner list\n            max_list = inner_list\n    \n    # Return the inner list with the highest sum\n    return max_list\n"}
{"task_id": "Mbpp/806", "solution": "\ndef max_run_uppercase(s: str) -> int:\n    # Initialize variables to track the maximum length and current length of uppercase runs\n    max_length = 0\n    current_length = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Check if the character is uppercase\n        if char.isupper():\n            current_length += 1  # Increment the current length for consecutive uppercase\n        else:\n            # If we hit a non-uppercase character, check if we need to update max_length\n            if current_length > max_length:\n                max_length = current_length\n            current_length = 0  # Reset current length for the next run\n    \n    # Final check in case the string ends with an uppercase run\n    if current_length > max_length:\n        max_length = current_length\n    \n    return max_length  # Return the maximum length found\n"}
{"task_id": "Mbpp/807", "solution": "\ndef is_odd(number):\n    # Check if the number is odd\n    return number % 2 != 0\n\ndef first_odd(numbers):\n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the current number is odd\n        if is_odd(number):\n            # Return the first odd number found\n            return number\n    # If no odd number is found, return None\n    return None\n"}
{"task_id": "Mbpp/808", "solution": "\ndef check_K(tup, k):\n    # Iterate through each element in the tuple\n    for element in tup:\n        # Check if the current element is equal to k\n        if element == k:\n            return True  # Return True if k is found\n    return False  # Return False if k is not found in the tuple\n"}
{"task_id": "Mbpp/809", "solution": "\ndef check_smaller(tuple1, tuple2):\n    # Iterate through the indices of the tuples\n    for i in range(len(tuple1)):\n        # Check if the element in tuple2 is not smaller than the corresponding element in tuple1\n        if tuple2[i] >= tuple1[i]:\n            return False  # Return False if any element in tuple2 is not smaller\n    return True  # Return True if all elements in tuple2 are smaller\n\n# The function can be called with two tuples as arguments\n"}
{"task_id": "Mbpp/82", "solution": "\ndef volume_sphere(radius):\n    # Define the value of pi\n    pi = 3.141592653589793\n    # Calculate the volume using the formula for the volume of a sphere\n    volume = (4/3) * pi * (radius ** 3)\n    # Return the calculated volume\n    return volume\n"}
{"task_id": "Mbpp/84", "solution": "\ndef sequence(n):\n    # Base cases for the first two terms of the Newman-Conway sequence\n    if n == 1 or n == 2:\n        return 1\n    \n    # Create a list to store the sequence values\n    dp = [0] * (n + 1)\n    dp[1] = 1  # T(1) = 1\n    dp[2] = 1  # T(2) = 1\n    \n    # Compute the sequence values from T(3) to T(n)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - 1]  # Correctly applying the formula\n    \n    # Return the nth term of the sequence\n    return dp[n]\n\n\ndef sequence(n):\n    # Base cases for the first two terms of the Newman-Conway sequence\n    if n == 1 or n == 2:\n        return 1\n    \n    # Create a list to store the sequence values\n    dp = [0] * (n + 1)\n    dp[1] = 1  # T(1) = 1\n    dp[2] = 1  # T(2) = 1\n    \n    # Compute the sequence values from T(3) to T(n)\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - 1]  # Correctly applying the formula\n    \n    # Return the nth term of the sequence\n    return dp[n]\n"}
{"task_id": "Mbpp/85", "solution": "\ndef surfacearea_sphere(radius):\n    # Define the value of pi\n    pi = 3.141592653589793\n    # Calculate the surface area using the formula 4 * pi * r^2\n    surface_area = 4 * pi * (radius * radius)\n    # Return the calculated surface area\n    return surface_area\n"}
{"task_id": "Mbpp/86", "solution": "\ndef centered_hexagonal_number(n):\n    # Check if n is less than 1, return 0 as a base case\n    if n < 1:\n        return 0\n    # Calculate the nth centered hexagonal number using the formula\n    return 3 * n * (n - 1) + 1  # H(n) = 3n(n - 1) + 1\n"}
{"task_id": "Mbpp/87", "solution": "\ndef merge_dictionaries_three(dict1, dict2, dict3):\n    # Create an empty dictionary to hold the merged result\n    merged_dict = {}\n    \n    # Update the merged_dict with the first dictionary\n    merged_dict.update(dict1)\n    \n    # Update the merged_dict with the second dictionary\n    merged_dict.update(dict2)\n    \n    # Update the merged_dict with the third dictionary\n    merged_dict.update(dict3)\n    \n    # Return the merged dictionary\n    return merged_dict\n"}
{"task_id": "Mbpp/88", "solution": "\ndef freq_count(input_list):\n    # Create an empty dictionary to store the frequency of each element\n    frequency = {}\n    \n    # Iterate through each number in the input list\n    for number in input_list:\n        # If the number is already in the dictionary, increment its count\n        if number in frequency:\n            frequency[number] += 1\n        # If the number is not in the dictionary, add it with a count of 1\n        else:\n            frequency[number] = 1\n            \n    # Return the dictionary containing the frequency of each element\n    return frequency\n"}
{"task_id": "Mbpp/89", "solution": "\n# Define a function to find the closest smaller number than n\ndef closest_num(n: int) -> int:\n    # The closest smaller number than n is simply n - 1\n    return n - 1\n"}
{"task_id": "Mbpp/9", "solution": "\ndef find_Rotations(s: str) -> int:\n    # Store the original string to compare with\n    original_string = s\n    # Get the length of the string\n    length = len(s)\n    \n    # Iterate through possible rotations\n    for i in range(1, length + 1):\n        # Rotate the string by moving the first character to the end\n        s = s[1:] + s[0]\n        # Check if the rotated string matches the original\n        if s == original_string:\n            return i  # Return the number of rotations needed\n    \n    return length  # This case should not happen as per problem statement\n"}
{"task_id": "Mbpp/90", "solution": "\ndef len_log(words):\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Check if the length of the current word is greater than max_length\n        if len(word) > max_length:\n            # Update max_length to the length of the current word\n            max_length = len(word)\n    \n    # Return the maximum length found\n    return max_length\n"}
{"task_id": "Mbpp/91", "solution": "\ndef find_substring(string_list, substring):\n    # Iterate through each string in the provided list\n    for string in string_list:\n        # Check if the substring is present in the current string\n        if substring in string:\n            return True  # Return True if found\n    return False  # Return False if not found in any string\n"}
{"task_id": "Mbpp/92", "solution": "\ndef is_undulating(n: int) -> bool:\n    # Convert the number to a string to access each digit\n    str_n = str(n)\n    \n    # Initialize a set to track unique digits\n    unique_digits = set()\n    \n    # Loop through each digit in the string representation\n    for i in range(len(str_n)):\n        # If the current digit is different from the previous one\n        if i == 0 or str_n[i] != str_n[i - 1]:\n            unique_digits.add(str_n[i])  # Add to the set of unique digits\n        \n        # If we have more than 2 unique digits, it's not undulating\n        if len(unique_digits) > 2:\n            return False\n    \n    # If we have exactly 2 unique digits, it is undulating\n    return len(unique_digits) == 2\n"}
{"task_id": "Mbpp/93", "solution": "\ndef power(a: int, b: int) -> int:\n    # Initialize the result to 1\n    result = 1\n    # Loop b times to multiply a with itself\n    for i in range(b):\n        result *= a\n    # Return the final result\n    return result\n"}
{"task_id": "Mbpp/94", "solution": "\ndef index_minimum(tuples):\n    # Initialize min_value to a very large number\n    min_value = float('inf')\n    # Initialize min_name to an empty string\n    min_name = ''\n    \n    # Iterate through each tuple in the list\n    for name, score in tuples:\n        # If the current score is less than the minimum found so far\n        if score < min_value:\n            # Update the minimum score and corresponding name\n            min_value = score\n            min_name = name\n            \n    # Return the name associated with the smallest score\n    return min_name\n"}
{"task_id": "Mbpp/95", "solution": "\ndef Find_Min_Length(lists):\n    # Initialize min_length to a large number\n    min_length = float('inf')\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in lists:\n        # Update min_length if the current sublist is shorter\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    \n    # Return the smallest length found\n    return min_length\n"}
{"task_id": "Mbpp/96", "solution": "\ndef count_divisors(n):\n    # Initialize a counter for the number of divisors\n    count = 0\n    # Iterate through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Increment the count if it is a divisor\n            count += 1\n    # Return the total count of divisors\n    return count\n\ndef divisor(n: int) -> int:\n    # Call the helper function to count divisors\n    return count_divisors(n)\n"}
{"task_id": "Mbpp/97", "solution": "\ndef frequency_lists(lists):\n    # Create an empty dictionary to store frequencies\n    freq = {}\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in lists:\n        # Iterate through each element in the current sublist\n        for element in sublist:\n            # If the element is already in the dictionary, increment its count\n            if element in freq:\n                freq[element] += 1\n            # If the element is not in the dictionary, add it with a count of 1\n            else:\n                freq[element] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return freq\n"}
{"task_id": "Mbpp/98", "solution": "\ndef multiply_num(numbers):\n    # Initialize product to 1\n    product = 1\n    # Iterate through each number in the input tuple\n    for number in numbers:\n        product *= number  # Multiply each number to the product\n    # Get the length of the input tuple\n    length_of_numbers = len(numbers)\n    # Divide the product by the length of the tuple\n    result = product / length_of_numbers\n    # Return the final result\n    return result\n"}
{"task_id": "Mbpp/99", "solution": "\ndef decimal_to_binary(n: int) -> str:\n    # Check if the input number is 0\n    if n == 0:\n        return \"0\"  # The binary representation of 0 is \"0\"\n    \n    # Initialize an empty list to store the binary digits\n    binary_digits = []\n    \n    # Loop until n becomes 0\n    while n > 0:\n        remainder = n % 2  # Get the remainder when n is divided by 2\n        binary_digits.append(str(remainder))  # Store the remainder as a string\n        n = n // 2  # Update n to be the quotient of n divided by 2\n    \n    # Reverse the list of binary digits to get the correct order\n    binary_digits.reverse()\n    \n    # Join the list into a single string and return it\n    return ''.join(binary_digits)\n"}
