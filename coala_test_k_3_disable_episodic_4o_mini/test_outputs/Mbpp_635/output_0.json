{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nTests failed:\nNone",
    "code": "\ndef heapify(arr, i, heap_size):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < heap_size and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < heap_size and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # Swap\n        heapify(arr, largest, heap_size)  # Recursively heapify the affected sub-tree\n\ndef build_max_heap(arr):\n    # Build a max heap\n    for i in range(len(arr) // 2 - 1, -1, -1):\n        heapify(arr, i, len(arr))\n\ndef heap_sort(arr):\n    build_max_heap(arr)  # Step 1: Build a max heap\n    for i in range(len(arr) - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]  # Step 2: Move current root to end\n        heapify(arr, 0, i)  # Step 3: Call max heapify on the reduced heap\n    return arr  # Return the sorted array\n",
    "full_code": "\ndef heapify(arr, i, heap_size):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < heap_size and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < heap_size and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # Swap\n        heapify(arr, largest, heap_size)  # Recursively heapify the affected sub-tree\n\ndef build_max_heap(arr):\n    # Build a max heap\n    for i in range(len(arr) // 2 - 1, -1, -1):\n        heapify(arr, i, len(arr))\n\ndef heap_sort(arr):\n    build_max_heap(arr)  # Step 1: Build a max heap\n    for i in range(len(arr) - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]  # Step 2: Move current root to end\n        heapify(arr, 0, i)  # Step 3: Call max heapify on the reduced heap\n    return arr  # Return the sorted array\n",
    "reward": true,
    "program_code": "\ndef heapify(arr, i, heap_size):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < heap_size and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < heap_size and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # Swap\n        heapify(arr, largest, heap_size)  # Recursively heapify the affected sub-tree\n\ndef build_max_heap(arr):\n    # Build a max heap\n    for i in range(len(arr) // 2 - 1, -1, -1):\n        heapify(arr, i, len(arr))\n\ndef heap_sort(arr):\n    build_max_heap(arr)  # Step 1: Build a max heap\n    for i in range(len(arr) - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]  # Step 2: Move current root to end\n        heapify(arr, 0, i)  # Step 3: Call max heapify on the reduced heap\n    return arr  # Return the sorted array\n",
    "program_name": "heap_sort",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**: \n   The task is to create a function that sorts a given list of numbers in ascending order using the heap sort algorithm.\n\n2. **Conceptualize a solution first in plain English**: \n   The heap sort algorithm involves two main steps: \n   - First, we need to build a max heap from the input list. A max heap is a complete binary tree where the value of each node is greater than or equal to the values of its children.\n   - Then, we repeatedly extract the maximum element from the heap (which is the root of the heap) and place it at the end of the list, reducing the size of the heap by one each time, until the heap is empty.\n\n3. **Write a pseudocode solution**:\n   ```\n   function heap_sort(arr):\n       build_max_heap(arr)\n       for i from length(arr) - 1 down to 1:\n           swap(arr[0], arr[i])  // Move current root to end\n           heapify(arr, 0, i)     // Call max heapify on the reduced heap\n\n   function build_max_heap(arr):\n       for i from length(arr) // 2 - 1 down to 0:\n           heapify(arr, i, length(arr))\n\n   function heapify(arr, i, heap_size):\n       largest = i\n       left = 2 * i + 1\n       right = 2 * i + 2\n       if left < heap_size and arr[left] > arr[largest]:\n           largest = left\n       if right < heap_size and arr[right] > arr[largest]:\n           largest = right\n       if largest != i:\n           swap(arr[i], arr[largest])\n           heapify(arr, largest, heap_size)\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\ndef heapify(arr, i, heap_size):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < heap_size and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < heap_size and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # Swap\n        heapify(arr, largest, heap_size)  # Recursively heapify the affected sub-tree\n\ndef build_max_heap(arr):\n    # Build a max heap\n    for i in range(len(arr) // 2 - 1, -1, -1):\n        heapify(arr, i, len(arr))\n\ndef heap_sort(arr):\n    build_max_heap(arr)  # Step 1: Build a max heap\n    for i in range(len(arr) - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]  # Step 2: Move current root to end\n        heapify(arr, 0, i)  # Step 3: Call max heapify on the reduced heap\n    return arr  # Return the sorted array\n```",
    "no_parent": true,
    "dependency_used": false
}