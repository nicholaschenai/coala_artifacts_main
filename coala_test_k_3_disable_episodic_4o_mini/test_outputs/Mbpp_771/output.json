{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert check_expression(\"{()}[{}]\") == True\n\nTests failed:\nNone",
    "code": "\ndef is_opening_bracket(char):\n    return char in \"({[\"\n\ndef is_closing_bracket(char):\n    return char in \")}]\"\n\ndef matches(opening, closing):\n    return (opening == '(' and closing == ')') or \\\n           (opening == '{' and closing == '}') or \\\n           (opening == '[' and closing == ']')\n\ndef check_expression(expression: str) -> bool:\n    # Create an empty stack to keep track of opening brackets\n    stack = []\n    \n    # Iterate through each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if is_opening_bracket(char):\n            stack.append(char)\n        # If the character is a closing bracket\n        elif is_closing_bracket(char):\n            # If the stack is empty, it means there's no matching opening bracket\n            if not stack:\n                return False\n            # Pop the top of the stack\n            top = stack.pop()\n            # Check if the popped bracket matches the current closing bracket\n            if not matches(top, char):\n                return False\n    \n    # If the stack is empty, all brackets were matched; otherwise, they were not\n    return len(stack) == 0\n",
    "full_code": "\ndef is_opening_bracket(char):\n    return char in \"({[\"\n\ndef is_closing_bracket(char):\n    return char in \")}]\"\n\ndef matches(opening, closing):\n    return (opening == '(' and closing == ')') or \\\n           (opening == '{' and closing == '}') or \\\n           (opening == '[' and closing == ']')\n\ndef check_expression(expression: str) -> bool:\n    # Create an empty stack to keep track of opening brackets\n    stack = []\n    \n    # Iterate through each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if is_opening_bracket(char):\n            stack.append(char)\n        # If the character is a closing bracket\n        elif is_closing_bracket(char):\n            # If the stack is empty, it means there's no matching opening bracket\n            if not stack:\n                return False\n            # Pop the top of the stack\n            top = stack.pop()\n            # Check if the popped bracket matches the current closing bracket\n            if not matches(top, char):\n                return False\n    \n    # If the stack is empty, all brackets were matched; otherwise, they were not\n    return len(stack) == 0\n",
    "reward": true,
    "program_code": "\ndef is_opening_bracket(char):\n    return char in \"({[\"\n\ndef is_closing_bracket(char):\n    return char in \")}]\"\n\ndef matches(opening, closing):\n    return (opening == '(' and closing == ')') or \\\n           (opening == '{' and closing == '}') or \\\n           (opening == '[' and closing == ']')\n\ndef check_expression(expression: str) -> bool:\n    # Create an empty stack to keep track of opening brackets\n    stack = []\n    \n    # Iterate through each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if is_opening_bracket(char):\n            stack.append(char)\n        # If the character is a closing bracket\n        elif is_closing_bracket(char):\n            # If the stack is empty, it means there's no matching opening bracket\n            if not stack:\n                return False\n            # Pop the top of the stack\n            top = stack.pop()\n            # Check if the popped bracket matches the current closing bracket\n            if not matches(top, char):\n                return False\n    \n    # If the stack is empty, all brackets were matched; otherwise, they were not\n    return len(stack) == 0\n",
    "program_name": "check_expression",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**: \n   We need to create a function that checks if a given string of brackets is balanced. A string is considered balanced if every opening bracket has a corresponding closing bracket in the correct order.\n\n2. **Conceptualize a solution first in plain English**: \n   To determine if the string is balanced, we can use a stack data structure. As we iterate through the string, we will push opening brackets onto the stack. When we encounter a closing bracket, we will check if the stack is not empty and if the top of the stack is the matching opening bracket. If both conditions are met, we pop the top of the stack. If at any point we find a mismatch or if the stack is empty when we encounter a closing bracket, the string is unbalanced. At the end of the iteration, if the stack is empty, the string is balanced; otherwise, it is not.\n\n3. **Write a pseudocode solution**:\n   ```\n   function check_expression(expression):\n       create an empty stack\n       for each character in expression:\n           if character is an opening bracket:\n               push character onto the stack\n           else if character is a closing bracket:\n               if stack is empty:\n                   return False\n               top = pop from the stack\n               if top does not match the corresponding opening bracket for the closing bracket:\n                   return False\n       return True if stack is empty, else return False\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\ndef is_opening_bracket(char):\n    return char in \"({[\"\n\ndef is_closing_bracket(char):\n    return char in \")}]\"\n\ndef matches(opening, closing):\n    return (opening == '(' and closing == ')') or \\\n           (opening == '{' and closing == '}') or \\\n           (opening == '[' and closing == ']')\n\ndef check_expression(expression: str) -> bool:\n    # Create an empty stack to keep track of opening brackets\n    stack = []\n    \n    # Iterate through each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if is_opening_bracket(char):\n            stack.append(char)\n        # If the character is a closing bracket\n        elif is_closing_bracket(char):\n            # If the stack is empty, it means there's no matching opening bracket\n            if not stack:\n                return False\n            # Pop the top of the stack\n            top = stack.pop()\n            # Check if the popped bracket matches the current closing bracket\n            if not matches(top, char):\n                return False\n    \n    # If the stack is empty, all brackets were matched; otherwise, they were not\n    return len(stack) == 0\n```",
    "no_parent": true,
    "dependency_used": false
}