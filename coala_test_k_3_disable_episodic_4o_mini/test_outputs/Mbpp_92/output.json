{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert is_undulating(1212121) == True\n\nTests failed:\nNone",
    "code": "\ndef is_undulating(n: int) -> bool:\n    # Convert the number to a string to access each digit\n    str_n = str(n)\n    \n    # Initialize a set to track unique digits\n    unique_digits = set()\n    \n    # Loop through each digit in the string representation\n    for i in range(len(str_n)):\n        # If the current digit is different from the previous one\n        if i == 0 or str_n[i] != str_n[i - 1]:\n            unique_digits.add(str_n[i])  # Add to the set of unique digits\n        \n        # If we have more than 2 unique digits, it's not undulating\n        if len(unique_digits) > 2:\n            return False\n    \n    # If we have exactly 2 unique digits, it is undulating\n    return len(unique_digits) == 2\n",
    "full_code": "\ndef is_undulating(n: int) -> bool:\n    # Convert the number to a string to access each digit\n    str_n = str(n)\n    \n    # Initialize a set to track unique digits\n    unique_digits = set()\n    \n    # Loop through each digit in the string representation\n    for i in range(len(str_n)):\n        # If the current digit is different from the previous one\n        if i == 0 or str_n[i] != str_n[i - 1]:\n            unique_digits.add(str_n[i])  # Add to the set of unique digits\n        \n        # If we have more than 2 unique digits, it's not undulating\n        if len(unique_digits) > 2:\n            return False\n    \n    # If we have exactly 2 unique digits, it is undulating\n    return len(unique_digits) == 2\n",
    "reward": true,
    "program_code": "\ndef is_undulating(n: int) -> bool:\n    # Convert the number to a string to access each digit\n    str_n = str(n)\n    \n    # Initialize a set to track unique digits\n    unique_digits = set()\n    \n    # Loop through each digit in the string representation\n    for i in range(len(str_n)):\n        # If the current digit is different from the previous one\n        if i == 0 or str_n[i] != str_n[i - 1]:\n            unique_digits.add(str_n[i])  # Add to the set of unique digits\n        \n        # If we have more than 2 unique digits, it's not undulating\n        if len(unique_digits) > 2:\n            return False\n    \n    # If we have exactly 2 unique digits, it is undulating\n    return len(unique_digits) == 2\n",
    "program_name": "is_undulating",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English**: \n   The task is to create a function that checks if a given number is \"undulating.\" A number is considered undulating if its digits alternate between two different values. For example, the number 1212121 is undulating because it alternates between 1 and 2.\n\n2. **Conceptualize a solution first in plain English**: \n   To determine if a number is undulating, we can convert the number to a string to easily access each digit. We will then check if the digits alternate between two distinct values. This can be done by comparing each digit with the one before it and ensuring that it only switches between two different digits.\n\n3. **Write a pseudocode solution**:\n   - Convert the number to a string.\n   - Initialize a set to keep track of the unique digits.\n   - Loop through each digit in the string:\n     - If the digit is different from the previous digit, add it to the set.\n     - If the size of the set exceeds 2, return False (not undulating).\n   - If the loop completes and the set size is 2, return True (it is undulating).\n\n4. **Output the final Python 3 solution with your solution steps in comments**:\n```python\ndef is_undulating(n: int) -> bool:\n    # Convert the number to a string to access each digit\n    str_n = str(n)\n    \n    # Initialize a set to track unique digits\n    unique_digits = set()\n    \n    # Loop through each digit in the string representation\n    for i in range(len(str_n)):\n        # If the current digit is different from the previous one\n        if i == 0 or str_n[i] != str_n[i - 1]:\n            unique_digits.add(str_n[i])  # Add to the set of unique digits\n        \n        # If we have more than 2 unique digits, it's not undulating\n        if len(unique_digits) > 2:\n            return False\n    \n    # If we have exactly 2 unique digits, it is undulating\n    return len(unique_digits) == 2\n```",
    "no_parent": true,
    "dependency_used": false
}