{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n\nTests failed:\nNone",
    "code": "\ndef maxAverageOfPath(matrix):\n    n = len(matrix)  # Get the size of the matrix\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array for dynamic programming\n\n    dp[0][0] = matrix[0][0]  # Starting point\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # The maximum sum is in dp[n-1][n-1]\n    max_sum = dp[n - 1][n - 1]\n    number_of_cells = n + n - 1  # Total cells in the path\n\n    return max_sum / number_of_cells  # Return the average\n",
    "full_code": "\ndef maxAverageOfPath(matrix):\n    n = len(matrix)  # Get the size of the matrix\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array for dynamic programming\n\n    dp[0][0] = matrix[0][0]  # Starting point\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # The maximum sum is in dp[n-1][n-1]\n    max_sum = dp[n - 1][n - 1]\n    number_of_cells = n + n - 1  # Total cells in the path\n\n    return max_sum / number_of_cells  # Return the average\n",
    "reward": true,
    "program_code": "\ndef maxAverageOfPath(matrix):\n    n = len(matrix)  # Get the size of the matrix\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array for dynamic programming\n\n    dp[0][0] = matrix[0][0]  # Starting point\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # The maximum sum is in dp[n-1][n-1]\n    max_sum = dp[n - 1][n - 1]\n    number_of_cells = n + n - 1  # Total cells in the path\n\n    return max_sum / number_of_cells  # Return the average\n",
    "program_name": "maxAverageOfPath",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n   The task is to find the maximum average cost of a path from the top-left corner to the bottom-right corner of a square matrix. The path can only move right or down, and the average is calculated by dividing the total cost of the path by the number of cells visited.\n\n2. **Conceptualize a solution first in plain English:**\n   To solve this problem, we can use dynamic programming. We will create a 2D array to store the maximum sum of costs for each cell in the matrix. Starting from the top-left corner, we will fill this array by considering the maximum sum that can be obtained from the cell above or the cell to the left. Once we reach the bottom-right corner, we can calculate the average by dividing the maximum sum by the number of cells in the path.\n\n3. **Write a pseudocode solution:**\n   ```\n   function maxAverageOfPath(matrix):\n       n = length of matrix\n       create a 2D array dp of size n*n initialized to 0\n       \n       dp[0][0] = matrix[0][0]  // starting point\n       \n       // Fill the first row\n       for j from 1 to n-1:\n           dp[0][j] = dp[0][j-1] + matrix[0][j]\n       \n       // Fill the first column\n       for i from 1 to n-1:\n           dp[i][0] = dp[i-1][0] + matrix[i][0]\n       \n       // Fill the rest of the dp array\n       for i from 1 to n-1:\n           for j from 1 to n-1:\n               dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n       \n       // The maximum sum is in dp[n-1][n-1]\n       max_sum = dp[n-1][n-1]\n       number_of_cells = n + n - 1  // total cells in the path\n       \n       return max_sum / number_of_cells\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n```python\ndef maxAverageOfPath(matrix):\n    n = len(matrix)  # Get the size of the matrix\n    dp = [[0] * n for _ in range(n)]  # Create a 2D array for dynamic programming\n\n    dp[0][0] = matrix[0][0]  # Starting point\n\n    # Fill the first row\n    for j in range(1, n):\n        dp[0][j] = dp[0][j - 1] + matrix[0][j]\n\n    # Fill the first column\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n\n    # Fill the rest of the dp array\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n\n    # The maximum sum is in dp[n-1][n-1]\n    max_sum = dp[n - 1][n - 1]\n    number_of_cells = n + n - 1  # Total cells in the path\n\n    return max_sum / number_of_cells  # Return the average\n```",
    "no_parent": true,
    "dependency_used": false
}