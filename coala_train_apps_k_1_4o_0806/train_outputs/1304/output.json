{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['3 2', '3 1 2', '2 3 1', ''] Output: 3 2 1\n3 1 2 \n\nTests failed:\nNone",
    "code": "\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        # Find the element just larger than perm[i]\n        while perm[j] <= perm[i]:\n            j -= 1\n        # Swap them\n        perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    \n    results = []\n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\n# Call the main function to execute the logic\nmain()\n",
    "full_code": "\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        # Find the element just larger than perm[i]\n        while perm[j] <= perm[i]:\n            j -= 1\n        # Swap them\n        perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    \n    results = []\n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\n# Call the main function to execute the logic\nmain()\n",
    "reward": true,
    "program_code": "\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        # Find the element just larger than perm[i]\n        while perm[j] <= perm[i]:\n            j -= 1\n        # Swap them\n        perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    \n    results = []\n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\n# Call the main function to execute the logic\nmain()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nGiven a permutation of numbers from 1 to N, the task is to find the next permutation in lexicographic order. We are provided with K permutations, and for each permutation, we need to output its next permutation in lexicographic order.\n\n### Conceptual Solution\n\n1. **Understanding Lexicographic Order**: Lexicographic order is similar to dictionary order. For permutations, it means arranging numbers in increasing order.\n\n2. **Finding the Next Permutation**:\n   - Start from the end of the permutation and find the first pair of consecutive elements where the earlier element is smaller than the later one. This identifies the point where the order can be increased.\n   - Swap this element with the smallest element to its right that is larger than it.\n   - Reverse the sequence to the right of the original position of the first element to get the smallest possible order.\n\n3. **Edge Case**: If the permutation is the largest possible (i.e., in descending order), the next permutation is the smallest possible (i.e., in ascending order).\n\n### Pseudocode\n\n```\nfunction next_permutation(perm):\n    n = length of perm\n    i = n - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        while perm[j] <= perm[i]:\n            j -= 1\n        swap perm[i] and perm[j]\n    reverse perm from i + 1 to end\n    return perm\n\nfunction main():\n    read N and K\n    for each of K permutations:\n        read permutation\n        print next_permutation(permutation)\n```\n\n### Final Python Solution\n\n```python\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        # Find the element just larger than perm[i]\n        while perm[j] <= perm[i]:\n            j -= 1\n        # Swap them\n        perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    \n    results = []\n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(permutation)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\n# Call the main function to execute the logic\nmain()\n```\n\n### Explanation\n\n- **next_permutation**: This function implements the logic to find the next permutation in lexicographic order.\n- **main**: This function handles input and output. It reads the input, processes each permutation using `next_permutation`, and prints the results.",
    "no_parent": false,
    "dependency_used": false
}