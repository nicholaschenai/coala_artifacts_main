{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['3', '4 12', '2 2', '5 14'] Output: [{'-1'}, {'2', '1'}, {'2', '1', '5', '4', '3'}]\n\nTests failed:\nNone",
    "code": "\ndef find_permutation():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        max_possible = (N * (N + 1) // 2) - 1\n        min_possible = (N * (N - 1) // 2)\n        \n        if K < min_possible or K > max_possible:\n            results.append(\"-1\")\n        else:\n            permutation = list(range(N, 0, -1))\n            current_sum = max_possible\n            \n            for i in range(N - 1):\n                if current_sum == K:\n                    break\n                if current_sum - (permutation[i] - permutation[i + 1]) >= K:\n                    current_sum -= (permutation[i] - permutation[i + 1])\n                    permutation[i], permutation[i + 1] = permutation[i + 1], permutation[i]\n            \n            results.append(\" \".join(map(str, permutation)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n# Call the function to execute the logic\nfind_permutation()\n",
    "full_code": "\ndef find_permutation():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        max_possible = (N * (N + 1) // 2) - 1\n        min_possible = (N * (N - 1) // 2)\n        \n        if K < min_possible or K > max_possible:\n            results.append(\"-1\")\n        else:\n            permutation = list(range(N, 0, -1))\n            current_sum = max_possible\n            \n            for i in range(N - 1):\n                if current_sum == K:\n                    break\n                if current_sum - (permutation[i] - permutation[i + 1]) >= K:\n                    current_sum -= (permutation[i] - permutation[i + 1])\n                    permutation[i], permutation[i + 1] = permutation[i + 1], permutation[i]\n            \n            results.append(\" \".join(map(str, permutation)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n# Call the function to execute the logic\nfind_permutation()\n",
    "reward": true,
    "program_code": "\ndef find_permutation():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        max_possible = (N * (N + 1) // 2) - 1\n        min_possible = (N * (N - 1) // 2)\n        \n        if K < min_possible or K > max_possible:\n            results.append(\"-1\")\n        else:\n            permutation = list(range(N, 0, -1))\n            current_sum = max_possible\n            \n            for i in range(N - 1):\n                if current_sum == K:\n                    break\n                if current_sum - (permutation[i] - permutation[i + 1]) >= K:\n                    current_sum -= (permutation[i] - permutation[i + 1])\n                    permutation[i], permutation[i + 1] = permutation[i + 1], permutation[i]\n            \n            results.append(\" \".join(map(str, permutation)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n# Call the function to execute the logic\nfind_permutation()\n",
    "program_name": "find_permutation",
    "dependencies": [],
    "raw_msg": "```python\ndef find_permutation():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        max_possible = (N * (N + 1) // 2) - 1\n        min_possible = (N * (N - 1) // 2)\n        \n        if K < min_possible or K > max_possible:\n            results.append(\"-1\")\n        else:\n            permutation = list(range(N, 0, -1))\n            current_sum = max_possible\n            \n            for i in range(N - 1):\n                if current_sum == K:\n                    break\n                if current_sum - (permutation[i] - permutation[i + 1]) >= K:\n                    current_sum -= (permutation[i] - permutation[i + 1])\n                    permutation[i], permutation[i + 1] = permutation[i + 1], permutation[i]\n            \n            results.append(\" \".join(map(str, permutation)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n# Call the function to execute the logic\nfind_permutation()\n```\n\n### Explanation:\n- **Function Call**: The function `find_permutation` is called at the end to ensure the logic is executed.\n- **Input Handling**: The input is read using `sys.stdin.read` for efficiency with large inputs.\n- **Output Handling**: The results are collected in a list and written to standard output at the end.\n- **Permutation Construction**: The logic constructs a permutation starting from the descending order and adjusts it to achieve the desired sum K, if possible.",
    "no_parent": false,
    "dependency_used": false
}