{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['2', '0 1', '1 -1'] Output: YES\n\nTests failed:\nNone",
    "code": "\ndef can_zebras_spit_at_each_other(t, zebras):\n    # Create a dictionary to map each zebra's position to the position it can hit\n    spit_map = {}\n    \n    # Populate the spit_map\n    for zebra in zebras:\n        position, distance = zebra\n        spit_position = position + distance\n        spit_map[position] = spit_position\n    \n    # Check for mutual spitting\n    for position, spit_position in spit_map.items():\n        if spit_position in spit_map and spit_map[spit_position] == position:\n            return \"YES\"\n    \n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    zebras = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        zebras.append((a, b))\n        index += 2\n    \n    result = can_zebras_spit_at_each_other(t, zebras)\n    print(result)\n\nmain()\n",
    "full_code": "\ndef can_zebras_spit_at_each_other(t, zebras):\n    # Create a dictionary to map each zebra's position to the position it can hit\n    spit_map = {}\n    \n    # Populate the spit_map\n    for zebra in zebras:\n        position, distance = zebra\n        spit_position = position + distance\n        spit_map[position] = spit_position\n    \n    # Check for mutual spitting\n    for position, spit_position in spit_map.items():\n        if spit_position in spit_map and spit_map[spit_position] == position:\n            return \"YES\"\n    \n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    zebras = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        zebras.append((a, b))\n        index += 2\n    \n    result = can_zebras_spit_at_each_other(t, zebras)\n    print(result)\n\nmain()\n",
    "reward": true,
    "program_code": "\ndef can_zebras_spit_at_each_other(t, zebras):\n    # Create a dictionary to map each zebra's position to the position it can hit\n    spit_map = {}\n    \n    # Populate the spit_map\n    for zebra in zebras:\n        position, distance = zebra\n        spit_position = position + distance\n        spit_map[position] = spit_position\n    \n    # Check for mutual spitting\n    for position, spit_position in spit_map.items():\n        if spit_position in spit_map and spit_map[spit_position] == position:\n            return \"YES\"\n    \n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    zebras = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        zebras.append((a, b))\n        index += 2\n    \n    result = can_zebras_spit_at_each_other(t, zebras)\n    print(result)\n\nmain()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe need to determine if there are two zebras in a jungle that have spitted at each other. Each zebra is positioned at a certain point and spits a certain distance either to the left or right. If a zebra at position `a` spits `b` meters, it can hit another zebra at position `a + b`. We need to check if there exists a pair of zebras such that they have spitted at each other.\n\n## Conceptual Solution\n\n1. **Understanding the Problem**: We have a list of zebras, each with a position and a spit distance. We need to check if there are two zebras such that one spits and hits the other, and vice versa.\n\n2. **Data Structure**: Use a dictionary to map each zebra's position to the position it can hit. This will allow us to quickly check if a zebra can hit another zebra.\n\n3. **Check for Mutual Spitting**: For each zebra, calculate the position it can hit. Check if there is another zebra at that position that can also hit back the original zebra.\n\n4. **Output**: If such a pair is found, output \"YES\". Otherwise, output \"NO\".\n\n## Pseudocode\n\n```\nfunction can_zebras_spit_at_each_other(t, zebras):\n    # Create a dictionary to map each zebra's position to the position it can hit\n    spit_map = {}\n    \n    # Populate the spit_map\n    for each zebra in zebras:\n        position, distance = zebra\n        spit_position = position + distance\n        spit_map[position] = spit_position\n    \n    # Check for mutual spitting\n    for position, spit_position in spit_map.items():\n        if spit_position in spit_map and spit_map[spit_position] == position:\n            return \"YES\"\n    \n    return \"NO\"\n\n# Read input\nt = read integer\nzebras = []\nfor i from 1 to t:\n    a, b = read two integers\n    zebras.append((a, b))\n\n# Determine if any zebras spit at each other\nresult = can_zebras_spit_at_each_other(t, zebras)\n\n# Output result\nprint(result)\n```\n\n## Final Python Solution\n\n```python\ndef can_zebras_spit_at_each_other(t, zebras):\n    # Create a dictionary to map each zebra's position to the position it can hit\n    spit_map = {}\n    \n    # Populate the spit_map\n    for zebra in zebras:\n        position, distance = zebra\n        spit_position = position + distance\n        spit_map[position] = spit_position\n    \n    # Check for mutual spitting\n    for position, spit_position in spit_map.items():\n        if spit_position in spit_map and spit_map[spit_position] == position:\n            return \"YES\"\n    \n    return \"NO\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    zebras = []\n    index = 1\n    for _ in range(t):\n        a = int(data[index])\n        b = int(data[index + 1])\n        zebras.append((a, b))\n        index += 2\n    \n    result = can_zebras_spit_at_each_other(t, zebras)\n    print(result)\n\nmain()\n```\n\nThis solution reads the input, processes the positions and spit distances of the zebras, and checks if any two zebras can spit at each other. If such a pair is found, it outputs \"YES\", otherwise \"NO\".",
    "no_parent": false,
    "dependency_used": false
}