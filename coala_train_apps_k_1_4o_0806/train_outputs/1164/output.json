{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['3 3', '16 24 60', '498 861 589', '14 24 62', '72 557 819', '16 15 69', '435 779 232'] Output: 2\n1\n3\n\nTests failed:\nNone",
    "code": "\ndef calculate_difficulty(problems):\n    difficulties = []\n    for index, (scores, contestants) in enumerate(problems):\n        # Pair scores with contestants and sort by score\n        paired = sorted(zip(scores, contestants))\n        # Extract the sorted contestants based on sorted scores\n        sorted_contestants = [c for _, c in paired]\n        \n        # Count the number of decreases\n        decrease_count = 0\n        for j in range(len(sorted_contestants) - 1):\n            if sorted_contestants[j] > sorted_contestants[j + 1]:\n                decrease_count += 1\n        \n        # Store the difficulty as a tuple (decrease_count, index)\n        difficulties.append((decrease_count, index + 1))\n    \n    # Sort by decrease_count, and by index in case of ties\n    difficulties.sort()\n    \n    # Extract the sorted indices\n    sorted_indices = [index for _, index in difficulties]\n    return sorted_indices\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    P = int(data[0])\n    S = int(data[1])\n    \n    problems = []\n    index = 2\n    for _ in range(P):\n        scores = list(map(int, data[index:index + S]))\n        contestants = list(map(int, data[index + S:index + 2 * S]))\n        problems.append((scores, contestants))\n        index += 2 * S\n    \n    sorted_indices = calculate_difficulty(problems)\n    for idx in sorted_indices:\n        print(idx)\n\nmain()\n",
    "full_code": "\ndef calculate_difficulty(problems):\n    difficulties = []\n    for index, (scores, contestants) in enumerate(problems):\n        # Pair scores with contestants and sort by score\n        paired = sorted(zip(scores, contestants))\n        # Extract the sorted contestants based on sorted scores\n        sorted_contestants = [c for _, c in paired]\n        \n        # Count the number of decreases\n        decrease_count = 0\n        for j in range(len(sorted_contestants) - 1):\n            if sorted_contestants[j] > sorted_contestants[j + 1]:\n                decrease_count += 1\n        \n        # Store the difficulty as a tuple (decrease_count, index)\n        difficulties.append((decrease_count, index + 1))\n    \n    # Sort by decrease_count, and by index in case of ties\n    difficulties.sort()\n    \n    # Extract the sorted indices\n    sorted_indices = [index for _, index in difficulties]\n    return sorted_indices\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    P = int(data[0])\n    S = int(data[1])\n    \n    problems = []\n    index = 2\n    for _ in range(P):\n        scores = list(map(int, data[index:index + S]))\n        contestants = list(map(int, data[index + S:index + 2 * S]))\n        problems.append((scores, contestants))\n        index += 2 * S\n    \n    sorted_indices = calculate_difficulty(problems)\n    for idx in sorted_indices:\n        print(idx)\n\nmain()\n",
    "reward": true,
    "program_code": "\ndef calculate_difficulty(problems):\n    difficulties = []\n    for index, (scores, contestants) in enumerate(problems):\n        # Pair scores with contestants and sort by score\n        paired = sorted(zip(scores, contestants))\n        # Extract the sorted contestants based on sorted scores\n        sorted_contestants = [c for _, c in paired]\n        \n        # Count the number of decreases\n        decrease_count = 0\n        for j in range(len(sorted_contestants) - 1):\n            if sorted_contestants[j] > sorted_contestants[j + 1]:\n                decrease_count += 1\n        \n        # Store the difficulty as a tuple (decrease_count, index)\n        difficulties.append((decrease_count, index + 1))\n    \n    # Sort by decrease_count, and by index in case of ties\n    difficulties.sort()\n    \n    # Extract the sorted indices\n    sorted_indices = [index for _, index in difficulties]\n    return sorted_indices\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    P = int(data[0])\n    S = int(data[1])\n    \n    problems = []\n    index = 2\n    for _ in range(P):\n        scores = list(map(int, data[index:index + S]))\n        contestants = list(map(int, data[index + S:index + 2 * S]))\n        problems.append((scores, contestants))\n        index += 2 * S\n    \n    sorted_indices = calculate_difficulty(problems)\n    for idx in sorted_indices:\n        print(idx)\n\nmain()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe have a contest with multiple problems, each containing several subtasks. Each subtask has a score and a number of contestants who solved it. The difficulty of a problem is determined by counting how many times the number of contestants solving a subtask decreases as the score increases. We need to sort the problems by their difficulty, where a problem is considered more difficult if it has more such decreases, or if the number of decreases is the same, the problem with the higher index is considered more difficult.\n\n### Conceptual Solution\n\n1. **Input Parsing**: Read the number of problems `P` and the number of subtasks `S`. For each problem, read the scores and the number of contestants who solved each subtask.\n\n2. **Calculate Difficulty**: For each problem, sort the subtasks by score. Count the number of times the number of contestants decreases as the score increases.\n\n3. **Sort Problems**: Sort the problems based on the difficulty measure `(n, i)`, where `n` is the number of decreases and `i` is the problem index.\n\n4. **Output**: Print the indices of the problems in increasing order of difficulty.\n\n### Pseudocode\n\n```\nfunction calculate_difficulty(problems):\n    difficulties = []\n    for each problem in problems:\n        sort subtasks by score\n        count decreases in number of contestants\n        store (count, index) in difficulties\n    sort difficulties by (count, index)\n    return sorted indices\n\nread P, S\ninitialize problems list\nfor i from 1 to P:\n    read scores\n    read number of contestants\n    add (scores, contestants) to problems\nsorted_indices = calculate_difficulty(problems)\nfor index in sorted_indices:\n    print index\n```\n\n### Python Code\n\n```python\ndef calculate_difficulty(problems):\n    difficulties = []\n    for index, (scores, contestants) in enumerate(problems):\n        # Pair scores with contestants and sort by score\n        paired = sorted(zip(scores, contestants))\n        # Extract the sorted contestants based on sorted scores\n        sorted_contestants = [c for _, c in paired]\n        \n        # Count the number of decreases\n        decrease_count = 0\n        for j in range(len(sorted_contestants) - 1):\n            if sorted_contestants[j] > sorted_contestants[j + 1]:\n                decrease_count += 1\n        \n        # Store the difficulty as a tuple (decrease_count, index)\n        difficulties.append((decrease_count, index + 1))\n    \n    # Sort by decrease_count, and by index in case of ties\n    difficulties.sort()\n    \n    # Extract the sorted indices\n    sorted_indices = [index for _, index in difficulties]\n    return sorted_indices\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    P = int(data[0])\n    S = int(data[1])\n    \n    problems = []\n    index = 2\n    for _ in range(P):\n        scores = list(map(int, data[index:index + S]))\n        contestants = list(map(int, data[index + S:index + 2 * S]))\n        problems.append((scores, contestants))\n        index += 2 * S\n    \n    sorted_indices = calculate_difficulty(problems)\n    for idx in sorted_indices:\n        print(idx)\n\nmain()\n```\n\nThis code reads input, calculates the difficulty of each problem, sorts them, and outputs the indices in the required order.",
    "no_parent": false,
    "dependency_used": false
}