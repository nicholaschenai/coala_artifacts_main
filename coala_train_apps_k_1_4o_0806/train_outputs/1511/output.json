{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['2', '4 5', 'I::M', '9 10', 'MIM_XII:M'] Output: 1\n2\n\nTests failed:\nNone",
    "code": "\ndef max_magnets(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N, K, S = test_case\n        segments = S.split('X')\n        total_pairs = 0\n        \n        for segment in segments:\n            magnets = []\n            irons = []\n            sheets = [0] * (len(segment) + 1)\n            \n            for idx, char in enumerate(segment):\n                if char == 'M':\n                    magnets.append(idx)\n                elif char == 'I':\n                    irons.append(idx)\n                sheets[idx + 1] = sheets[idx] + (1 if char == ':' else 0)\n            \n            i, j = 0, 0\n            while i < len(magnets) and j < len(irons):\n                m = magnets[i]\n                iron = irons[j]\n                num_sheets = sheets[max(m, iron) + 1] - sheets[min(m, iron) + 1]\n                power = K + 1 - abs(m - iron) - num_sheets\n                \n                if power > 0:\n                    total_pairs += 1\n                    i += 1\n                    j += 1\n                elif m < iron:\n                    i += 1\n                else:\n                    j += 1\n        \n        results.append(total_pairs)\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\ntest_cases = []\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    S = data[index + 2]\n    test_cases.append((N, K, S))\n    index += 3\n\nmax_magnets(T, test_cases)\n",
    "full_code": "\ndef max_magnets(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N, K, S = test_case\n        segments = S.split('X')\n        total_pairs = 0\n        \n        for segment in segments:\n            magnets = []\n            irons = []\n            sheets = [0] * (len(segment) + 1)\n            \n            for idx, char in enumerate(segment):\n                if char == 'M':\n                    magnets.append(idx)\n                elif char == 'I':\n                    irons.append(idx)\n                sheets[idx + 1] = sheets[idx] + (1 if char == ':' else 0)\n            \n            i, j = 0, 0\n            while i < len(magnets) and j < len(irons):\n                m = magnets[i]\n                iron = irons[j]\n                num_sheets = sheets[max(m, iron) + 1] - sheets[min(m, iron) + 1]\n                power = K + 1 - abs(m - iron) - num_sheets\n                \n                if power > 0:\n                    total_pairs += 1\n                    i += 1\n                    j += 1\n                elif m < iron:\n                    i += 1\n                else:\n                    j += 1\n        \n        results.append(total_pairs)\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\ntest_cases = []\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    S = data[index + 2]\n    test_cases.append((N, K, S))\n    index += 3\n\nmax_magnets(T, test_cases)\n",
    "reward": true,
    "program_code": "\ndef max_magnets(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N, K, S = test_case\n        segments = S.split('X')\n        total_pairs = 0\n        \n        for segment in segments:\n            magnets = []\n            irons = []\n            sheets = [0] * (len(segment) + 1)\n            \n            for idx, char in enumerate(segment):\n                if char == 'M':\n                    magnets.append(idx)\n                elif char == 'I':\n                    irons.append(idx)\n                sheets[idx + 1] = sheets[idx] + (1 if char == ':' else 0)\n            \n            i, j = 0, 0\n            while i < len(magnets) and j < len(irons):\n                m = magnets[i]\n                iron = irons[j]\n                num_sheets = sheets[max(m, iron) + 1] - sheets[min(m, iron) + 1]\n                power = K + 1 - abs(m - iron) - num_sheets\n                \n                if power > 0:\n                    total_pairs += 1\n                    i += 1\n                    j += 1\n                elif m < iron:\n                    i += 1\n                else:\n                    j += 1\n        \n        results.append(total_pairs)\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\ntest_cases = []\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    S = data[index + 2]\n    test_cases.append((N, K, S))\n    index += 3\n\nmax_magnets(T, test_cases)\n",
    "program_name": "max_magnets",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe have a sequence of cells, each containing either iron ('I'), a magnet ('M'), an empty space ('_'), a conducting sheet (':'), or a blocked cell ('X'). Magnets can attract iron pieces if the attraction power between them is positive and there are no blocked cells between them. The attraction power is calculated as `P_{i,j} = K + 1 - |j-i| - S_{i,j}`, where `S_{i,j}` is the number of conducting sheets between the magnet and the iron. We need to determine the maximum number of magnets that can attract iron pieces for each test case.\n\n### Conceptual Solution\n\n1. **Segmentation**: First, split the sequence into segments separated by blocked cells ('X'), as no attraction can occur across these cells.\n\n2. **Attraction Calculation**: For each segment, calculate the attraction power between each magnet and each iron piece. If the power is positive, consider this pair for attraction.\n\n3. **Greedy Pairing**: Use a greedy approach to pair magnets and iron pieces within each segment. Start with the closest pairs and move outward, ensuring each iron and magnet is used at most once.\n\n4. **Count Maximum Pairs**: For each segment, count the maximum number of valid magnet-iron pairs and sum these counts for the final result.\n\n### Pseudocode\n\n```\nfunction max_magnets(T, test_cases):\n    for each test_case in test_cases:\n        N, K, S = test_case\n        segments = split S by 'X'\n        total_pairs = 0\n        \n        for each segment in segments:\n            magnets = indices of 'M' in segment\n            irons = indices of 'I' in segment\n            sheets = prefix sum of ':' in segment\n            \n            i, j = 0, 0\n            while i < len(magnets) and j < len(irons):\n                m = magnets[i]\n                iron = irons[j]\n                num_sheets = sheets[max(m, iron)] - sheets[min(m, iron)]\n                power = K + 1 - abs(m - iron) - num_sheets\n                \n                if power > 0:\n                    total_pairs += 1\n                    i += 1\n                    j += 1\n                elif m < iron:\n                    i += 1\n                else:\n                    j += 1\n        \n        print total_pairs\n```\n\n### Final Python Solution\n\n```python\ndef max_magnets(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N, K, S = test_case\n        segments = S.split('X')\n        total_pairs = 0\n        \n        for segment in segments:\n            magnets = []\n            irons = []\n            sheets = [0] * (len(segment) + 1)\n            \n            for idx, char in enumerate(segment):\n                if char == 'M':\n                    magnets.append(idx)\n                elif char == 'I':\n                    irons.append(idx)\n                sheets[idx + 1] = sheets[idx] + (1 if char == ':' else 0)\n            \n            i, j = 0, 0\n            while i < len(magnets) and j < len(irons):\n                m = magnets[i]\n                iron = irons[j]\n                num_sheets = sheets[max(m, iron) + 1] - sheets[min(m, iron) + 1]\n                power = K + 1 - abs(m - iron) - num_sheets\n                \n                if power > 0:\n                    total_pairs += 1\n                    i += 1\n                    j += 1\n                elif m < iron:\n                    i += 1\n                else:\n                    j += 1\n        \n        results.append(total_pairs)\n    \n    for result in results:\n        print(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nT = int(data[0])\nindex = 1\ntest_cases = []\nfor _ in range(T):\n    N = int(data[index])\n    K = int(data[index + 1])\n    S = data[index + 2]\n    test_cases.append((N, K, S))\n    index += 3\n\nmax_magnets(T, test_cases)\n```\n\nThis solution efficiently processes each test case by segmenting the string, calculating attraction power, and using a greedy approach to maximize the number of magnet-iron pairs.",
    "no_parent": false,
    "dependency_used": false
}