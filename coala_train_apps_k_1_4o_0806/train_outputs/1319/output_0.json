{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['10 3', '1', '3', '7', '6', '-1', '5', '-1', '18', '9', '11', '2', '-1', '4'] Output: 7\n6\n18\n\nTests failed:\nNone",
    "code": "\ndef process_events():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read the first line to get N and M\n    N, M = map(int, data[0].split())\n    \n    # Initialize a max-heap and a set to track beheaded citizens\n    max_heap = []\n    beheaded = set()\n    \n    # Function to push into max-heap (negate value for max-heap behavior)\n    def push_heap(heap, value):\n        heap.append(-value)\n        heap.sort()\n    \n    # Function to pop from max-heap (negate value back)\n    def pop_heap(heap):\n        return -heap.pop(0)\n    \n    # Process each event\n    for event in data[1:]:\n        event = int(event)\n        if event > 0:\n            # Citizen's wealth, add to heap\n            push_heap(max_heap, event)\n        elif event == -1:\n            # King's visit, find the richest alive\n            while max_heap and -max_heap[0] in beheaded:\n                pop_heap(max_heap)\n            richest = pop_heap(max_heap)\n            beheaded.add(richest)\n            print(richest)\n\nprocess_events()\n",
    "full_code": "\ndef process_events():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read the first line to get N and M\n    N, M = map(int, data[0].split())\n    \n    # Initialize a max-heap and a set to track beheaded citizens\n    max_heap = []\n    beheaded = set()\n    \n    # Function to push into max-heap (negate value for max-heap behavior)\n    def push_heap(heap, value):\n        heap.append(-value)\n        heap.sort()\n    \n    # Function to pop from max-heap (negate value back)\n    def pop_heap(heap):\n        return -heap.pop(0)\n    \n    # Process each event\n    for event in data[1:]:\n        event = int(event)\n        if event > 0:\n            # Citizen's wealth, add to heap\n            push_heap(max_heap, event)\n        elif event == -1:\n            # King's visit, find the richest alive\n            while max_heap and -max_heap[0] in beheaded:\n                pop_heap(max_heap)\n            richest = pop_heap(max_heap)\n            beheaded.add(richest)\n            print(richest)\n\nprocess_events()\n",
    "reward": true,
    "program_code": "\ndef process_events():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read the first line to get N and M\n    N, M = map(int, data[0].split())\n    \n    # Initialize a max-heap and a set to track beheaded citizens\n    max_heap = []\n    beheaded = set()\n    \n    # Function to push into max-heap (negate value for max-heap behavior)\n    def push_heap(heap, value):\n        heap.append(-value)\n        heap.sort()\n    \n    # Function to pop from max-heap (negate value back)\n    def pop_heap(heap):\n        return -heap.pop(0)\n    \n    # Process each event\n    for event in data[1:]:\n        event = int(event)\n        if event > 0:\n            # Citizen's wealth, add to heap\n            push_heap(max_heap, event)\n        elif event == -1:\n            # King's visit, find the richest alive\n            while max_heap and -max_heap[0] in beheaded:\n                pop_heap(max_heap)\n            richest = pop_heap(max_heap)\n            beheaded.add(richest)\n            print(richest)\n\nprocess_events()\n",
    "program_name": "process_events",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n\n   We have a sequence of events where citizens declare their wealth and the king visits the court. Each citizen's wealth is a unique positive integer, and a king's visit is denoted by `-1`. When the king visits, the richest citizen who has appeared so far and is still alive is beheaded. We need to output the wealth of the citizen who is beheaded at each of the king's visits.\n\n2. **Conceptualize a solution in plain English:**\n\n   We will maintain a list of citizens' wealth as they appear. When a king's visit occurs, we need to find the richest citizen who is still alive (i.e., not yet beheaded). We can use a max-heap to efficiently track the richest citizen. Each time a citizen appears, we add their wealth to the heap. When the king visits, we extract the maximum wealth from the heap, which represents the richest citizen to be beheaded.\n\n3. **Write a pseudocode solution:**\n\n   ```\n   Initialize an empty max-heap\n   Initialize an empty set to track beheaded citizens\n\n   For each event in the sequence:\n       If the event is a positive integer (citizen's wealth):\n           Add the wealth to the max-heap\n       Else if the event is -1 (king's visit):\n           While the top of the heap is in the set of beheaded citizens:\n               Remove the top of the heap\n           Extract the maximum wealth from the heap\n           Add this wealth to the set of beheaded citizens\n           Output this wealth\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n\n```python\ndef process_events():\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    # Read the first line to get N and M\n    N, M = map(int, data[0].split())\n    \n    # Initialize a max-heap and a set to track beheaded citizens\n    max_heap = []\n    beheaded = set()\n    \n    # Function to push into max-heap (negate value for max-heap behavior)\n    def push_heap(heap, value):\n        heap.append(-value)\n        heap.sort()\n    \n    # Function to pop from max-heap (negate value back)\n    def pop_heap(heap):\n        return -heap.pop(0)\n    \n    # Process each event\n    for event in data[1:]:\n        event = int(event)\n        if event > 0:\n            # Citizen's wealth, add to heap\n            push_heap(max_heap, event)\n        elif event == -1:\n            # King's visit, find the richest alive\n            while max_heap and -max_heap[0] in beheaded:\n                pop_heap(max_heap)\n            richest = pop_heap(max_heap)\n            beheaded.add(richest)\n            print(richest)\n\nprocess_events()\n```\n\nThis solution uses a max-heap to efficiently track the richest citizen who is still alive. The heap operations are managed by negating values to simulate max-heap behavior using Python's list sorting.",
    "no_parent": false,
    "dependency_used": false
}