{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['2', '4', '1 0 1 0', '0 0 0 1', '0 1 0 0', '1 0 0 1', '4', '1 0 1 0', '0 0 0 0', '1 0 1 1', '0 1 0 0'] Expected output: [{'SAFE'}, {'UNSAFE'}] # Execution output: []\nNo output detected. You might want to check the reading from / writing to standard IO.\nA common mistake is to put the IO inside a function, but the function is not called.\n",
    "code": "\ndef is_safe(grid, N):\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                # Check horizontal and vertical neighbors\n                if i > 0 and grid[i-1][j] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and grid[i+1][j] == 1:\n                    return \"UNSAFE\"\n                if j > 0 and grid[i][j-1] == 1:\n                    return \"UNSAFE\"\n                if j < N-1 and grid[i][j+1] == 1:\n                    return \"UNSAFE\"\n                # Check diagonal neighbors\n                if i > 0 and j > 0 and grid[i-1][j-1] == 1:\n                    return \"UNSAFE\"\n                if i > 0 and j < N-1 and grid[i-1][j+1] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and j > 0 and grid[i+1][j-1] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and j < N-1 and grid[i+1][j+1] == 1:\n                    return \"UNSAFE\"\n    return \"SAFE\"\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\n",
    "full_code": "\ndef is_safe(grid, N):\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                # Check horizontal and vertical neighbors\n                if i > 0 and grid[i-1][j] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and grid[i+1][j] == 1:\n                    return \"UNSAFE\"\n                if j > 0 and grid[i][j-1] == 1:\n                    return \"UNSAFE\"\n                if j < N-1 and grid[i][j+1] == 1:\n                    return \"UNSAFE\"\n                # Check diagonal neighbors\n                if i > 0 and j > 0 and grid[i-1][j-1] == 1:\n                    return \"UNSAFE\"\n                if i > 0 and j < N-1 and grid[i-1][j+1] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and j > 0 and grid[i+1][j-1] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and j < N-1 and grid[i+1][j+1] == 1:\n                    return \"UNSAFE\"\n    return \"SAFE\"\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\n",
    "reward": false,
    "program_code": "\ndef is_safe(grid, N):\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                # Check horizontal and vertical neighbors\n                if i > 0 and grid[i-1][j] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and grid[i+1][j] == 1:\n                    return \"UNSAFE\"\n                if j > 0 and grid[i][j-1] == 1:\n                    return \"UNSAFE\"\n                if j < N-1 and grid[i][j+1] == 1:\n                    return \"UNSAFE\"\n                # Check diagonal neighbors\n                if i > 0 and j > 0 and grid[i-1][j-1] == 1:\n                    return \"UNSAFE\"\n                if i > 0 and j < N-1 and grid[i-1][j+1] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and j > 0 and grid[i+1][j-1] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and j < N-1 and grid[i+1][j+1] == 1:\n                    return \"UNSAFE\"\n    return \"SAFE\"\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\n",
    "program_name": "solve",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe are given a grid of size \\( N \\times N \\) where each cell can either have a bed (denoted by 1) or be empty (denoted by 0). The task is to determine if the arrangement of beds is \"SAFE\" or \"UNSAFE\". A \"SAFE\" arrangement means no two beds are adjacent horizontally, vertically, or diagonally, except for consecutive diagonal blocks. We need to check this condition for multiple test cases.\n\n## Conceptual Solution\n\n1. **Input Parsing**: Read the number of test cases \\( T \\). For each test case, read the size \\( N \\) of the grid and then the \\( N \\times N \\) grid itself.\n\n2. **Safety Check**: For each grid, check every cell that contains a bed (1). Ensure that no adjacent cell (up, down, left, right, and diagonals) also contains a bed, except for the allowed consecutive diagonal blocks.\n\n3. **Output**: For each test case, output \"SAFE\" if the arrangement meets the criteria, otherwise output \"UNSAFE\".\n\n## Pseudocode\n\n```\nfunction is_safe(grid, N):\n    for each cell (i, j) in grid:\n        if grid[i][j] == 1:\n            check all adjacent cells (i-1, j), (i+1, j), (i, j-1), (i, j+1)\n            check diagonal cells (i-1, j-1), (i-1, j+1), (i+1, j-1), (i+1, j+1)\n            if any of these cells contain a bed (1), return \"UNSAFE\"\n    return \"SAFE\"\n\nfunction solve():\n    read T\n    for each test case:\n        read N\n        read the N x N grid\n        result = is_safe(grid, N)\n        print result\n```\n\n## Final Python Solution\n\n```python\ndef is_safe(grid, N):\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                # Check horizontal and vertical neighbors\n                if i > 0 and grid[i-1][j] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and grid[i+1][j] == 1:\n                    return \"UNSAFE\"\n                if j > 0 and grid[i][j-1] == 1:\n                    return \"UNSAFE\"\n                if j < N-1 and grid[i][j+1] == 1:\n                    return \"UNSAFE\"\n                # Check diagonal neighbors\n                if i > 0 and j > 0 and grid[i-1][j-1] == 1:\n                    return \"UNSAFE\"\n                if i > 0 and j < N-1 and grid[i-1][j+1] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and j > 0 and grid[i+1][j-1] == 1:\n                    return \"UNSAFE\"\n                if i < N-1 and j < N-1 and grid[i+1][j+1] == 1:\n                    return \"UNSAFE\"\n    return \"SAFE\"\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\n```",
    "no_parent": false,
    "dependency_used": false
}