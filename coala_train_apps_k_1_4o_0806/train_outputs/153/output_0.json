{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: [[2, 2, 2, 1, 1]] Output: True\n\nTests failed:\nNone",
    "code": "\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums or sum(nums) % 4 != 0:\n            return False\n        \n        target = sum(nums) // 4\n        nums.sort(reverse=True)\n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n",
    "full_code": "\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums or sum(nums) % 4 != 0:\n            return False\n        \n        target = sum(nums) // 4\n        nums.sort(reverse=True)\n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n",
    "reward": true,
    "program_code": "\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums or sum(nums) % 4 != 0:\n            return False\n        \n        target = sum(nums) // 4\n        nums.sort(reverse=True)\n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n",
    "program_name": "",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe need to determine if we can use all given matchsticks to form a perfect square. Each matchstick can only be used once, and we cannot break any matchstick. The goal is to see if we can arrange the matchsticks such that they form four equal-length sides of a square.\n\n## Conceptual Solution\n\n1. **Check Total Length**: First, calculate the total length of all matchsticks. If this total is not divisible by 4, it's impossible to form a square, and we should return `False`.\n\n2. **Target Side Length**: If the total length is divisible by 4, the target length for each side of the square is the total length divided by 4.\n\n3. **Backtracking Approach**: Use a backtracking approach to try and form the four sides of the square. Start by sorting the matchsticks in descending order to optimize the process (larger sticks are harder to place, so try them first).\n\n4. **Recursive Function**: Create a recursive function that attempts to build each side of the square. If a matchstick can fit into the current side without exceeding the target length, place it and move to the next matchstick. If a side is completed, move to the next side.\n\n5. **Base Case**: If all matchsticks are used and all four sides are formed, return `True`. If at any point a matchstick cannot be placed, backtrack and try a different configuration.\n\n## Pseudocode\n\n```\nfunction makesquare(nums):\n    if sum(nums) % 4 != 0:\n        return False\n    target = sum(nums) / 4\n    sort nums in descending order\n    sides = [0, 0, 0, 0]\n    \n    function backtrack(index):\n        if index == length of nums:\n            return all sides are equal to target\n        for each side in sides:\n            if side + nums[index] <= target:\n                add nums[index] to side\n                if backtrack(index + 1):\n                    return True\n                remove nums[index] from side\n        return False\n    \n    return backtrack(0)\n```\n\n## Final Python Solution\n\n```python\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums or sum(nums) % 4 != 0:\n            return False\n        \n        target = sum(nums) // 4\n        nums.sort(reverse=True)\n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n```\n\n### Explanation of the Code\n\n- **Initial Check**: We first check if the total length of matchsticks is divisible by 4. If not, return `False`.\n- **Sorting**: We sort the matchsticks in descending order to try larger matchsticks first, which helps in reducing the number of recursive calls.\n- **Backtracking**: We use a recursive function `backtrack` to attempt to place each matchstick into one of the four sides. If a matchstick can fit into a side without exceeding the target length, we place it and move to the next matchstick.\n- **Base Case**: If all matchsticks are placed and all sides are equal to the target length, we return `True`. If a configuration doesn't work, we backtrack and try a different configuration.",
    "no_parent": false,
    "dependency_used": false
}