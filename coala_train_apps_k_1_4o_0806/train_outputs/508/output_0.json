{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: 4 6\n1 3 2\n7 13 10\n18 20 13\n3 4 2\n0\n1\n2\n3\n5\n8\n Expected output: [{'2'}, {'2'}, {'10'}, {'-1'}, {'13'}, {'-1'}] # Execution output: []\nNo output detected. You might want to check the reading from / writing to standard IO.\nA common mistake is to put the IO inside a function, but the function is not called.\n",
    "code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    Q = int(data[index])\n    index += 1\n    \n    events = []\n    \n    for _ in range(N):\n        S = int(data[index])\n        T = int(data[index + 1])\n        X = int(data[index + 2])\n        index += 3\n        events.append((S - 0.5, 'start', X))\n        events.append((T - 0.5, 'end', X))\n    \n    D = []\n    for _ in range(Q):\n        D.append(int(data[index]))\n        index += 1\n    \n    events.sort()\n    \n    blocked_points = set()\n    results = []\n    event_index = 0\n    \n    for d in D:\n        while event_index < len(events) and events[event_index][0] <= d:\n            time, event_type, x = events[event_index]\n            if event_type == 'start':\n                blocked_points.add(x)\n            elif event_type == 'end':\n                blocked_points.discard(x)\n            event_index += 1\n        \n        position = 0\n        time = d\n        \n        while True:\n            if position in blocked_points:\n                results.append(position)\n                break\n            if event_index >= len(events):\n                results.append(-1)\n                break\n            next_event_time = events[event_index][0]\n            position += (next_event_time - time)\n            time = next_event_time\n            \n            while event_index < len(events) and events[event_index][0] == time:\n                _, event_type, x = events[event_index]\n                if event_type == 'start':\n                    blocked_points.add(x)\n                elif event_type == 'end':\n                    blocked_points.discard(x)\n                event_index += 1\n    \n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\n",
    "full_code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    Q = int(data[index])\n    index += 1\n    \n    events = []\n    \n    for _ in range(N):\n        S = int(data[index])\n        T = int(data[index + 1])\n        X = int(data[index + 2])\n        index += 3\n        events.append((S - 0.5, 'start', X))\n        events.append((T - 0.5, 'end', X))\n    \n    D = []\n    for _ in range(Q):\n        D.append(int(data[index]))\n        index += 1\n    \n    events.sort()\n    \n    blocked_points = set()\n    results = []\n    event_index = 0\n    \n    for d in D:\n        while event_index < len(events) and events[event_index][0] <= d:\n            time, event_type, x = events[event_index]\n            if event_type == 'start':\n                blocked_points.add(x)\n            elif event_type == 'end':\n                blocked_points.discard(x)\n            event_index += 1\n        \n        position = 0\n        time = d\n        \n        while True:\n            if position in blocked_points:\n                results.append(position)\n                break\n            if event_index >= len(events):\n                results.append(-1)\n                break\n            next_event_time = events[event_index][0]\n            position += (next_event_time - time)\n            time = next_event_time\n            \n            while event_index < len(events) and events[event_index][0] == time:\n                _, event_type, x = events[event_index]\n                if event_type == 'start':\n                    blocked_points.add(x)\n                elif event_type == 'end':\n                    blocked_points.discard(x)\n                event_index += 1\n    \n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\n",
    "reward": false,
    "program_code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    Q = int(data[index])\n    index += 1\n    \n    events = []\n    \n    for _ in range(N):\n        S = int(data[index])\n        T = int(data[index + 1])\n        X = int(data[index + 2])\n        index += 3\n        events.append((S - 0.5, 'start', X))\n        events.append((T - 0.5, 'end', X))\n    \n    D = []\n    for _ in range(Q):\n        D.append(int(data[index]))\n        index += 1\n    \n    events.sort()\n    \n    blocked_points = set()\n    results = []\n    event_index = 0\n    \n    for d in D:\n        while event_index < len(events) and events[event_index][0] <= d:\n            time, event_type, x = events[event_index]\n            if event_type == 'start':\n                blocked_points.add(x)\n            elif event_type == 'end':\n                blocked_points.discard(x)\n            event_index += 1\n        \n        position = 0\n        time = d\n        \n        while True:\n            if position in blocked_points:\n                results.append(position)\n                break\n            if event_index >= len(events):\n                results.append(-1)\n                break\n            next_event_time = events[event_index][0]\n            position += (next_event_time - time)\n            time = next_event_time\n            \n            while event_index < len(events) and events[event_index][0] == time:\n                _, event_type, x = events[event_index]\n                if event_type == 'start':\n                    blocked_points.add(x)\n                elif event_type == 'end':\n                    blocked_points.discard(x)\n                event_index += 1\n    \n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\n",
    "program_name": "solve",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe have a street represented as a number line with several roadworks scheduled at specific points. Each roadwork blocks a point on the number line for a given time interval. Multiple people start walking from the origin at different times, moving eastward at a constant speed. Each person stops walking when they reach a blocked point. We need to determine the distance each person walks before stopping or if they walk indefinitely.\n\n### Conceptual Solution\n\n1. **Input Parsing**: First, parse the input to get the number of roadworks and people. Then, gather the details of each roadwork and the start times for each person.\n\n2. **Event Creation**: For each roadwork, create two events: one for the start of the roadwork and one for the end. These events will help us track when a point becomes blocked and unblocked.\n\n3. **Event Sorting**: Sort all events by time. This allows us to process the events in chronological order, updating the status of blocked points as we go.\n\n4. **Simulate Walking**: For each person, simulate their walk:\n   - Start at the origin and move eastward.\n   - Check if the current position is blocked at the current time.\n   - If blocked, record the distance walked and stop.\n   - If not blocked and no more events are left, the person walks indefinitely.\n\n5. **Output**: For each person, output the distance walked or -1 if they walk indefinitely.\n\n### Pseudocode\n\n```\nfunction solve():\n    read N, Q\n    roadworks = []\n    for i from 1 to N:\n        read S_i, T_i, X_i\n        add (S_i - 0.5, 'start', X_i) to roadworks\n        add (T_i - 0.5, 'end', X_i) to roadworks\n\n    read D_1, D_2, ..., D_Q\n\n    sort roadworks by time\n\n    blocked_points = empty set\n    results = []\n\n    for each D_i in D_1, D_2, ..., D_Q:\n        while there are events and event time <= D_i:\n            process event:\n                if event is 'start':\n                    add X_i to blocked_points\n                else if event is 'end':\n                    remove X_i from blocked_points\n\n        position = 0\n        time = D_i\n        while true:\n            if position in blocked_points:\n                results.append(position)\n                break\n            if no more events:\n                results.append(-1)\n                break\n            move to next event time\n            position += (next event time - time)\n            time = next event time\n\n    print each result in results\n```\n\n### Final Python Solution\n\n```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    Q = int(data[index])\n    index += 1\n    \n    events = []\n    \n    for _ in range(N):\n        S = int(data[index])\n        T = int(data[index + 1])\n        X = int(data[index + 2])\n        index += 3\n        events.append((S - 0.5, 'start', X))\n        events.append((T - 0.5, 'end', X))\n    \n    D = []\n    for _ in range(Q):\n        D.append(int(data[index]))\n        index += 1\n    \n    events.sort()\n    \n    blocked_points = set()\n    results = []\n    event_index = 0\n    \n    for d in D:\n        while event_index < len(events) and events[event_index][0] <= d:\n            time, event_type, x = events[event_index]\n            if event_type == 'start':\n                blocked_points.add(x)\n            elif event_type == 'end':\n                blocked_points.discard(x)\n            event_index += 1\n        \n        position = 0\n        time = d\n        \n        while True:\n            if position in blocked_points:\n                results.append(position)\n                break\n            if event_index >= len(events):\n                results.append(-1)\n                break\n            next_event_time = events[event_index][0]\n            position += (next_event_time - time)\n            time = next_event_time\n            \n            while event_index < len(events) and events[event_index][0] == time:\n                _, event_type, x = events[event_index]\n                if event_type == 'start':\n                    blocked_points.add(x)\n                elif event_type == 'end':\n                    blocked_points.discard(x)\n                event_index += 1\n    \n    sys.stdout.write('\\n'.join(map(str, results)) + '\\n')\n\n```",
    "no_parent": false,
    "dependency_used": false
}