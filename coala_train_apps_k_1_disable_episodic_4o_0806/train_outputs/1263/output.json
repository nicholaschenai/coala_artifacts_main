{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['2', '4 1', '38 2'] Output: 2\n1\n\nTests failed:\nNone",
    "code": "\ndef countWays(N, K):\n    def explore(current_sum, start):\n        if current_sum == N:\n            return 1\n        if current_sum > N:\n            return 0\n        ways = 0\n        for i in range(start, N + 1):\n            power = i ** K\n            if current_sum + power <= N:\n                ways += explore(current_sum + power, i + 1)\n        return ways\n\n    return explore(0, 1)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    T = int(data[0])\n    index = 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        results.append(str(countWays(N, K)))\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nmain()\n",
    "full_code": "\ndef countWays(N, K):\n    def explore(current_sum, start):\n        if current_sum == N:\n            return 1\n        if current_sum > N:\n            return 0\n        ways = 0\n        for i in range(start, N + 1):\n            power = i ** K\n            if current_sum + power <= N:\n                ways += explore(current_sum + power, i + 1)\n        return ways\n\n    return explore(0, 1)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    T = int(data[0])\n    index = 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        results.append(str(countWays(N, K)))\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nmain()\n",
    "reward": true,
    "program_code": "\ndef countWays(N, K):\n    def explore(current_sum, start):\n        if current_sum == N:\n            return 1\n        if current_sum > N:\n            return 0\n        ways = 0\n        for i in range(start, N + 1):\n            power = i ** K\n            if current_sum + power <= N:\n                ways += explore(current_sum + power, i + 1)\n        return ways\n\n    return explore(0, 1)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    T = int(data[0])\n    index = 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        results.append(str(countWays(N, K)))\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nmain()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe need to determine the number of ways to express a given natural number \\( N \\) as the sum of unique positive integers raised to the power \\( K \\). Each test case provides values for \\( N \\) and \\( K \\), and we need to output the number of unique ways for each test case.\n\n### Conceptual Solution\n\n1. **Understanding the Problem**: We need to find combinations of unique integers such that their \\( K \\)-th powers sum up to \\( N \\).\n\n2. **Recursive Approach**: We can use a recursive function to explore all possible combinations of integers. For each integer, we decide whether to include it in the current combination or not. We ensure that each combination consists of unique integers.\n\n3. **Backtracking**: Use backtracking to explore all possible combinations. Start with the smallest integer and try to build up to \\( N \\) using its \\( K \\)-th power. If a combination exceeds \\( N \\), backtrack and try the next possibility.\n\n4. **Base Cases**:\n   - If the sum of the current combination equals \\( N \\), count it as a valid way.\n   - If the sum exceeds \\( N \\), stop exploring that path.\n\n5. **Optimization**: Use memoization to store results of subproblems to avoid redundant calculations.\n\n### Pseudocode\n\n```\nfunction countWays(N, K):\n    define a recursive function explore(current_sum, start):\n        if current_sum == N:\n            return 1\n        if current_sum > N:\n            return 0\n        ways = 0\n        for i from start to N:\n            power = i^K\n            if current_sum + power <= N:\n                ways += explore(current_sum + power, i + 1)\n        return ways\n\n    return explore(0, 1)\n\nread T\nfor each test case:\n    read N, K\n    print countWays(N, K)\n```\n\n### Python Code\n\n```python\ndef countWays(N, K):\n    def explore(current_sum, start):\n        if current_sum == N:\n            return 1\n        if current_sum > N:\n            return 0\n        ways = 0\n        for i in range(start, N + 1):\n            power = i ** K\n            if current_sum + power <= N:\n                ways += explore(current_sum + power, i + 1)\n        return ways\n\n    return explore(0, 1)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    T = int(data[0])\n    index = 1\n    results = []\n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        results.append(str(countWays(N, K)))\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nmain()\n```\n\n### Explanation\n\n- **Recursive Function**: `explore` is a recursive function that attempts to build combinations of integers whose \\( K \\)-th powers sum to \\( N \\).\n- **Base Cases**: If the current sum equals \\( N \\), it counts as a valid combination. If it exceeds \\( N \\), it stops further exploration.\n- **Loop**: The loop iterates over possible integers starting from `start` to ensure uniqueness in combinations.\n- **Main Function**: Reads input, processes each test case, and outputs the result using the `countWays` function.",
    "no_parent": false,
    "dependency_used": false
}