{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['1', '3 3', '1 2', '2 1', '3 2'] Expected output: [{'0'}, {'2'}, {'2'}] # Execution output: []\nNo output detected. You might want to check the reading from / writing to standard IO.\nA common mistake is to put the IO inside a function, but the function is not called.\n",
    "code": "\nMOD = 10**9 + 7\n\ndef mod_inv(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef precompute_factorials(n, mod):\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    inv_fact[n] = mod_inv(fact[n], mod)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    return fact, inv_fact\n\ndef combination(n, k, fact, inv_fact, mod):\n    if k > n or k < 0:\n        return 0\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    max_n = 4000\n    fact, inv_fact = precompute_factorials(max_n, MOD)\n    \n    for _ in range(T):\n        N = int(data[index])\n        Q = int(data[index + 1])\n        index += 2\n        \n        for __ in range(Q):\n            I = int(data[index])\n            K = int(data[index + 1])\n            index += 2\n            \n            if K > I:\n                results.append(0)\n            else:\n                ways_to_choose_before_I = combination(I - 1, K - 1, fact, inv_fact, MOD)\n                ways_to_choose_after_I = pow(2, N - I, MOD)\n                result = ways_to_choose_before_I * ways_to_choose_after_I % MOD\n                results.append(result)\n    \n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\n",
    "full_code": "\nMOD = 10**9 + 7\n\ndef mod_inv(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef precompute_factorials(n, mod):\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    inv_fact[n] = mod_inv(fact[n], mod)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    return fact, inv_fact\n\ndef combination(n, k, fact, inv_fact, mod):\n    if k > n or k < 0:\n        return 0\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    max_n = 4000\n    fact, inv_fact = precompute_factorials(max_n, MOD)\n    \n    for _ in range(T):\n        N = int(data[index])\n        Q = int(data[index + 1])\n        index += 2\n        \n        for __ in range(Q):\n            I = int(data[index])\n            K = int(data[index + 1])\n            index += 2\n            \n            if K > I:\n                results.append(0)\n            else:\n                ways_to_choose_before_I = combination(I - 1, K - 1, fact, inv_fact, MOD)\n                ways_to_choose_after_I = pow(2, N - I, MOD)\n                result = ways_to_choose_before_I * ways_to_choose_after_I % MOD\n                results.append(result)\n    \n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\n",
    "reward": false,
    "program_code": "\nMOD = 10**9 + 7\n\ndef mod_inv(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef precompute_factorials(n, mod):\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    inv_fact[n] = mod_inv(fact[n], mod)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    return fact, inv_fact\n\ndef combination(n, k, fact, inv_fact, mod):\n    if k > n or k < 0:\n        return 0\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    max_n = 4000\n    fact, inv_fact = precompute_factorials(max_n, MOD)\n    \n    for _ in range(T):\n        N = int(data[index])\n        Q = int(data[index + 1])\n        index += 2\n        \n        for __ in range(Q):\n            I = int(data[index])\n            K = int(data[index + 1])\n            index += 2\n            \n            if K > I:\n                results.append(0)\n            else:\n                ways_to_choose_before_I = combination(I - 1, K - 1, fact, inv_fact, MOD)\n                ways_to_choose_after_I = pow(2, N - I, MOD)\n                result = ways_to_choose_before_I * ways_to_choose_after_I % MOD\n                results.append(result)\n    \n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\n",
    "program_name": "solve",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe are given a set of natural numbers from 1 to N. For each query, we need to determine the number of subsets where a specific number `I` appears at the `K`-th position when the subset is sorted. The result should be given modulo \\(10^9 + 7\\).\n\n## Conceptual Solution\n\n1. **Understanding Subsets**: For a number `I` to be at the `K`-th position in a sorted subset, there must be exactly `K-1` numbers smaller than `I` in the subset. This means we need to choose `K-1` numbers from the set `{1, 2, ..., I-1}`.\n\n2. **Remaining Numbers**: After placing `I` at the `K`-th position, the remaining numbers in the subset can be chosen from the set `{I+1, I+2, ..., N}`. The number of such subsets is determined by the number of ways to choose any subset from these numbers.\n\n3. **Combinatorial Counting**: \n   - Use combinations to count the number of ways to choose `K-1` numbers from `I-1` numbers.\n   - Use powers of 2 to count the number of subsets that can be formed from the remaining numbers.\n\n4. **Modulo Arithmetic**: Since the result can be large, compute all results modulo \\(10^9 + 7\\).\n\n## Pseudocode\n\n1. Precompute factorials and inverse factorials up to `N` for efficient combination calculations.\n2. For each query:\n   - If `K > I`, output 0 (since `I` cannot be at the `K`-th position).\n   - Otherwise, calculate the number of ways to choose `K-1` numbers from `I-1`.\n   - Calculate the number of subsets from the remaining numbers.\n   - Multiply these two results and take modulo \\(10^9 + 7\\).\n3. Output the result for each query.\n\n## Final Python Solution\n\n```python\nMOD = 10**9 + 7\n\ndef mod_inv(x, mod):\n    return pow(x, mod - 2, mod)\n\ndef precompute_factorials(n, mod):\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n    for i in range(2, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n    inv_fact[n] = mod_inv(fact[n], mod)\n    for i in range(n - 1, 0, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % mod\n    return fact, inv_fact\n\ndef combination(n, k, fact, inv_fact, mod):\n    if k > n or k < 0:\n        return 0\n    return fact[n] * inv_fact[k] % mod * inv_fact[n - k] % mod\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    \n    results = []\n    \n    max_n = 4000\n    fact, inv_fact = precompute_factorials(max_n, MOD)\n    \n    for _ in range(T):\n        N = int(data[index])\n        Q = int(data[index + 1])\n        index += 2\n        \n        for __ in range(Q):\n            I = int(data[index])\n            K = int(data[index + 1])\n            index += 2\n            \n            if K > I:\n                results.append(0)\n            else:\n                ways_to_choose_before_I = combination(I - 1, K - 1, fact, inv_fact, MOD)\n                ways_to_choose_after_I = pow(2, N - I, MOD)\n                result = ways_to_choose_before_I * ways_to_choose_after_I % MOD\n                results.append(result)\n    \n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\n```\n\nThis solution efficiently handles the constraints by precomputing factorials and using combinatorial mathematics to determine the number of valid subsets for each query.",
    "no_parent": false,
    "dependency_used": false
}