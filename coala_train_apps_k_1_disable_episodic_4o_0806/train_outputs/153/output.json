{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: [[2, 2, 2, 1, 1]] Output: True\n\nTests failed:\nNone",
    "code": "\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums:\n            return False\n        \n        total_length = sum(nums)\n        if total_length % 4 != 0:\n            return False\n        \n        target_side_length = total_length // 4\n        nums.sort(reverse=True)\n        \n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target_side_length for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target_side_length:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n",
    "full_code": "\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums:\n            return False\n        \n        total_length = sum(nums)\n        if total_length % 4 != 0:\n            return False\n        \n        target_side_length = total_length // 4\n        nums.sort(reverse=True)\n        \n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target_side_length for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target_side_length:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n",
    "reward": true,
    "program_code": "\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums:\n            return False\n        \n        total_length = sum(nums)\n        if total_length % 4 != 0:\n            return False\n        \n        target_side_length = total_length // 4\n        nums.sort(reverse=True)\n        \n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target_side_length for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target_side_length:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n",
    "program_name": "",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe need to determine if we can use all given matchsticks to form a square. Each matchstick can only be used once, and we cannot break any matchstick. The goal is to see if we can arrange the matchsticks such that they form a square with equal sides.\n\n### Conceptual Solution\n\n1. **Check Total Length**: First, calculate the total length of all matchsticks. If this total is not divisible by 4, it's impossible to form a square, so we return `False`.\n\n2. **Target Side Length**: If the total length is divisible by 4, the target length for each side of the square is `total_length / 4`.\n\n3. **Backtracking Approach**: Use a backtracking approach to try and form the square:\n   - Sort the matchsticks in descending order to optimize the process (larger sticks are harder to place, so try them first).\n   - Attempt to place each matchstick into one of the four sides.\n   - Use a recursive function to try placing each matchstick and backtrack if a configuration doesn't work.\n\n4. **Base Case**: If all matchsticks are placed successfully such that each side equals the target length, return `True`.\n\n5. **Pruning**: If at any point a side exceeds the target length, backtrack immediately.\n\n### Pseudocode\n\n```\nfunction makesquare(nums):\n    if nums is empty, return False\n    total_length = sum(nums)\n    if total_length % 4 != 0, return False\n    target_side_length = total_length / 4\n    sort nums in descending order\n    initialize sides as [0, 0, 0, 0]\n    \n    function backtrack(index):\n        if index == length of nums:\n            return all sides are equal to target_side_length\n        for each side in sides:\n            if side + nums[index] <= target_side_length:\n                add nums[index] to side\n                if backtrack(index + 1) is True, return True\n                remove nums[index] from side\n        return False\n    \n    return backtrack(0)\n```\n\n### Final Python Solution\n\n```python\nfrom typing import List\n\nclass Solution:\n    def makesquare(self, nums: List[int]) -> bool:\n        if not nums:\n            return False\n        \n        total_length = sum(nums)\n        if total_length % 4 != 0:\n            return False\n        \n        target_side_length = total_length // 4\n        nums.sort(reverse=True)\n        \n        sides = [0] * 4\n        \n        def backtrack(index):\n            if index == len(nums):\n                return all(side == target_side_length for side in sides)\n            \n            for i in range(4):\n                if sides[i] + nums[index] <= target_side_length:\n                    sides[i] += nums[index]\n                    if backtrack(index + 1):\n                        return True\n                    sides[i] -= nums[index]\n            \n            return False\n        \n        return backtrack(0)\n```\n\nThis solution uses a backtracking approach to try and fit each matchstick into one of the four sides of the square, ensuring that each side reaches the target length. The matchsticks are sorted in descending order to optimize the placement process.",
    "no_parent": false,
    "dependency_used": false
}