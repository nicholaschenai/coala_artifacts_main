{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['3 2', '3 1 2', '2 3 1', ''] Output: 3 2 1\n3 1 2 \n\nTests failed:\nNone",
    "code": "\ndef next_permutation(perm):\n    # Find the longest non-increasing suffix\n    n = len(perm)\n    i = n - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If the entire sequence is non-increasing, it's the last permutation\n    if i == -1:\n        perm.reverse()\n        return perm\n    \n    # Find the rightmost element that exceeds perm[i]\n    j = n - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap the found element with perm[i]\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse the suffix\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read N and K\n    N = int(data[0])\n    K = int(data[1])\n    \n    index = 2\n    results = []\n    \n    # Process each permutation\n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        # Get the next permutation\n        next_perm = next_permutation(permutation)\n        # Append the result as a space-separated string\n        results.append(\" \".join(map(str, next_perm)))\n    \n    # Print all results, each on a new line\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nmain()\n",
    "full_code": "\ndef next_permutation(perm):\n    # Find the longest non-increasing suffix\n    n = len(perm)\n    i = n - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If the entire sequence is non-increasing, it's the last permutation\n    if i == -1:\n        perm.reverse()\n        return perm\n    \n    # Find the rightmost element that exceeds perm[i]\n    j = n - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap the found element with perm[i]\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse the suffix\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read N and K\n    N = int(data[0])\n    K = int(data[1])\n    \n    index = 2\n    results = []\n    \n    # Process each permutation\n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        # Get the next permutation\n        next_perm = next_permutation(permutation)\n        # Append the result as a space-separated string\n        results.append(\" \".join(map(str, next_perm)))\n    \n    # Print all results, each on a new line\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nmain()\n",
    "reward": true,
    "program_code": "\ndef next_permutation(perm):\n    # Find the longest non-increasing suffix\n    n = len(perm)\n    i = n - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If the entire sequence is non-increasing, it's the last permutation\n    if i == -1:\n        perm.reverse()\n        return perm\n    \n    # Find the rightmost element that exceeds perm[i]\n    j = n - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap the found element with perm[i]\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse the suffix\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read N and K\n    N = int(data[0])\n    K = int(data[1])\n    \n    index = 2\n    results = []\n    \n    # Process each permutation\n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        # Get the next permutation\n        next_perm = next_permutation(permutation)\n        # Append the result as a space-separated string\n        results.append(\" \".join(map(str, next_perm)))\n    \n    # Print all results, each on a new line\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nmain()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n\n   We are given a number `N` and `K` permutations of numbers from `1` to `N`. For each permutation, we need to find the next permutation in lexicographic order. If the permutation is the last one in lexicographic order, we should wrap around to the first permutation.\n\n2. **Conceptualize a solution in plain English:**\n\n   To find the next permutation in lexicographic order, we can use the following steps:\n   - Identify the longest suffix that is non-increasing (i.e., find the rightmost position where the order breaks).\n   - If the entire sequence is non-increasing, it is the last permutation, so reverse it to get the first permutation.\n   - Otherwise, find the smallest element in the suffix that is larger than the element just before the suffix.\n   - Swap these two elements.\n   - Reverse the suffix to get the next permutation.\n\n3. **Write a pseudocode solution:**\n\n   ```\n   function next_permutation(perm):\n       n = length of perm\n       i = n - 2\n       while i >= 0 and perm[i] >= perm[i + 1]:\n           i -= 1\n       if i == -1:\n           reverse perm\n           return perm\n       j = n - 1\n       while perm[j] <= perm[i]:\n           j -= 1\n       swap perm[i] and perm[j]\n       reverse perm from i + 1 to end\n       return perm\n\n   function main():\n       read N and K\n       for each of the K permutations:\n           read permutation\n           result = next_permutation(permutation)\n           print result\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n\n```python\ndef next_permutation(perm):\n    # Find the longest non-increasing suffix\n    n = len(perm)\n    i = n - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If the entire sequence is non-increasing, it's the last permutation\n    if i == -1:\n        perm.reverse()\n        return perm\n    \n    # Find the rightmost element that exceeds perm[i]\n    j = n - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap the found element with perm[i]\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse the suffix\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return perm\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    # Read N and K\n    N = int(data[0])\n    K = int(data[1])\n    \n    index = 2\n    results = []\n    \n    # Process each permutation\n    for _ in range(K):\n        permutation = list(map(int, data[index:index + N]))\n        index += N\n        # Get the next permutation\n        next_perm = next_permutation(permutation)\n        # Append the result as a space-separated string\n        results.append(\" \".join(map(str, next_perm)))\n    \n    # Print all results, each on a new line\n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\nmain()\n```\n\nThis code reads the input, processes each permutation to find the next lexicographic permutation, and outputs the results. The `next_permutation` function implements the algorithm to find the next permutation in lexicographic order.",
    "no_parent": false,
    "dependency_used": false
}