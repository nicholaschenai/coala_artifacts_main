{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: 1\n10\n1 2\n1 3\n1 4\n2 5\n2 6\n3 7\n3 8\n4 9\n4 10\n Expected output: [{'8'}] # Execution output: ['5']",
    "code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    q = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import deque\n    \n    def bfs(start, n, adj):\n        visited = [-1] * (n + 1)\n        queue = deque([start])\n        visited[start] = 0\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if visited[neighbor] == -1:\n                    visited[neighbor] = visited[node] + 1\n                    queue.append(neighbor)\n                    if visited[neighbor] > max_distance:\n                        max_distance = visited[neighbor]\n                        farthest_node = neighbor\n        \n        return farthest_node, max_distance\n    \n    for _ in range(q):\n        n = int(data[index])\n        index += 1\n        adj = [[] for _ in range(n + 1)]\n        \n        for _ in range(n - 1):\n            x = int(data[index])\n            y = int(data[index + 1])\n            index += 2\n            adj[x].append(y)\n            adj[y].append(x)\n        \n        # Find the diameter of the tree\n        farthest_node, _ = bfs(1, n, adj)\n        _, diameter = bfs(farthest_node, n, adj)\n        \n        results.append(diameter + 1)\n    \n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\n# Call the solve function to execute the logic\nsolve()\n",
    "full_code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    q = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import deque\n    \n    def bfs(start, n, adj):\n        visited = [-1] * (n + 1)\n        queue = deque([start])\n        visited[start] = 0\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if visited[neighbor] == -1:\n                    visited[neighbor] = visited[node] + 1\n                    queue.append(neighbor)\n                    if visited[neighbor] > max_distance:\n                        max_distance = visited[neighbor]\n                        farthest_node = neighbor\n        \n        return farthest_node, max_distance\n    \n    for _ in range(q):\n        n = int(data[index])\n        index += 1\n        adj = [[] for _ in range(n + 1)]\n        \n        for _ in range(n - 1):\n            x = int(data[index])\n            y = int(data[index + 1])\n            index += 2\n            adj[x].append(y)\n            adj[y].append(x)\n        \n        # Find the diameter of the tree\n        farthest_node, _ = bfs(1, n, adj)\n        _, diameter = bfs(farthest_node, n, adj)\n        \n        results.append(diameter + 1)\n    \n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\n# Call the solve function to execute the logic\nsolve()\n",
    "reward": false,
    "program_code": "\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    q = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import deque\n    \n    def bfs(start, n, adj):\n        visited = [-1] * (n + 1)\n        queue = deque([start])\n        visited[start] = 0\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if visited[neighbor] == -1:\n                    visited[neighbor] = visited[node] + 1\n                    queue.append(neighbor)\n                    if visited[neighbor] > max_distance:\n                        max_distance = visited[neighbor]\n                        farthest_node = neighbor\n        \n        return farthest_node, max_distance\n    \n    for _ in range(q):\n        n = int(data[index])\n        index += 1\n        adj = [[] for _ in range(n + 1)]\n        \n        for _ in range(n - 1):\n            x = int(data[index])\n            y = int(data[index + 1])\n            index += 2\n            adj[x].append(y)\n            adj[y].append(x)\n        \n        # Find the diameter of the tree\n        farthest_node, _ = bfs(1, n, adj)\n        _, diameter = bfs(farthest_node, n, adj)\n        \n        results.append(diameter + 1)\n    \n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\n# Call the solve function to execute the logic\nsolve()\n",
    "program_name": "solve",
    "dependencies": [],
    "raw_msg": "```python\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    q = int(data[index])\n    index += 1\n    results = []\n    \n    from collections import deque\n    \n    def bfs(start, n, adj):\n        visited = [-1] * (n + 1)\n        queue = deque([start])\n        visited[start] = 0\n        farthest_node = start\n        max_distance = 0\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in adj[node]:\n                if visited[neighbor] == -1:\n                    visited[neighbor] = visited[node] + 1\n                    queue.append(neighbor)\n                    if visited[neighbor] > max_distance:\n                        max_distance = visited[neighbor]\n                        farthest_node = neighbor\n        \n        return farthest_node, max_distance\n    \n    for _ in range(q):\n        n = int(data[index])\n        index += 1\n        adj = [[] for _ in range(n + 1)]\n        \n        for _ in range(n - 1):\n            x = int(data[index])\n            y = int(data[index + 1])\n            index += 2\n            adj[x].append(y)\n            adj[y].append(x)\n        \n        # Find the diameter of the tree\n        farthest_node, _ = bfs(1, n, adj)\n        _, diameter = bfs(farthest_node, n, adj)\n        \n        results.append(diameter + 1)\n    \n    sys.stdout.write(\"\\n\".join(map(str, results)) + \"\\n\")\n\n# Call the solve function to execute the logic\nsolve()\n```",
    "no_parent": false,
    "dependency_used": false
}