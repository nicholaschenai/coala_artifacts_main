{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['10 3', '1', '3', '7', '6', '-1', '5', '-1', '18', '9', '11', '2', '-1', '4'] Output: 7\n6\n18\n\nTests failed:\nNone",
    "code": "\nimport sys\nimport heapq\n\ndef process_events():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    events = data[2:]\n    \n    max_heap = []\n    results = []\n    \n    for event in events:\n        if event != '-1':\n            # Convert the wealth to an integer and push its negative to simulate a max-heap\n            wealth = int(event)\n            heapq.heappush(max_heap, -wealth)\n        else:\n            # Pop the richest (which is the smallest negative number)\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n    \n    for result in results:\n        print(result)\n\nprocess_events()\n",
    "full_code": "\nimport sys\nimport heapq\n\ndef process_events():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    events = data[2:]\n    \n    max_heap = []\n    results = []\n    \n    for event in events:\n        if event != '-1':\n            # Convert the wealth to an integer and push its negative to simulate a max-heap\n            wealth = int(event)\n            heapq.heappush(max_heap, -wealth)\n        else:\n            # Pop the richest (which is the smallest negative number)\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n    \n    for result in results:\n        print(result)\n\nprocess_events()\n",
    "reward": true,
    "program_code": "\nimport sys\nimport heapq\n\ndef process_events():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    events = data[2:]\n    \n    max_heap = []\n    results = []\n    \n    for event in events:\n        if event != '-1':\n            # Convert the wealth to an integer and push its negative to simulate a max-heap\n            wealth = int(event)\n            heapq.heappush(max_heap, -wealth)\n        else:\n            # Pop the richest (which is the smallest negative number)\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n    \n    for result in results:\n        print(result)\n\nprocess_events()\n",
    "program_name": "process_events",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe have a sequence of events where citizens declare their wealth and the king visits the court. Each citizen's wealth is unique and represented by a positive integer. A king's visit is represented by `-1`. When the king visits, the richest citizen who has appeared so far and is still alive is beheaded. We need to determine the wealth of the citizen who is beheaded at each of the king's visits.\n\n## Conceptual Solution\n\n1. **Data Structure Choice**: Use a max-heap to efficiently track the richest citizen who is still alive. A max-heap allows us to quickly retrieve and remove the largest element.\n\n2. **Processing Events**:\n   - For each citizen's wealth declaration, add their wealth to the max-heap.\n   - For each king's visit (`-1`), remove the richest citizen from the heap and record their wealth as they are beheaded.\n\n3. **Handling the Max-Heap**: Since Python's `heapq` is a min-heap by default, we can simulate a max-heap by inserting negative values.\n\n## Pseudocode\n\n```\nfunction process_events(events):\n    initialize an empty max-heap (using a list)\n    initialize an empty list for results\n\n    for each event in events:\n        if event is a positive integer (citizen's wealth):\n            push the negative of the event into the max-heap\n        else if event is -1 (king's visit):\n            pop the smallest element from the max-heap (which is the largest wealth)\n            append the negative of this value to the results list\n\n    return results\n```\n\n## Python Solution\n\n```python\nimport sys\nimport heapq\n\ndef process_events():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    events = data[2:]\n    \n    max_heap = []\n    results = []\n    \n    for event in events:\n        if event != '-1':\n            # Convert the wealth to an integer and push its negative to simulate a max-heap\n            wealth = int(event)\n            heapq.heappush(max_heap, -wealth)\n        else:\n            # Pop the richest (which is the smallest negative number)\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n    \n    for result in results:\n        print(result)\n\nprocess_events()\n```\n\n### Explanation\n\n- **Heap Operations**: We use `heapq.heappush` to add elements to the heap and `heapq.heappop` to remove the smallest element. By storing negative values, we effectively turn the min-heap into a max-heap.\n- **Event Processing**: We iterate over each event, adding wealth to the heap or processing a king's visit by removing the richest citizen.\n- **Output**: After processing all events, we print the wealth of each beheaded citizen in the order of the king's visits.",
    "no_parent": false,
    "dependency_used": false
}