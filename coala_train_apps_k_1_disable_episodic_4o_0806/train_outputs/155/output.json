{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: [[6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2] Output: 4\n\nTests failed:\nNone",
    "code": "\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        # Initialize dp array where each index can visit itself\n        dp = [1] * len(arr)\n        \n        # Sort indices based on the values in arr to ensure we process in increasing order of values\n        indices = sorted(range(len(arr)), key=lambda i: arr[i])\n        \n        # Process each index in the order of increasing values\n        for i in indices:\n            # Check forward jumps\n            for x in range(1, d + 1):\n                if i + x < len(arr) and arr[i] > arr[i + x]:\n                    dp[i] = max(dp[i], 1 + dp[i + x])\n                else:\n                    break  # Stop if we can't jump further\n            \n            # Check backward jumps\n            for x in range(1, d + 1):\n                if i - x >= 0 and arr[i] > arr[i - x]:\n                    dp[i] = max(dp[i], 1 + dp[i - x])\n                else:\n                    break  # Stop if we can't jump further\n        \n        # Return the maximum number of indices that can be visited\n        return max(dp)\n",
    "full_code": "\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        # Initialize dp array where each index can visit itself\n        dp = [1] * len(arr)\n        \n        # Sort indices based on the values in arr to ensure we process in increasing order of values\n        indices = sorted(range(len(arr)), key=lambda i: arr[i])\n        \n        # Process each index in the order of increasing values\n        for i in indices:\n            # Check forward jumps\n            for x in range(1, d + 1):\n                if i + x < len(arr) and arr[i] > arr[i + x]:\n                    dp[i] = max(dp[i], 1 + dp[i + x])\n                else:\n                    break  # Stop if we can't jump further\n            \n            # Check backward jumps\n            for x in range(1, d + 1):\n                if i - x >= 0 and arr[i] > arr[i - x]:\n                    dp[i] = max(dp[i], 1 + dp[i - x])\n                else:\n                    break  # Stop if we can't jump further\n        \n        # Return the maximum number of indices that can be visited\n        return max(dp)\n",
    "reward": true,
    "program_code": "\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        # Initialize dp array where each index can visit itself\n        dp = [1] * len(arr)\n        \n        # Sort indices based on the values in arr to ensure we process in increasing order of values\n        indices = sorted(range(len(arr)), key=lambda i: arr[i])\n        \n        # Process each index in the order of increasing values\n        for i in indices:\n            # Check forward jumps\n            for x in range(1, d + 1):\n                if i + x < len(arr) and arr[i] > arr[i + x]:\n                    dp[i] = max(dp[i], 1 + dp[i + x])\n                else:\n                    break  # Stop if we can't jump further\n            \n            # Check backward jumps\n            for x in range(1, d + 1):\n                if i - x >= 0 and arr[i] > arr[i - x]:\n                    dp[i] = max(dp[i], 1 + dp[i - x])\n                else:\n                    break  # Stop if we can't jump further\n        \n        # Return the maximum number of indices that can be visited\n        return max(dp)\n",
    "program_name": "",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n\n   We are given an array of integers and a maximum jump distance `d`. Starting from any index in the array, we can jump to another index if the value at the starting index is greater than the value at the destination index, and all values between these indices are also smaller than the starting index value. We can jump either forward or backward, but the jump distance cannot exceed `d`. The task is to determine the maximum number of indices we can visit by making such jumps.\n\n2. **Conceptualize a solution in plain English:**\n\n   To solve this problem, we can use dynamic programming. We will maintain an array `dp` where `dp[i]` represents the maximum number of indices that can be visited starting from index `i`. We will iterate over each index and calculate the possible jumps both forward and backward within the allowed distance `d`. For each valid jump, we update the `dp` value for the current index based on the `dp` value of the destination index. The final answer will be the maximum value in the `dp` array.\n\n3. **Write a pseudocode solution:**\n\n   ```\n   Initialize dp array with all elements set to 1 (each index can visit itself)\n   For each index i in the array:\n       For each possible jump distance x from 1 to d:\n           Check forward jump (i + x):\n               If i + x is within bounds and arr[i] > arr[i + x]:\n                   Update dp[i] = max(dp[i], 1 + dp[i + x])\n               Else break (since we can't jump further)\n           Check backward jump (i - x):\n               If i - x is within bounds and arr[i] > arr[i - x]:\n                   Update dp[i] = max(dp[i], 1 + dp[i - x])\n               Else break (since we can't jump further)\n   Return the maximum value in the dp array\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n\n```python\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        # Initialize dp array where each index can visit itself\n        dp = [1] * len(arr)\n        \n        # Sort indices based on the values in arr to ensure we process in increasing order of values\n        indices = sorted(range(len(arr)), key=lambda i: arr[i])\n        \n        # Process each index in the order of increasing values\n        for i in indices:\n            # Check forward jumps\n            for x in range(1, d + 1):\n                if i + x < len(arr) and arr[i] > arr[i + x]:\n                    dp[i] = max(dp[i], 1 + dp[i + x])\n                else:\n                    break  # Stop if we can't jump further\n            \n            # Check backward jumps\n            for x in range(1, d + 1):\n                if i - x >= 0 and arr[i] > arr[i - x]:\n                    dp[i] = max(dp[i], 1 + dp[i - x])\n                else:\n                    break  # Stop if we can't jump further\n        \n        # Return the maximum number of indices that can be visited\n        return max(dp)\n```\n\nThis solution uses dynamic programming to calculate the maximum number of indices that can be visited starting from each index, considering both forward and backward jumps within the allowed distance `d`. The final result is the maximum value in the `dp` array.",
    "no_parent": false,
    "dependency_used": false
}