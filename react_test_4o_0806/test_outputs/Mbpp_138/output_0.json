{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert is_Sum_Of_Powers_Of_Two(10) == True\n\nTests failed:\nNone",
    "code": "\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    # If the number is less than or equal to 0, it cannot be represented as a sum of positive powers of 2\n    if n <= 0:\n        return False\n    \n    # While n is greater than 0, check each bit\n    while n > 0:\n        # If the least significant bit is 1, it means this bit contributes to the sum\n        if n % 2 == 1:\n            # Subtract 1 to remove the contribution of this power of 2\n            n -= 1\n        # Divide n by 2 to shift right and check the next bit\n        n //= 2\n    \n    # If we can reduce n to 0 by subtracting powers of 2, return True\n    return True\n",
    "full_code": "\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    # If the number is less than or equal to 0, it cannot be represented as a sum of positive powers of 2\n    if n <= 0:\n        return False\n    \n    # While n is greater than 0, check each bit\n    while n > 0:\n        # If the least significant bit is 1, it means this bit contributes to the sum\n        if n % 2 == 1:\n            # Subtract 1 to remove the contribution of this power of 2\n            n -= 1\n        # Divide n by 2 to shift right and check the next bit\n        n //= 2\n    \n    # If we can reduce n to 0 by subtracting powers of 2, return True\n    return True\n",
    "reward": true,
    "program_code": "\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    # If the number is less than or equal to 0, it cannot be represented as a sum of positive powers of 2\n    if n <= 0:\n        return False\n    \n    # While n is greater than 0, check each bit\n    while n > 0:\n        # If the least significant bit is 1, it means this bit contributes to the sum\n        if n % 2 == 1:\n            # Subtract 1 to remove the contribution of this power of 2\n            n -= 1\n        # Divide n by 2 to shift right and check the next bit\n        n //= 2\n    \n    # If we can reduce n to 0 by subtracting powers of 2, return True\n    return True\n",
    "program_name": "is_Sum_Of_Powers_Of_Two",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\n1. **Restate the problem in plain English:**\n\n   We need to determine if a given integer can be expressed as a sum of distinct powers of 2. For example, the number 10 can be expressed as \\(2^3 + 2^1\\) (which is 8 + 2), so the function should return `True` for 10.\n\n### Conceptualize a Solution\n\n2. **Conceptualize a solution in plain English:**\n\n   - A number can be represented as a sum of distinct powers of 2 if its binary representation consists only of 0s and 1s. Each '1' in the binary representation corresponds to a power of 2 that contributes to the sum.\n   - For example, the binary representation of 10 is `1010`, which corresponds to \\(2^3 + 2^1\\).\n   - Therefore, to solve the problem, we can convert the number to its binary form and check if it consists only of 0s and 1s. If it does, the number can be represented as a sum of distinct powers of 2.\n\n### Pseudocode\n\n3. **Write a pseudocode solution:**\n\n   ```\n   function is_Sum_Of_Powers_Of_Two(n):\n       if n is less than or equal to 0:\n           return False\n       while n is greater than 0:\n           if n is odd:\n               subtract 1 from n\n           else:\n               divide n by 2\n       return True\n   ```\n\n### Final Python Solution\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n\n```python\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    # If the number is less than or equal to 0, it cannot be represented as a sum of positive powers of 2\n    if n <= 0:\n        return False\n    \n    # While n is greater than 0, check each bit\n    while n > 0:\n        # If the least significant bit is 1, it means this bit contributes to the sum\n        if n % 2 == 1:\n            # Subtract 1 to remove the contribution of this power of 2\n            n -= 1\n        # Divide n by 2 to shift right and check the next bit\n        n //= 2\n    \n    # If we can reduce n to 0 by subtracting powers of 2, return True\n    return True\n```\n\nThis solution iteratively checks each bit of the number by using modulo and division operations, effectively simulating the process of checking the binary representation of the number. If the number can be reduced to zero by subtracting powers of 2, it returns `True`.",
    "no_parent": true,
    "dependency_used": false
}