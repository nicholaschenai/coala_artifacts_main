{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nNone\n\nTests failed:\nassert find_solution(2, 3, 7) == (2, 1) # output: (-7, 7)",
    "code": "\ndef extended_gcd(a, b):\n    # Base case: if b is 0, gcd is a, and coefficients are (1, 0)\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        # Recursive call\n        gcd, x1, y1 = extended_gcd(b, a % b)\n        # Update x and y using results of recursion\n        x = y1\n        y = x1 - (a // b) * y1\n        return (gcd, x, y)\n\ndef find_solution(a, b, n):\n    # Get gcd and coefficients for the equation ax + by = gcd(a, b)\n    gcd, x0, y0 = extended_gcd(a, b)\n    # Check if n is divisible by gcd\n    if n % gcd != 0:\n        return None\n    # Scale the solution to match the equation ax + by = n\n    scale = n // gcd\n    x = x0 * scale\n    y = y0 * scale\n    return (x, y)\n",
    "full_code": "\ndef extended_gcd(a, b):\n    # Base case: if b is 0, gcd is a, and coefficients are (1, 0)\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        # Recursive call\n        gcd, x1, y1 = extended_gcd(b, a % b)\n        # Update x and y using results of recursion\n        x = y1\n        y = x1 - (a // b) * y1\n        return (gcd, x, y)\n\ndef find_solution(a, b, n):\n    # Get gcd and coefficients for the equation ax + by = gcd(a, b)\n    gcd, x0, y0 = extended_gcd(a, b)\n    # Check if n is divisible by gcd\n    if n % gcd != 0:\n        return None\n    # Scale the solution to match the equation ax + by = n\n    scale = n // gcd\n    x = x0 * scale\n    y = y0 * scale\n    return (x, y)\n",
    "reward": false,
    "program_code": "\ndef extended_gcd(a, b):\n    # Base case: if b is 0, gcd is a, and coefficients are (1, 0)\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        # Recursive call\n        gcd, x1, y1 = extended_gcd(b, a % b)\n        # Update x and y using results of recursion\n        x = y1\n        y = x1 - (a // b) * y1\n        return (gcd, x, y)\n\ndef find_solution(a, b, n):\n    # Get gcd and coefficients for the equation ax + by = gcd(a, b)\n    gcd, x0, y0 = extended_gcd(a, b)\n    # Check if n is divisible by gcd\n    if n % gcd != 0:\n        return None\n    # Scale the solution to match the equation ax + by = n\n    scale = n // gcd\n    x = x0 * scale\n    y = y0 * scale\n    return (x, y)\n",
    "program_name": "find_solution",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe need to find two integers, \\( x \\) and \\( y \\), such that the equation \\( ax + by = n \\) holds true for given integers \\( a \\), \\( b \\), and \\( n \\). If such integers exist, we should return them as a tuple \\((x, y)\\). If no such integers exist, we should return `None`.\n\n### Conceptual Solution\n\n1. **Understanding the Equation**: The equation \\( ax + by = n \\) is a linear Diophantine equation. A solution exists if and only if the greatest common divisor (GCD) of \\( a \\) and \\( b \\) divides \\( n \\).\n\n2. **Finding a Solution**: If a solution exists, we can use the Extended Euclidean Algorithm to find one particular solution \\((x_0, y_0)\\) to the equation \\( ax + by = \\text{gcd}(a, b) \\). We can then scale this solution by \\( \\frac{n}{\\text{gcd}(a, b)} \\) to get a solution to \\( ax + by = n \\).\n\n3. **Algorithm Steps**:\n   - Compute the GCD of \\( a \\) and \\( b \\).\n   - Check if \\( n \\) is divisible by this GCD. If not, return `None`.\n   - Use the Extended Euclidean Algorithm to find one solution to \\( ax + by = \\text{gcd}(a, b) \\).\n   - Scale this solution to find a solution to \\( ax + by = n \\).\n\n### Pseudocode\n\n```\nfunction extended_gcd(a, b):\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        gcd, x1, y1 = extended_gcd(b, a % b)\n        x = y1\n        y = x1 - (a // b) * y1\n        return (gcd, x, y)\n\nfunction find_solution(a, b, n):\n    gcd, x0, y0 = extended_gcd(a, b)\n    if n % gcd != 0:\n        return None\n    scale = n // gcd\n    x = x0 * scale\n    y = y0 * scale\n    return (x, y)\n```\n\n### Final Python Solution\n\n```python\ndef extended_gcd(a, b):\n    # Base case: if b is 0, gcd is a, and coefficients are (1, 0)\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        # Recursive call\n        gcd, x1, y1 = extended_gcd(b, a % b)\n        # Update x and y using results of recursion\n        x = y1\n        y = x1 - (a // b) * y1\n        return (gcd, x, y)\n\ndef find_solution(a, b, n):\n    # Get gcd and coefficients for the equation ax + by = gcd(a, b)\n    gcd, x0, y0 = extended_gcd(a, b)\n    # Check if n is divisible by gcd\n    if n % gcd != 0:\n        return None\n    # Scale the solution to match the equation ax + by = n\n    scale = n // gcd\n    x = x0 * scale\n    y = y0 * scale\n    return (x, y)\n```\n\nThis code uses the Extended Euclidean Algorithm to find a solution to the linear Diophantine equation, ensuring that the solution is only returned if it exists.",
    "no_parent": true,
    "dependency_used": false
}