{"date": "2025-01-03 08:21", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/102": [{"task_id": "Mbpp/102", "solution": "\ndef snake_to_camel(s: str) -> str:\n    # Split the input string by underscores to get individual words\n    words = s.split('_')\n    # Capitalize the first letter of each word and join them together\n    camel_case = ''.join(word.capitalize() for word in words)\n    # Return the resulting CamelCase string\n    return camel_case\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["___python_program"]]}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "\ndef is_palindrome(n: int) -> bool:\n    # Convert the number to a string\n    s = str(n)\n    # Check if the string is equal to its reverse\n    return s == s[::-1]\n\ndef next_smallest_palindrome(n: int) -> int:\n    # Start with the number immediately greater than n\n    n += 1\n    # Continuously check for the next palindrome\n    while True:\n        # Check if the current number is a palindrome\n        if is_palindrome(n):\n            # If it is, return the number\n            return n\n        # Otherwise, increment the number and check again\n        n += 1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "\ndef count(boolean_list):\n    # Initialize a counter to keep track of True values\n    true_count = 0\n    \n    # Iterate through each element in the list\n    for element in boolean_list:\n        # Check if the element is True\n        if element is True:\n            # Increment the counter if the element is True\n            true_count += 1\n    \n    # Return the total count of True values\n    return true_count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "\ndef merge_sorted_list(list1, list2, list3):\n    # Combine all three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Sort the combined list in ascending order\n    combined_list.sort()\n    \n    # Return the sorted list\n    return combined_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "\ndef kth_element(arr: list, k: int) -> int:\n    # Return the element at the (k-1)th index of the list to account for 1-based indexing\n    return arr[k - 1]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "\ndef eulerian_helper(n, m, memo):\n    # Check if the result is already computed\n    if (n, m) in memo:\n        return memo[(n, m)]\n    \n    # Base cases\n    if m >= n:\n        return 0\n    if m == 0:\n        return 1\n    \n    # Recursive calculation using the Eulerian number formula\n    result = (n - m) * eulerian_helper(n - 1, m - 1, memo) + (m + 1) * eulerian_helper(n - 1, m, memo)\n    \n    # Store the result in memoization dictionary\n    memo[(n, m)] = result\n    return result\n\ndef eulerian_num(n: int, m: int) -> int:\n    # Initialize memoization dictionary\n    memo = {}\n    # Calculate the Eulerian number using the helper function\n    return eulerian_helper(n, m, memo)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "\ndef add_lists(lst, tpl):\n    # Convert the list to a tuple\n    list_as_tuple = tuple(lst)\n    \n    # Concatenate the original tuple with the converted tuple\n    result = tpl + list_as_tuple\n    \n    # Return the concatenated tuple\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "\ndef sort_sublists(list_of_lists):\n    # Create a new list to store the sorted sublists\n    sorted_sublists = []\n    # Iterate over each sublist in the tuple\n    for sublist in list_of_lists:\n        # Sort the current sublist alphabetically and append to the new list\n        sorted_sublists.append(sorted(sublist))\n    # Return the new list of sorted sublists\n    return sorted_sublists\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "\ndef odd_Equivalent(binary_string: str, rotations: int) -> int:\n    # Initialize the count of odd numbers\n    odd_count = 0\n    \n    # Convert the binary string to a list for easier manipulation\n    binary_list = list(binary_string)\n    \n    # Perform the rotations\n    for _ in range(rotations):\n        # Rotate the binary string by moving the first character to the end\n        first_char = binary_list.pop(0)\n        binary_list.append(first_char)\n        \n        # Check if the last character is '1' (indicating an odd number)\n        if binary_list[-1] == '1':\n            odd_count += 1\n    \n    # Return the count of odd numbers\n    return odd_count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "\ndef remove_Occ(s: str, char: str) -> str:\n    # Find the first occurrence of the character\n    first_index = s.find(char)\n    # Find the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is found\n    if first_index != -1:\n        # If the first and last occurrence are the same, remove it once\n        if first_index == last_index:\n            s = s[:first_index] + s[first_index+1:]\n        else:\n            # Remove the first occurrence\n            s = s[:first_index] + s[first_index+1:]\n            # Adjust last_index because the string is now shorter by one character\n            last_index -= 1\n            # Remove the last occurrence\n            s = s[:last_index] + s[last_index+1:]\n    \n    return s\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "\ndef common_in_nested_lists(nested_lists):\n    # Start with the first list's elements as a set\n    common_elements = set(nested_lists[0])\n    \n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Update the common elements by intersecting with the current list\n        common_elements.intersection_update(lst)\n    \n    # Return the common elements as a list\n    return list(common_elements)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "\ndef check_integer(s: str) -> bool:\n    # Check if the string is empty\n    if not s:\n        return False\n    \n    # Check if the string starts with '+' or '-'\n    if s[0] in ('+', '-'):\n        # Remove the sign for further checks\n        s = s[1:]\n    \n    # Check if the remaining string consists only of digits\n    return s.isdigit()\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "\ndef search(arr):\n    # Iterate through the array in steps of 2\n    for i in range(0, len(arr) - 1, 2):\n        # If the current element is not equal to the next one, it is the unique element\n        if arr[i] != arr[i + 1]:\n            return arr[i]\n    # If no unique element is found in the loop, the last element is unique\n    return arr[-1]\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "\ndef string_to_list(s: str) -> list:\n    # Use the split method to divide the string into a list of words based on spaces\n    return s.split()\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "\ndef tuple_to_int(t: tuple) -> int:\n    # Convert each integer in the tuple to a string and join them together\n    concatenated_string = ''.join(str(num) for num in t)\n    # Convert the concatenated string back to an integer\n    result_integer = int(concatenated_string)\n    # Return the resulting integer\n    return result_integer\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "\ndef sort_matrix(matrix):\n    # Sort the matrix using the sum of each row as the key\n    # The sorted function will sort the rows based on the sum of their elements\n    sorted_matrix = sorted(matrix, key=sum)\n    return sorted_matrix\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "\ndef max_product_tuple(list_of_tuples):\n    # Initialize the maximum absolute product to zero\n    max_abs_product = 0\n    \n    # Iterate over each tuple in the list\n    for t in list_of_tuples:\n        # Calculate the product of the two numbers in the tuple\n        product = t[0] * t[1]\n        \n        # Calculate the absolute value of the product\n        abs_product = abs(product)\n        \n        # Update the maximum absolute product if the current one is larger\n        if abs_product > max_abs_product:\n            max_abs_product = abs_product\n    \n    # Return the maximum absolute product found\n    return max_abs_product\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "\ndef find_length(s: str) -> int:\n    # Initialize the maximum difference and current difference\n    max_diff = 0\n    current_diff = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Increment current_diff for '0', decrement for '1'\n        if char == '0':\n            current_diff += 1\n        else:  # char == '1'\n            current_diff -= 1\n        \n        # Update max_diff if current_diff is greater\n        if current_diff > max_diff:\n            max_diff = current_diff\n        \n        # Reset current_diff if it becomes negative\n        if current_diff < 0:\n            current_diff = 0\n    \n    # Return the maximum difference found\n    return max_diff\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "\nimport math\n\ndef angle_complex(z: complex) -> float:\n    # Extract the real and imaginary parts of the complex number\n    real_part = z.real\n    imaginary_part = z.imag\n    \n    # Calculate the angle using atan2\n    angle = math.atan2(imaginary_part, real_part)\n    \n    # Return the calculated angle\n    return angle\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["0.0", "1j"]], "plus_fail_tests": [["0.0", "0j"]]}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "\ndef multiply_int(a: int, b: int) -> int:\n    # Calculate the product of a and b\n    result = a * b\n    # Return the result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "\ndef long_words(n: int, sentence: str) -> list:\n    # Split the sentence into words\n    words = sentence.split()\n    # Initialize an empty list to store words longer than n\n    result = []\n    # Iterate over each word in the list\n    for word in words:\n        # Check if the word's length is greater than n\n        if len(word) > n:\n            # Add the word to the result list\n            result.append(word)\n    # Return the list of words longer than n\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "\ndef magic_square_test(matrix):\n    # Check if the matrix is empty or not square\n    if not matrix or len(matrix) != len(matrix[0]):\n        return False\n    \n    n = len(matrix)\n    # Calculate the magic sum using the first row\n    magic_sum = sum(matrix[0])\n    \n    # Check each row sum\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check each column sum\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n    \n    # Check the main diagonal sum\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n    \n    # Check the secondary diagonal sum\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    # If all checks pass, it is a magic square\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "\ndef max_occurrences(lst):\n    # Create a dictionary to store the frequency of each number\n    frequency_count = {}\n    \n    # Iterate through the list to count the occurrences of each number\n    for number in lst:\n        if number in frequency_count:\n            frequency_count[number] += 1\n        else:\n            frequency_count[number] = 1\n    \n    # Initialize variables to track the number with the maximum frequency\n    max_count = 0\n    max_number = None\n    \n    # Iterate through the frequency dictionary to find the number with the highest frequency\n    for number, count in frequency_count.items():\n        if count > max_count:\n            max_count = count\n            max_number = number\n    \n    # Return the number with the maximum frequency\n    return max_number\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "\ndef tup_string(tup: tuple) -> str:\n    # Use the join method to concatenate all characters in the tuple into a single string\n    return ''.join(tup)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "\ndef reverse_vowels(s: str) -> str:\n    # Define a set of vowels for quick lookup\n    vowels_set = set('aeiouAEIOU')\n    \n    # Extract all vowels from the string\n    vowels = [char for char in s if char in vowels_set]\n    \n    # Reverse the list of vowels\n    vowels.reverse()\n    \n    # Initialize a list to build the result string\n    result = []\n    \n    # Initialize a counter to track the position in the reversed vowels list\n    vowel_index = 0\n    \n    # Iterate over each character in the original string\n    for char in s:\n        if char in vowels_set:\n            # If the character is a vowel, replace it with the next vowel from the reversed list\n            result.append(vowels[vowel_index])\n            vowel_index += 1\n        else:\n            # If the character is not a vowel, keep it unchanged\n            result.append(char)\n    \n    # Join the list into a string and return it\n    return ''.join(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "\ndef sum_negativenum(numbers):\n    # Initialize the sum of negative numbers to 0\n    sum_of_negatives = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is negative\n        if number < 0:\n            # Add the negative number to the sum\n            sum_of_negatives += number\n    \n    # Return the total sum of negative numbers\n    return sum_of_negatives\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "\ndef hexagonal_num(n: int) -> int:\n    # Calculate the nth hexagonal number using the formula: 2n^2 - n\n    hexagonal_number = 2 * n * n - n\n    # Return the calculated hexagonal number\n    return hexagonal_number\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "\ndef zero_count(arr):\n    # Initialize the count of zeroes\n    zero_count = 0\n    \n    # Count the number of zeroes in the array\n    for num in arr:\n        if num == 0:\n            zero_count += 1\n    \n    # Calculate the number of non-zero elements\n    non_zero_count = len(arr) - zero_count\n    \n    # If there are no non-zero elements, return 0.0 to avoid division by zero\n    if non_zero_count == 0:\n        return 0.0\n    \n    # Calculate and return the ratio of zeroes to non-zeroes\n    return zero_count / non_zero_count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    # If the number is less than or equal to 0, it cannot be represented as a sum of positive powers of 2\n    if n <= 0:\n        return False\n    \n    # While n is greater than 0, check each bit\n    while n > 0:\n        # If the least significant bit is 1, it means this bit contributes to the sum\n        if n % 2 == 1:\n            # Subtract 1 to remove the contribution of this power of 2\n            n -= 1\n        # Divide n by 2 to shift right and check the next bit\n        n //= 2\n    \n    # If we can reduce n to 0 by subtracting powers of 2, return True\n    return True\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[123456789]]}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "\ndef circle_circumference(radius: float) -> float:\n    # Define the value of pi\n    pi = 3.14159\n    # Calculate the circumference using the formula C = 2 * pi * radius\n    circumference = 2 * pi * radius\n    # Return the calculated circumference\n    return circumference\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000]]}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "\ndef find_Volume(base: float, height: float, length: float) -> float:\n    # Calculate the area of the triangular base\n    base_area = 0.5 * base * height\n    # Calculate the volume of the triangular prism\n    volume = base_area * length\n    # Return the calculated volume\n    return volume\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "\ndef extract_singly(list_of_tuples):\n    # Initialize an empty set to store unique numbers\n    result_set = set()\n    \n    # Iterate over each tuple in the list\n    for tuple_ in list_of_tuples:\n        # Iterate over each number in the current tuple\n        for number in tuple_:\n            # Add the number to the set (duplicates are automatically handled)\n            result_set.add(number)\n    \n    # Return the set containing all unique numbers\n    return result_set\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "\ndef flip(arr, k):\n    # Reverse the first k elements of the array\n    left = 0\n    right = k - 1\n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n\ndef pancake_sort(arr):\n    n = len(arr)\n    # Iterate from the end of the list to the beginning\n    for i in range(n, 1, -1):\n        # Find the index of the maximum element in the unsorted portion\n        max_index = 0\n        for j in range(1, i):\n            if arr[j] > arr[max_index]:\n                max_index = j\n        # If the maximum element is not already in its correct position\n        if max_index != i - 1:\n            # Flip the maximum element to the front\n            flip(arr, max_index + 1)\n            # Flip it to its correct position\n            flip(arr, i)\n    return arr\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "\ndef count_samepair(list1, list2, list3):\n    # Initialize a counter to keep track of identical elements\n    count = 0\n    \n    # Iterate through the indices of the lists\n    for i in range(len(list1)):\n        # Check if the elements at the current index are the same in all three lists\n        if list1[i] == list2[i] == list3[i]:\n            # Increment the counter if they are identical\n            count += 1\n    \n    # Return the total count of identical elements\n    return count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]]]}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "\ndef max_Abs_Diff(arr: tuple) -> int:\n    # Find the minimum value in the array\n    min_value = min(arr)\n    # Find the maximum value in the array\n    max_value = max(arr)\n    # Calculate the difference between the maximum and minimum values\n    difference = max_value - min_value\n    # Return the calculated difference\n    return difference\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "\ndef extended_gcd(a, b):\n    # Base case: if b is 0, gcd is a, and coefficients are (1, 0)\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        # Recursive call\n        gcd, x1, y1 = extended_gcd(b, a % b)\n        # Update x and y using results of recursion\n        x = y1\n        y = x1 - (a // b) * y1\n        return (gcd, x, y)\n\ndef find_solution(a, b, n):\n    # Get gcd and coefficients for the equation ax + by = gcd(a, b)\n    gcd, x0, y0 = extended_gcd(a, b)\n    # Check if n is divisible by gcd\n    if n % gcd != 0:\n        return None\n    # Scale the solution to match the equation ax + by = n\n    scale = n // gcd\n    x = x0 * scale\n    y = y0 * scale\n    \n    # Adjust the solution to find a non-negative solution with smaller values\n    # We will adjust x and y to be the smallest non-negative solution\n    # by using the fact that (x + k*(b/gcd), y - k*(a/gcd)) is also a solution\n    # for any integer k.\n    a_div_gcd = a // gcd\n    b_div_gcd = b // gcd\n    \n    # Adjust x and y to be non-negative\n    if x < 0:\n        k = (-x + b_div_gcd - 1) // b_div_gcd\n        x += k * b_div_gcd\n        y -= k * a_div_gcd\n    elif y < 0:\n        k = (-y + a_div_gcd - 1) // a_div_gcd\n        x -= k * b_div_gcd\n        y += k * a_div_gcd\n    \n    return (x, y)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1, 13, 17]], "plus_fail_tests": [[25, 10, 500]]}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "\ndef text_lowercase_underscore(s: str) -> bool:\n    # If the string is empty, it cannot match the pattern\n    if not s:\n        return False\n    \n    # If the first or last character is an underscore, return False\n    if s[0] == '_' or s[-1] == '_':\n        return False\n    \n    # Initialize a variable to track if the previous character was an underscore\n    previous_was_underscore = False\n    \n    # Iterate through each character in the string\n    for char in s:\n        # If the character is not a lowercase letter and not an underscore, return False\n        if not (char.islower() or char == '_'):\n            return False\n        \n        # If the character is an underscore\n        if char == '_':\n            # If the previous character was also an underscore, return False\n            if previous_was_underscore:\n                return False\n            # Set the previous character as underscore\n            previous_was_underscore = True\n        else:\n            # Set the previous character as not underscore\n            previous_was_underscore = False\n    \n    # If all checks are passed, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "\ndef remove_elements(list1, list2):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each element in the first list\n    for element in list1:\n        # Check if the element is not in the second list\n        if element not in list2:\n            # If not, append it to the result list\n            result.append(element)\n    \n    # Return the result list containing elements not in list2\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "\ndef count_char_position(s: str) -> int:\n    # Convert the string to lowercase to ensure case insensitivity\n    s = s.lower()\n    count = 0\n    \n    # Iterate over each character and its index\n    for i, c in enumerate(s):\n        # Calculate the position of the character in the alphabet\n        alphabet_position = ord(c) - ord('a') + 1\n        \n        # Check if the alphabet position matches the string position (index + 1)\n        if alphabet_position == i + 1:\n            count += 1\n    \n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "\ndef find_even_pair(nums):\n    # Initialize counters for even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    # Count the number of even and odd numbers in the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate the number of pairs of even numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    # Calculate the number of pairs of odd numbers\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    # Return the total number of pairs that XOR to an even number\n    return even_pairs + odd_pairs\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "\ndef frequency(lst, num):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # Check if the current element matches the given number\n        if element == num:\n            # Increment the counter if there's a match\n            count += 1\n    \n    # Return the total count of occurrences\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "\ndef next_power_of_2(n: int) -> int:\n    # If n is less than or equal to 0, the smallest power of 2 is 1\n    if n <= 0:\n        return 1\n    \n    # Start with the smallest power of 2, which is 1 (2^0)\n    power = 1\n    \n    # Keep multiplying by 2 until power is greater than or equal to n\n    while power < n:\n        power *= 2\n    \n    # Return the smallest power of 2 that is greater than or equal to n\n    return power\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "\n# Define the function to calculate the perimeter of a square\ndef square_perimeter(side_length: int) -> int:\n    # Calculate the perimeter by multiplying the side length by 4\n    perimeter = 4 * side_length\n    # Return the calculated perimeter\n    return perimeter\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "\ndef sum_range_list(numbers: list, start_index: int, end_index: int) -> int:\n    # Extract the sublist from start_index to end_index (inclusive)\n    sublist = numbers[start_index:end_index + 1]\n    # Calculate the sum of the sublist\n    total_sum = sum(sublist)\n    # Return the sum\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "\ndef remove_dirty_chars(first_string: str, second_string: str) -> str:\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the first string\n    for char in first_string:\n        # Check if the character is not in the second string\n        if char not in second_string:\n            # If not, add it to the result string\n            result += char\n    \n    # Return the final result string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "\ndef test_duplicate(arr):\n    # Create an empty set to keep track of numbers we have seen\n    seen_numbers = set()\n    \n    # Iterate through each number in the array\n    for number in arr:\n        # If the number is already in the set, we found a duplicate\n        if number in seen_numbers:\n            return True\n        # Otherwise, add the number to the set\n        else:\n            seen_numbers.add(number)\n    \n    # If we finish the loop without finding duplicates, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "\ndef perimeter_pentagon(side_length: int) -> int:\n    # Calculate the perimeter by multiplying the side length by 5\n    perimeter = side_length * 5\n    # Return the calculated perimeter\n    return perimeter\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "\ndef count_occurance(input_string: str) -> int:\n    # Use the built-in string method count to find the number of occurrences of \"std\"\n    return input_string.count(\"std\")\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/2": [{"task_id": "Mbpp/2", "solution": "\ndef similar_elements(list1, list2):\n    # Convert the first list to a set to remove duplicates and allow set operations\n    set1 = set(list1)\n    # Convert the second list to a set\n    set2 = set(list2)\n    # Find the intersection of the two sets to get common elements\n    common_elements = set1.intersection(set2)\n    # Convert the set of common elements back to a list\n    return list(common_elements)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "\ndef is_woodall(x: int) -> bool:\n    # Start with n = 1\n    n = 1\n    while True:\n        # Calculate the Woodall number for the current n\n        woodall_number = n * (2 ** n) - 1\n        # Check if the calculated Woodall number matches the input number\n        if woodall_number == x:\n            return True\n        # If the calculated Woodall number exceeds the input number, stop and return False\n        if woodall_number > x:\n            return False\n        # Increment n to check the next possible Woodall number\n        n += 1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "\ndef check_type(tuple_data: tuple) -> bool:\n    # If the tuple is empty, return True as there are no elements to compare\n    if not tuple_data:\n        return True\n    \n    # Get the data type of the first element\n    first_type = type(tuple_data[0])\n    \n    # Iterate through each element in the tuple\n    for element in tuple_data:\n        # If the type of the current element is not the same as the first element's type\n        if type(element) != first_type:\n            # Return False as not all elements have the same type\n            return False\n    \n    # If all elements have the same type, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "\ndef binary_search_first_occurrence(arr, n, element):\n    left, right = 0, n - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == element:\n            result = mid\n            right = mid - 1  # Continue searching in the left half\n        elif arr[mid] < element:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result\n\ndef is_majority(arr, n, element):\n    # Find the first occurrence of the element\n    first_occurrence = binary_search_first_occurrence(arr, n, element)\n    \n    # If the element is not found, it cannot be the majority\n    if first_occurrence == -1:\n        return False\n    \n    # Check if the element appears more than n/2 times\n    if first_occurrence + n // 2 < n and arr[first_occurrence + n // 2] == element:\n        return True\n    else:\n        return False\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 1, 0]]}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "\ndef count_Set_Bits(n: int) -> int:\n    # Convert the number to its binary representation\n    binary_representation = bin(n)\n    \n    # Count the number of '1's in the binary representation\n    # We use slicing [2:] to remove the '0b' prefix\n    count_of_ones = binary_representation[2:].count('1')\n    \n    # Return the count of '1's\n    return count_of_ones\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "\ndef odd_values_string(s: str) -> str:\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Loop through the string using an index\n    for i in range(len(s)):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Append the character at the even index to the result string\n            result += s[i]\n    \n    # Return the result string containing characters at even indices\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "\ndef min_of_three(a: int, b: int, c: int) -> int:\n    # Start by assuming the first number is the smallest\n    min_value = a\n    \n    # Compare with the second number\n    if b < min_value:\n        min_value = b\n    \n    # Compare with the third number\n    if c < min_value:\n        min_value = c\n    \n    # Return the smallest number found\n    return min_value\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "\ndef replace_blank(input_string: str, replacement_char: str) -> str:\n    # Use the replace method to replace all spaces with the replacement character\n    modified_string = input_string.replace(' ', replacement_char)\n    # Return the modified string\n    return modified_string\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "\nimport math\n\ndef lateralsuface_cylinder(height: float, radius: float) -> float:\n    # Calculate the lateral surface area using the formula: 2 * pi * radius * height\n    lateral_surface_area = 2 * math.pi * radius * height\n    # Return the calculated lateral surface area\n    return lateral_surface_area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "\ndef volume_cube(side: int) -> int:\n    # Calculate the volume of the cube by raising the side length to the power of 3\n    volume = side ** 3\n    # Return the calculated volume\n    return volume\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "\ndef larg_nnum(lst, n):\n    # Step 1: Sort the list in descending order\n    sorted_lst = sorted(lst, reverse=True)\n    \n    # Step 2: Take the first n elements from the sorted list\n    largest_n = sorted_lst[:n]\n    \n    # Step 3: Return the list of n largest elements\n    return largest_n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "\ndef sum_series(n: int) -> int:\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the series from i = 0 to n // 2\n    for i in range(n // 2 + 1):\n        # Calculate the current term in the series\n        term = n - 2 * i\n        \n        # Add the current term to the total sum\n        total_sum += term\n    \n    # Return the total sum of the series\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "\ndef even_bit_set_number(n: int) -> int:\n    # Initialize the mask to 0\n    mask = 0\n    \n    # Determine the number of bits in the binary representation of n\n    num_bits = max(n.bit_length(), 1)  # Ensure at least one bit is considered\n    \n    # Set all even bits in the mask\n    for i in range(0, num_bits, 2):\n        mask |= (1 << i)\n    \n    # Return the number with all even bits set\n    return n | mask\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[999999999]]}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "\ndef check_occurences(tuples_list):\n    # Initialize an empty dictionary to store the counts of each tuple\n    tuple_count = {}\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Sort the tuple to handle both the tuple and its reverse as the same key\n        sorted_tup = tuple(sorted(tup))\n        \n        # If the sorted tuple is already in the dictionary, increment its count\n        if sorted_tup in tuple_count:\n            tuple_count[sorted_tup] += 1\n        else:\n            # If the sorted tuple is not in the dictionary, add it with a count of 1\n            tuple_count[sorted_tup] = 1\n    \n    # Return the dictionary containing the counts of each tuple\n    return tuple_count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "\ndef number_of_substrings(s: str) -> int:\n    # Calculate the length of the string\n    n = len(s)\n    # Use the formula to calculate the number of non-empty substrings\n    # The formula is n * (n + 1) / 2\n    return n * (n + 1) // 2\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "\ndef count_charac(input_string: str) -> int:\n    # Use the len() function to get the number of characters in the input string\n    return len(input_string)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "\ndef replace_list(list1: list, list2: list) -> list:\n    # Remove the last element from list1\n    list1.pop()\n    \n    # Extend list1 with all elements from list2\n    list1.extend(list2)\n    \n    # Return the modified list1\n    return list1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "\ndef next_Perfect_Square(n: int) -> int:\n    # Step 1: Find the integer part of the square root of n\n    root = int(n**0.5)\n    \n    # Step 2: Increment the root by 1 to find the next integer\n    next_root = root + 1\n    \n    # Step 3: Return the square of the next integer\n    return next_root * next_root\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "\ndef max_sum(array):\n    n = len(array)\n    \n    # Initialize arrays to store the maximum sum of increasing and decreasing subsequences\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Calculate maximum sum of increasing subsequence ending at each element\n    for i in range(n):\n        inc[i] = array[i]\n        for j in range(i):\n            if array[j] < array[i]:\n                inc[i] = max(inc[i], inc[j] + array[i])\n    \n    # Calculate maximum sum of decreasing subsequence starting at each element\n    for i in range(n-1, -1, -1):\n        dec[i] = array[i]\n        for j in range(n-1, i, -1):\n            if array[j] < array[i]:\n                dec[i] = max(dec[i], dec[j] + array[i])\n    \n    # Find the maximum sum of bitonic subsequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - array[i])\n    \n    return max_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "\ndef count_X(input_tuple: tuple, element: int) -> int:\n    # Use the count method of tuple to find the number of occurrences of the element\n    return input_tuple.count(element)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "\ndef find_divisors(n: int) -> set:\n    # Initialize an empty set to store divisors\n    divisors = set()\n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # If i is a divisor of n, add it to the set\n        if n % i == 0:\n            divisors.add(i)\n    return divisors\n\ndef sum(a: int, b: int) -> int:\n    # Find divisors of both numbers\n    divisors_a = find_divisors(a)\n    divisors_b = find_divisors(b)\n    # Find common divisors by intersecting the two sets\n    common_divisors = divisors_a.intersection(divisors_b)\n    # Calculate the sum of the common divisors manually\n    total = 0\n    for divisor in common_divisors:\n        total += divisor\n    return total\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321, 123456789]]}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "\ndef insert_element(lst: list, element) -> list:\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each item in the input list\n    for item in lst:\n        # Insert the given element before the current item\n        result.append(element)\n        # Append the current item to the result list\n        result.append(item)\n    \n    # Return the modified list\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "\nimport math\n\ndef convert(z: complex) -> tuple:\n    # Extract real and imaginary parts\n    a = z.real\n    b = z.imag\n    \n    # Calculate magnitude\n    magnitude = math.sqrt(a**2 + b**2)\n    \n    # Calculate angle\n    angle = math.atan2(b, a)\n    \n    # Return the polar coordinates as a tuple\n    return (magnitude, angle)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "\ndef count_integer(lst):\n    # Initialize a counter to keep track of integer elements\n    count = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # Check if the current element is an integer\n        if isinstance(element, int):\n            # Increment the counter if the element is an integer\n            count += 1\n    \n    # Return the total count of integer elements\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "\ndef lps(s: str) -> int:\n    n = len(s)\n    # Create a 2D array to store the length of longest palindromic subsequence\n    dp = [[0] * n for _ in range(n)]\n    \n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n    \n    # Build the dp table\n    for length in range(2, n + 1):  # length of the substring\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    # The result is in the top right corner of the table\n    return dp[0][n - 1]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "\ndef count_sequences(current_value, current_length, m, n):\n    # Base case: if the sequence length is n, we have a valid sequence\n    if current_length == n:\n        return 1\n    \n    count = 0\n    # Try all possible next values that are at least twice the current value\n    for next_value in range(2 * current_value, m + 1):\n        count += count_sequences(next_value, current_length + 1, m, n)\n    \n    return count\n\ndef get_total_number_of_sequences(m, n):\n    total_count = 0\n    # Start sequences with each possible starting value from 1 to m\n    for start_value in range(1, m + 1):\n        total_count += count_sequences(start_value, 1, m, n)\n    \n    return total_count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[200, 6]]}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "\ndef sum_of_divisors(num: int) -> int:\n    # Calculate the sum of proper divisors of num\n    total = 0\n    for i in range(1, num):\n        if num % i == 0:\n            total += i\n    return total\n\ndef amicable_numbers_sum(n: int) -> int:\n    amicable_sum = 0\n    checked = set()\n    \n    for i in range(1, n + 1):\n        if i in checked:\n            continue\n        \n        sum_i = sum_of_divisors(i)\n        \n        if sum_i != i and sum_i <= n:\n            sum_j = sum_of_divisors(sum_i)\n            if sum_j == i:\n                amicable_sum += i\n                if sum_i <= n:\n                    amicable_sum += sum_i\n                checked.add(i)\n                checked.add(sum_i)\n    \n    return amicable_sum\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9999]], "plus_fail_tests": [[10000]]}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "\ndef split_two_parts(lst, L):\n    # Slice the list from the start to L to get the first part\n    first_part = lst[:L]\n    # Slice the list from L to the end to get the second part\n    second_part = lst[L:]\n    # Return a tuple containing the first and second parts\n    return (first_part, second_part)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "\ndef dog_age(human_years: int) -> int:\n    # Calculate the conversion rate from human years to dog years\n    conversion_rate = 61 / 12\n    \n    # Calculate the dog's age in dog years\n    dog_years = human_years * conversion_rate\n    \n    # Return the dog's age in dog years as an integer\n    return int(dog_years)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15]], "plus_fail_tests": [[100]]}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "\ndef swap_numbers(a: int, b: int) -> tuple:\n    # Create a tuple with the second number first and the first number second\n    result = (b, a)\n    # Return the tuple\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "\ndef maximize_elements(tuple1: tuple, tuple2: tuple) -> tuple:\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over pairs of tuples from both input tuples\n    for pair1, pair2 in zip(tuple1, tuple2):\n        # Find the maximum of the corresponding elements in the pairs\n        max_pair = (max(pair1[0], pair2[0]), max(pair1[1], pair2[1]))\n        \n        # Append the new tuple with maximum values to the result list\n        result.append(max_pair)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "\ndef division_elements(tuple1: tuple, tuple2: tuple) -> tuple:\n    # Initialize an empty list to store the results of division\n    result = []\n    \n    # Loop over the indices of the tuples\n    for i in range(len(tuple1)):\n        # Perform division of the elements at the current index\n        division_result = tuple1[i] // tuple2[i]\n        # Append the result to the result list\n        result.append(division_result)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[5, 2, 3, 3], [5, 2, 3, 4]]]}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "\ndef newman_prime(n: int) -> int:\n    # Base cases for the sequence\n    if n == 0 or n == 1:\n        return 1\n    \n    # Initialize the first two terms of the sequence\n    S0 = 1\n    S1 = 1\n    \n    # Calculate the sequence up to the nth term\n    for i in range(2, n + 1):\n        # Calculate the next term using the recurrence relation\n        Si = 2 * S1 + S0\n        # Update the previous terms for the next iteration\n        S0 = S1\n        S1 = Si\n    \n    # Return the nth term\n    return Si\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "\ndef is_prime(number: int) -> bool:\n    # A number less than 2 is not prime\n    if number < 2:\n        return False\n    # Check divisibility from 2 to the square root of the number\n    for i in range(2, int(number**0.5) + 1):\n        if number % i == 0:\n            return False\n    return True\n\ndef count_Primes_nums(n: int) -> int:\n    # Initialize the count of prime numbers\n    prime_count = 0\n    # Iterate over each number from 2 to n-1\n    for num in range(2, n):\n        # Check if the current number is prime\n        if is_prime(num):\n            # Increment the prime count if it is prime\n            prime_count += 1\n    # Return the total count of prime numbers found\n    return prime_count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "\ndef square_Sum(n: int) -> int:\n    # Initialize the sum to 0\n    sum_of_squares = 0\n    \n    # Loop through the first n odd numbers\n    for i in range(1, n + 1):\n        # Calculate the i-th odd number\n        odd_number = 2 * i - 1\n        # Add the square of the odd number to the sum\n        sum_of_squares += odd_number ** 2\n    \n    # Return the total sum of squares\n    return sum_of_squares\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000.0]]}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "\ndef ascii_value(character: str) -> int:\n    # Use the built-in ord() function to get the ASCII value of the character\n    return ord(character)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "\ndef find_star_num(n: int) -> int:\n    # Calculate the nth star number using the formula\n    # Star(n) = 6 * n * (n - 1) + 1\n    star_number = 6 * n * (n - 1) + 1\n    # Return the calculated star number\n    return star_number\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "\ndef sum_even_and_even_index(lst):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list using index\n    for i in range(len(lst)):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Check if the element at this index is even\n            if lst[i] % 2 == 0:\n                # Add the element to the sum\n                total_sum += lst[i]\n    \n    # Return the total sum of even numbers at even indices\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "\ndef lateralsurface_cube(side_length: int) -> int:\n    # Calculate the lateral surface area of the cube\n    # Lateral surface area = 4 * (side length)^2\n    lateral_surface_area = 4 * side_length * side_length\n    \n    # Return the calculated lateral surface area\n    return lateral_surface_area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "\ndef list_split(lst, n):\n    # Step 1: Initialize a list of n empty lists\n    result = [[] for _ in range(n)]\n    \n    # Step 2: Iterate over the input list with index\n    for i, elem in enumerate(lst):\n        # Step 3: Append the element to the appropriate sublist\n        result[i % n].append(elem)\n    \n    # Step 4: Return the list of lists\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "\ndef dict_filter(input_dict: dict, n: int) -> dict:\n    # Create an empty dictionary to store the filtered results\n    filtered_dict = {}\n    \n    # Iterate over each key-value pair in the input dictionary\n    for key, value in input_dict.items():\n        # Check if the value is greater than or equal to n\n        if value >= n:\n            # Add the key-value pair to the filtered dictionary\n            filtered_dict[key] = value\n    \n    # Return the filtered dictionary\n    return filtered_dict\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "\ndef rear_extract(tuples_list):\n    # Initialize an empty list to store the last elements of each tuple\n    result = []\n    \n    # Iterate over each tuple in the input list\n    for tup in tuples_list:\n        # Access the last element of the tuple using negative indexing\n        last_element = tup[-1]\n        \n        # Append the last element to the result list\n        result.append(last_element)\n    \n    # Return the list containing the last elements of each tuple\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "\ndef count_first_elements(t: tuple) -> int:\n    # Initialize a counter to keep track of the number of elements before the first tuple\n    count = 0\n    \n    # Iterate over each element in the input tuple\n    for element in t:\n        # Check if the current element is a tuple\n        if isinstance(element, tuple):\n            # If it is a tuple, break the loop as we found the first tuple\n            break\n        # If it is not a tuple, increment the counter\n        count += 1\n    \n    # Return the count of elements before the first tuple\n    return count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "\n# Helper function to calculate factorial of a number\ndef factorial(num: int) -> int:\n    if num == 0 or num == 1:\n        return 1\n    result = 1\n    for i in range(2, num + 1):\n        result *= i\n    return result\n\n# Main function to calculate the sum of even index binomial coefficients\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    sum_even_coeff = 0\n    # Iterate over even indices from 0 to n\n    for k in range(0, n + 1, 2):\n        # Calculate the binomial coefficient C(n, k)\n        binomial_coeff = factorial(n) // (factorial(k) * factorial(n - k))\n        # Add the binomial coefficient to the sum\n        sum_even_coeff += binomial_coeff\n    return sum_even_coeff\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "\ndef substract_elements(tuple1: tuple, tuple2: tuple) -> tuple:\n    # Initialize an empty list to store the results of the subtraction\n    result = []\n    \n    # Iterate over the indices of the tuples\n    for i in range(len(tuple1)):\n        # Subtract the element in tuple2 from the element in tuple1 at the same index\n        subtraction = tuple1[i] - tuple2[i]\n        # Append the result to the result list\n        result.append(subtraction)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "\ndef volume_cylinder(radius: float, height: float) -> float:\n    # Import the math module to access the value of \u03c0 (pi)\n    import math\n    \n    # Calculate the square of the radius\n    radius_squared = radius ** 2\n    \n    # Calculate the volume using the formula: \u03c0 * (radius squared) * height\n    volume = math.pi * radius_squared * height\n    \n    # Return the calculated volume\n    return volume\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "\ndef sub_list(list1, list2):\n    # Initialize an empty list to store the results of the subtraction\n    result = []\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Subtract the element in list2 from the element in list1 at the same index\n        difference = list1[i] - list2[i]\n        # Append the result to the result list\n        result.append(difference)\n    \n    # Return the list containing the element-wise differences\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "\ndef is_num_decagonal(n: int) -> int:\n    # Calculate the nth decagonal number using the formula\n    # D_n = 4n^2 - 3n\n    decagonal_number = 4 * n * n - 3 * n\n    return decagonal_number\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "\ndef sequential_search(array, element):\n    # Iterate over the array with index\n    for index in range(len(array)):\n        # Check if the current element matches the target element\n        if array[index] == element:\n            # If found, return True and the index\n            return (True, index)\n    # If not found, return False and -1\n    return (False, -1)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "\ndef all_unique(lst):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    \n    # Compare the length of the set with the length of the list\n    # If they are equal, all elements were unique\n    return len(unique_elements) == len(lst)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "\ndef validate(n: int) -> bool:\n    # Convert the integer to a string to iterate over each digit\n    num_str = str(n)\n    \n    # Create a dictionary to count the frequency of each digit\n    digit_count = {}\n    \n    # Count the frequency of each digit\n    for char in num_str:\n        digit = int(char)\n        if digit not in digit_count:\n            digit_count[digit] = 0\n        digit_count[digit] += 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit in digit_count:\n        if digit_count[digit] > digit:\n            return False\n    \n    # If all conditions are satisfied, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "\ndef check_element(lst, element):\n    # Iterate through each item in the list\n    for item in lst:\n        # If the current item is not equal to the specified element\n        if item != element:\n            # Return False immediately\n            return False\n    # If all items are equal to the specified element, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "\ndef kadane(arr):\n    max_ending_here = max_so_far = arr[0]\n    for i in range(1, len(arr)):\n        max_ending_here = max(arr[i], max_ending_here + arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef calculate_best_prefix_sum(arr):\n    best_prefix_sum = current_sum = 0\n    for i in range(len(arr)):\n        current_sum += arr[i]\n        best_prefix_sum = max(best_prefix_sum, current_sum)\n    return best_prefix_sum\n\ndef calculate_best_suffix_sum(arr):\n    best_suffix_sum = current_sum = 0\n    for i in range(len(arr) - 1, -1, -1):\n        current_sum += arr[i]\n        best_suffix_sum = max(best_suffix_sum, current_sum)\n    return best_suffix_sum\n\ndef max_sub_array_sum_repeated(arr, n, k):\n    max_kadane = kadane(arr)\n    total_sum = sum(arr)\n    \n    if k == 1:\n        return max_kadane\n    \n    best_prefix_sum = calculate_best_prefix_sum(arr)\n    best_suffix_sum = calculate_best_suffix_sum(arr)\n    \n    if total_sum > 0:\n        return max(max_kadane, best_prefix_sum + best_suffix_sum + total_sum * (k - 2))\n    else:\n        return max(max_kadane, best_prefix_sum + best_suffix_sum)\n", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[[-1, -2, -3], 3, 3]], "plus_fail_tests": []}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "\ndef text_match_two_three(s: str) -> bool:\n    # Loop through each character in the string s using an index i\n    for i in range(len(s)):\n        # If the character at index i is 'a'\n        if s[i] == 'a':\n            # Check if the next two characters are 'b'\n            if i + 2 < len(s) and s[i+1] == 'b' and s[i+2] == 'b':\n                return True\n            # Check if the next three characters are 'b'\n            if i + 3 < len(s) and s[i+1] == 'b' and s[i+2] == 'b' and s[i+3] == 'b':\n                return True\n    # If no pattern is found, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "\ndef max_length(list_of_lists):\n    # Initialize the maximum length to zero\n    max_len = 0\n    # Initialize the longest list as an empty list\n    longest_list = []\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Check if the current list's length is greater than the current maximum length\n        if len(lst) > max_len:\n            # Update the maximum length\n            max_len = len(lst)\n            # Update the longest list\n            longest_list = lst\n    \n    # Return a tuple containing the maximum length and the longest list\n    return (max_len, longest_list)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "\ndef find(a: int, b: int) -> int:\n    # Use integer division to find the quotient of a divided by b\n    # The // operator will automatically round down to the nearest integer\n    result = a // b\n    # Return the result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "\ndef otherside_rightangle(a: float, b: float) -> float:\n    # Calculate the hypotenuse if both sides are legs\n    if a**2 + b**2 > max(a, b)**2:\n        return (a**2 + b**2) ** 0.5\n    else:\n        # Calculate the missing leg if one side is the hypotenuse\n        return abs(a**2 - b**2) ** 0.5\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "\ndef max_val(lst):\n    # Initialize a list to store numeric values\n    numeric_values = []\n    \n    # Iterate over each item in the input list\n    for item in lst:\n        # Check if the item is an integer or a float\n        if isinstance(item, (int, float)):\n            # Add the numeric item to the numeric_values list\n            numeric_values.append(item)\n    \n    # Return the maximum value from the numeric_values list\n    return max(numeric_values)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["3.14", false, 7.5]]]}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "\ndef merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all elements left to i in the left subarray\n            # are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\n\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\n\ndef get_Inv_Count(arr):\n    n = len(arr)\n    temp_arr = [0] * n\n    return merge_sort_and_count(arr, temp_arr, 0, n - 1)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "\ndef max_aggregate(tuples_list):\n    # Initialize a dictionary to store the total scores for each name\n    scores_dict = {}\n\n    # Iterate through each tuple in the list\n    for name, score in tuples_list:\n        # If the name is already in the dictionary, add the score to the existing total\n        if name in scores_dict:\n            scores_dict[name] += score\n        # If the name is not in the dictionary, initialize it with the current score\n        else:\n            scores_dict[name] = score\n\n    # Initialize variables to track the name with the maximum score\n    max_name = None\n    max_score = 0\n\n    # Iterate through the dictionary to find the name with the highest total score\n    for name, total_score in scores_dict.items():\n        if total_score > max_score:\n            max_score = total_score\n            max_name = name\n\n    # Return the name with the highest score and the score itself\n    return (max_name, max_score)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[["Alice", -50]]]]}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "\ndef flatten_list(nested_list):\n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n    \n    # Iterate over each element in the input list\n    for element in nested_list:\n        # If the element is a list, recursively flatten it\n        if isinstance(element, list):\n            # Extend the flat_list with the flattened result of the element\n            flat_list.extend(flatten_list(element))\n        else:\n            # If the element is not a list, append it directly to flat_list\n            flat_list.append(element)\n    \n    # Return the fully flattened list\n    return flat_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "\ndef is_not_prime(n: int) -> bool:\n    # Numbers less than or equal to 1 are not prime\n    if n <= 1:\n        return True\n    # 2 is the only even prime number\n    if n == 2:\n        return False\n    # Any other even number is not prime\n    if n % 2 == 0:\n        return True\n    # Check for factors from 3 to the square root of n\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return True\n        i += 2\n    # If no factors were found, n is prime\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "\ndef dict_depth(d):\n    # Base case: if the input is not a dictionary or is an empty dictionary\n    if not isinstance(d, dict) or not d:\n        return 1\n    \n    # Initialize the maximum depth to 1 (the current level)\n    max_depth = 1\n    \n    # Iterate over each key-value pair in the dictionary\n    for key, value in d.items():\n        # If the value is a dictionary, calculate its depth recursively\n        if isinstance(value, dict):\n            # Calculate the depth of the nested dictionary\n            depth = dict_depth(value)\n            # Update the maximum depth encountered\n            max_depth = max(max_depth, depth + 1)\n    \n    # Return the maximum depth found\n    return max_depth\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "\ndef start_withp(words_list):\n    # Initialize an empty list to store words starting with 'p' or 'P'\n    p_words = []\n    \n    # Iterate over each string in the input list\n    for string in words_list:\n        # Split the string into individual words\n        words = string.split()\n        \n        # Check each word\n        for word in words:\n            # If the word starts with 'p' or 'P', add it to the list\n            if word.lower().startswith('p'):\n                p_words.append(word)\n                \n                # If we have found two words, return them as a tuple\n                if len(p_words) == 2:\n                    return (p_words[0], p_words[1])\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["python Programming", "Java Programming", "perl Programming", "Ruby Programming", "PHP Programming", "C Programming"]]]}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize an array to store the maximum sum of increasing subsequences\n    # ending at each index up to i\n    max_sum = [0] * (i + 1)\n    \n    # Calculate the maximum sum of increasing subsequences for each index up to i\n    for j in range(i + 1):\n        max_sum[j] = arr[j]\n        for m in range(j):\n            if arr[m] < arr[j]:\n                max_sum[j] = max(max_sum[j], max_sum[m] + arr[j])\n    \n    # Find the maximum sum of subsequences that can be extended to include arr[k]\n    result = 0\n    for j in range(i + 1):\n        if arr[j] < arr[k]:\n            result = max(result, max_sum[j] + arr[k])\n    \n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[5, 2, 4, 1, 3, 6], 6, 1, 3]]}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "\ndef binomial_coefficient(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)  # Take advantage of symmetry\n    c = 1\n    for i in range(k):\n        c = c * (n - i) // (i + 1)\n    return c\n\ndef count_binary_seq(n: int) -> float:\n    total_count = 0\n    for k in range(n + 1):\n        c_n_k = binomial_coefficient(n, k)\n        total_count += c_n_k * c_n_k\n    return float(total_count)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000]]}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "\ndef large_product(list1, list2, n):\n    # Initialize an empty list to store the products\n    products = []\n    \n    # Generate all possible products\n    for num1 in list1:\n        for num2 in list2:\n            # Calculate the product and append to the list\n            products.append(num1 * num2)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first 'n' elements from the sorted list\n    return products[:n]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "\ndef square_Sum(n: int) -> int:\n    # Initialize the sum of squares to 0\n    sum_of_squares = 0\n    \n    # Loop over the first n even numbers\n    for i in range(1, n + 1):\n        # Calculate the i-th even number\n        even_number = 2 * i\n        # Add the square of the even number to the sum\n        sum_of_squares += even_number ** 2\n    \n    # Return the total sum of squares\n    return sum_of_squares\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000]]}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "\ndef maximum(a: int, b: int) -> int:\n    # Check if the first number is greater than or equal to the second number\n    if a >= b:\n        # If true, return the first number\n        return a\n    else:\n        # Otherwise, return the second number\n        return b\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "\ndef string_to_tuple(s: str) -> tuple:\n    # Convert the string 's' to a tuple where each character is an element of the tuple\n    return tuple(s)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python 3.0"]], "plus_fail_tests": [["hello   world"]]}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "\ndef set_left_most_unset_bit(n: int) -> int:\n    # Convert the number to binary string\n    binary_str = bin(n)[2:]  # Remove the '0b' prefix\n    \n    # Find the leftmost unset bit (0)\n    for i in range(len(binary_str)):\n        if binary_str[i] == '0':\n            # Set the leftmost unset bit to 1\n            # Create a new binary string with the bit set\n            new_binary_str = binary_str[:i] + '1' + binary_str[i+1:]\n            # Convert the new binary string back to an integer\n            return int(new_binary_str, 2)\n    \n    # If no unset bit is found, it means all bits are set\n    # In this case, append a '1' to the left of the binary string\n    new_binary_str = '1' + binary_str\n    return int(new_binary_str, 2)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15]], "plus_fail_tests": [[255]]}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "\ndef highest_Power_of_2(n: int) -> int:\n    # Start with the smallest power of 2, which is 1 (2^0)\n    power = 1\n    \n    # Keep multiplying by 2 until the next power would exceed n\n    while power * 2 <= n:\n        power *= 2\n    \n    # Return the largest power of 2 that is less than or equal to n\n    return power\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "\nimport math\n\ndef volume_cone(radius: float, height: float) -> float:\n    # Calculate the volume of the cone using the formula\n    volume = (1/3) * math.pi * (radius ** 2) * height\n    # Return the calculated volume\n    return volume\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "\ndef find_lucas(n: int) -> int:\n    # Base cases for the first two Lucas numbers\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    \n    # Initialize the first two Lucas numbers\n    a, b = 2, 1\n    \n    # Iteratively calculate the nth Lucas number\n    for _ in range(2, n + 1):\n        # Calculate the next Lucas number\n        a, b = b, a + b\n    \n    # Return the nth Lucas number\n    return b\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "\ndef add_string(elements, format_string):\n    # Create an empty list to store the formatted strings\n    formatted_list = []\n    \n    # Iterate over each element in the input list\n    for element in elements:\n        # Format the current element using the format string\n        formatted_element = format_string.format(element)\n        \n        # Append the formatted string to the result list\n        formatted_list.append(formatted_element)\n    \n    # Return the list of formatted strings\n    return formatted_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "\ndef convert_list_dictionary(ids, names, scores):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the indices of the input lists\n    for i in range(len(ids)):\n        # Create a nested dictionary for each index\n        nested_dict = {ids[i]: {names[i]: scores[i]}}\n        # Append the nested dictionary to the result list\n        result.append(nested_dict)\n    \n    # Return the final list of nested dictionaries\n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["S001", "S002", "S003", "S004"], ["Adina Park", "Leyton Marsh", "Duncan Boyle", "Saim Richards"], [[1, 2, 3], [4, 5, 6], {"a": "x", "b": "y", "c": "z"}]]]}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "\ndef get_max_sum(n: int) -> int:\n    # Dictionary to store already computed results for memoization\n    memo = {}\n\n    # Helper function to compute f(x) using recursion and memoization\n    def f(x: int) -> int:\n        # If the result for x is already computed, return it\n        if x in memo:\n            return memo[x]\n        # Base case: if x is 0, the maximum sum is 0\n        if x == 0:\n            return 0\n        # Calculate the sum of f(x//2), f(x//3), f(x//4), and f(x//5)\n        sum_parts = f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5)\n        # The result is the maximum of sum_parts and x itself\n        result = max(sum_parts, x)\n        # Store the result in the memo dictionary\n        memo[x] = result\n        return result\n\n    # Return the result of f(n)\n    return f(n)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "\ndef check_distinct(t: tuple) -> bool:\n    # Convert the tuple to a set, which removes duplicates\n    unique_elements = set(t)\n    # Compare the length of the set with the length of the tuple\n    # If they are equal, there are no duplicates\n    return len(unique_elements) == len(t)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "\ndef first_non_repeating_character(s: str) -> str:\n    # Create a dictionary to store the count of each character\n    char_count = {}\n    \n    # Count the occurrences of each character in the string\n    for c in s:\n        if c in char_count:\n            char_count[c] += 1\n        else:\n            char_count[c] = 1\n    \n    # Find the first character with a count of 1\n    for c in s:\n        if char_count[c] == 1:\n            return c\n    \n    # If no non-repeating character is found, return None\n    return None\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "\ndef median_numbers(a: int, b: int, c: int) -> float:\n    # Step 1: Create a list of the three numbers\n    numbers = [a, b, c]\n    \n    # Step 2: Sort the list\n    numbers.sort()\n    \n    # Step 3: Return the second element of the sorted list as a float\n    return float(numbers[1])\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "\ndef minimum(a: int, b: int) -> int:\n    # Check if the first number is less than or equal to the second number\n    if a <= b:\n        # If true, return the first number\n        return a\n    else:\n        # Otherwise, return the second number\n        return b\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "\ndef sum_of_digits(numbers):\n    # Initialize the total sum of digits to 0\n    total_sum = 0\n    \n    # Iterate over each number in the list\n    for number in numbers:\n        # Convert the number to a string to access each digit\n        str_number = str(number)\n        \n        # Iterate over each character in the string representation of the number\n        for char in str_number:\n            # Convert the character back to an integer\n            digit = int(char)\n            \n            # Add the digit to the total sum\n            total_sum += digit\n    \n    # Return the total sum of all digits\n    return total_sum\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 20, 4, 5, "b", 70, "a"]]]], "plus_fail_tests": [[[-10, 15, 0, -5, 2]]]}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "\ndef heap_queue_largest(numbers, n):\n    # Sort the list in descending order\n    sorted_numbers = sorted(numbers, reverse=True)\n    # Select the first 'n' elements from the sorted list\n    largest_numbers = sorted_numbers[:n]\n    # Return the 'n' largest numbers\n    return largest_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "\ndef check_tuplex(tuple_data: tuple, element) -> bool:\n    # Use the 'in' keyword to check if the element is in the tuple\n    return element in tuple_data\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "\ndef find_Parity(number: int) -> bool:\n    # Check if the number is odd by using the modulus operator\n    # If the remainder when divided by 2 is not zero, it's odd\n    if number % 2 != 0:\n        return True\n    else:\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "\ndef min_product_tuple(tuples_list):\n    # Initialize min_product to a very large number\n    min_product = float('inf')\n    \n    # Iterate over each tuple in the list\n    for t in tuples_list:\n        # Calculate the product of the two numbers in the tuple\n        product = t[0] * t[1]\n        \n        # If the calculated product is less than the current min_product, update min_product\n        if product < min_product:\n            min_product = product\n    \n    # Return the smallest product found\n    return min_product\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "\ndef min_val(lst):\n    # Initialize min_value to None\n    min_value = None\n    \n    # Iterate over each element in the list\n    for x in lst:\n        # Check if the element is a number (int or float)\n        if isinstance(x, (int, float)):\n            # If min_value is None or x is smaller, update min_value\n            if min_value is None or x < min_value:\n                min_value = x\n    \n    # Return the smallest number found\n    return min_value\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["Python", 10, 5, 2.5, 2.5, "version"]]]}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "\ndef remove_odd(numbers):\n    # Create an empty list to store even numbers\n    even_numbers = []\n    \n    # Iterate over each number in the input list\n    for number in numbers:\n        # Check if the number is even\n        if number % 2 == 0:\n            # If even, add it to the even_numbers list\n            even_numbers.append(number)\n    \n    # Return the list of even numbers\n    return even_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "\ndef extract_nth_element(list_of_tuples, n):\n    # Initialize an empty list to store the nth elements\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tuple_item in list_of_tuples:\n        # Append the nth element of the current tuple to the result list\n        result.append(tuple_item[n])\n    \n    # Return the list of nth elements\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "\ndef max_Product(arr):\n    # Initialize the two largest and two smallest numbers\n    max1, max2 = float('-inf'), float('-inf')\n    min1, min2 = float('inf'), float('inf')\n    \n    # Iterate through the array to find the two largest and two smallest numbers\n    for num in arr:\n        # Update the largest numbers\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n        \n        # Update the smallest numbers\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    \n    # Calculate the products\n    product_max = max1 * max2\n    product_min = min1 * min2\n    \n    # Determine the pair with the highest product\n    if product_max > product_min:\n        result = (max1, max2)\n    else:\n        result = (min1, min2)\n    \n    # Return the pair in ascending order\n    return tuple(sorted(result))\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[0, -1, -2, -4, 5, 0, -6]]], "plus_fail_tests": [[[10, -20, 30, -40, 50, -60, 70, -80, 90, -100]]]}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "\ndef overlapping(seq1, seq2):\n    # Iterate over each element in the first sequence\n    for element in seq1:\n        # Check if the current element is present in the second sequence\n        if element in seq2:\n            # If a common element is found, return True\n            return True\n    # If no common elements are found, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "\ndef Find_Max(list_of_lists):\n    # Start with the first sublist as the maximum\n    max_list = list_of_lists[0]\n    \n    # Iterate through each sublist in the input list\n    for sublist in list_of_lists:\n        # If the current sublist's length is greater than the max_list's length, update max_list\n        if len(sublist) > len(max_list):\n            max_list = sublist\n    \n    # Return the sublist with the maximum length\n    return max_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "\ndef round_and_sum(numbers):\n    # Initialize a variable to store the sum of rounded numbers\n    rounded_sum = 0\n    \n    # Iterate over each number in the list\n    for number in numbers:\n        # Round the number to the nearest integer and add it to the sum\n        rounded_sum += round(number)\n    \n    # Calculate the length of the list\n    length_of_list = len(numbers)\n    \n    # Multiply the sum of rounded numbers by the length of the list\n    result = rounded_sum * length_of_list\n    \n    # Return the final result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "\ndef concatenate_tuple(tup: tuple) -> str:\n    # Convert each element of the tuple to a string\n    string_elements = map(str, tup)\n    \n    # Join the string elements with a hyphen as the delimiter\n    result = '-'.join(string_elements)\n    \n    # Return the concatenated string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "\ndef cube_Sum(n: int) -> int:\n    # Initialize the sum of cubes to 0\n    sum_cubes = 0\n    \n    # Loop over the first n even natural numbers\n    for i in range(1, n + 1):\n        # Calculate the i-th even number\n        even_number = 2 * i\n        # Add the cube of the even number to the sum\n        sum_cubes += even_number ** 3\n    \n    # Return the total sum of cubes\n    return sum_cubes\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "\ndef find_Average_Of_Cube(n: int) -> float:\n    # Initialize the sum of cubes to 0\n    sum_of_cubes = 0\n    \n    # Loop through each number from 1 to n\n    for i in range(1, n + 1):\n        # Add the cube of the current number to the sum\n        sum_of_cubes += i ** 3\n    \n    # Calculate the average by dividing the sum of cubes by n\n    average = sum_of_cubes / n\n    \n    # Return the calculated average\n    return average\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "\ndef extract_rear(strings: tuple) -> list:\n    # Initialize an empty list to store the last characters\n    rear_characters = []\n    \n    # Iterate over each string in the input tuple\n    for string in strings:\n        # Append the last character of the current string to the list\n        rear_characters.append(string[-1])\n    \n    # Return the list of last characters\n    return rear_characters\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "\ndef count_element_in_list(list_of_sublists, element):\n    # Initialize a counter to keep track of sublists containing the element\n    count = 0\n    \n    # Iterate over each sublist in the list of sublists\n    for sublist in list_of_sublists:\n        # Check if the element is present in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    \n    # Return the total count of sublists containing the element\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "\ndef filter_oddnumbers(numbers):\n    # Initialize an empty list to store odd numbers\n    odd_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is odd\n        if number % 2 != 0:\n            # If it is odd, append it to the odd_numbers list\n            odd_numbers.append(number)\n    \n    # Return the list of odd numbers\n    return odd_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "\ndef change_date_format(date: str) -> str:\n    # Split the input date string by the '-' delimiter\n    parts = date.split('-')\n    \n    # Rearrange the parts to form the new date format \"dd-mm-yyyy\"\n    new_date = f\"{parts[2]}-{parts[1]}-{parts[0]}\"\n    \n    # Return the newly formatted date string\n    return new_date\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["2021-1-026"]]}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    # Calculate the directrix using the formula for the directrix of a parabola\n    # The directrix is given by the formula: y = - (b^2 - 4ac + 1) / (4a)\n    directrix = -(b**2 - 4*a*c + 1) / (4*a)\n    \n    # Return the directrix as an integer\n    return int(directrix)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 3, 2]], "plus_fail_tests": [[0, 0, 0]]}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "\ndef and_tuples(tuple1, tuple2):\n    # Initialize an empty list to store the results of the bitwise AND operations\n    result = []\n    \n    # Iterate over the elements of both tuples simultaneously\n    for a, b in zip(tuple1, tuple2):\n        # Perform bitwise AND operation and append the result to the list\n        result.append(a & b)\n    \n    # Convert the list to a tuple and return it\n    return tuple(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "\ndef shell_sort(arr):\n    # Get the length of the array\n    n = len(arr)\n    # Initialize the gap size\n    gap = n // 2\n    \n    # Continue the process until the gap is reduced to 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Store the current element in a temporary variable\n            temp = arr[i]\n            # Initialize j to the current index\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Place the temp element at its correct position\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    # Return the sorted array\n    return arr\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "\ndef median_trapezium(base1: int, base2: int, height: int) -> int:\n    # Calculate the average of the two bases\n    median_length = (base1 + base2) / 2\n    # Return the median length as an integer\n    return int(median_length)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[6, 9, 4]], "plus_fail_tests": [[2.3, 4.7, 3.9]]}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "\ndef check_greater(arr, num):\n    # Iterate through each element in the array\n    for element in arr:\n        # If the number is less than or equal to the current element\n        if num <= element:\n            # Return False as the number is not greater than this element\n            return False\n    # If the loop completes, the number is greater than all elements\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "\ndef multiple_to_single(numbers: list) -> int:\n    # Step 1: Convert each integer in the list to a string\n    string_numbers = [str(number) for number in numbers]\n    \n    # Step 2: Concatenate all the string representations\n    concatenated_string = ''.join(string_numbers)\n    \n    # Step 3: Convert the concatenated string back to an integer\n    result = int(concatenated_string)\n    \n    # Step 4: Return the resulting integer\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "\ndef remove_odd(s: str) -> str:\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Loop through the string starting from index 1 with a step of 2 to get odd indices\n    for i in range(1, len(s), 2):\n        # Append the character at the current odd index to the result\n        result += s[i]\n    \n    # Return the result string containing only characters at odd indices\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "\ndef neg_nos(nums):\n    # Initialize an empty list to store negative numbers\n    negative_numbers = []\n    \n    # Iterate over each number in the input list\n    for num in nums:\n        # Check if the number is negative\n        if num < 0:\n            # If negative, append it to the negative_numbers list\n            negative_numbers.append(num)\n    \n    # Return the list of negative numbers\n    return negative_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "\ndef last_Digit(n: int) -> int:\n    # Use modulus operator to get the last digit of the number\n    last_digit = n % 10\n    # Return the last digit\n    return last_digit\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-987]]}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "\ndef surfacearea_cube(side_length: int) -> int:\n    # Calculate the area of one face of the cube\n    face_area = side_length * side_length\n    \n    # Calculate the total surface area by multiplying the face area by 6\n    total_surface_area = 6 * face_area\n    \n    # Return the total surface area\n    return total_surface_area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "\ndef find_adverb_position(sentence: str):\n    # Split the sentence into words\n    words = sentence.split()\n    # Initialize the current index to track the position in the original sentence\n    current_index = 0\n    \n    # Iterate over each word\n    for word in words:\n        # Strip punctuation from the end of the word\n        cleaned_word = word.rstrip('.,!?;:')\n        \n        # Check if the cleaned word ends with \"ly\"\n        if cleaned_word.endswith(\"ly\"):\n            # Calculate the starting and ending indices\n            starting_index = current_index\n            ending_index = current_index + len(cleaned_word)\n            # Return the tuple with starting index, ending index, and the adverb\n            return (starting_index, ending_index, cleaned_word)\n        \n        # Update the current index for the next word\n        current_index += len(word) + 1  # +1 for the space\n    \n    # If no adverb is found, return None\n    return None\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["awaquicklyy"]]}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "\ndef index_multiplication(tuple1: tuple, tuple2: tuple) -> tuple:\n    # Initialize an empty list to store the result tuples\n    result = []\n    \n    # Iterate over pairs of inner tuples from tuple1 and tuple2\n    for (a, b), (c, d) in zip(tuple1, tuple2):\n        # Calculate the products of corresponding elements\n        product1 = a * c\n        product2 = b * d\n        # Append the result tuple to the result list\n        result.append((product1, product2))\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "\ndef cal_sum(n: int) -> int:\n    # Initialize the first three Perrin numbers\n    perrin = [3, 0, 2]\n    \n    # If n is less than or equal to 3, return the sum of the first n numbers\n    if n <= 3:\n        return sum(perrin[:n])\n\n    # Calculate the rest of the Perrin numbers up to the nth number\n    for i in range(3, n):\n        # Calculate the next Perrin number\n        next_perrin = perrin[i-2] + perrin[i-3]\n        # Append the new number to the list\n        perrin.append(next_perrin)\n\n    # Return the total sum of the first n Perrin numbers\n    return sum(perrin)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[-5]]}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "\ndef count_Occurrence(input_tuple: tuple, input_list: list) -> int:\n    # Initialize a counter to keep track of occurrences\n    counter = 0\n    \n    # Iterate over each element in the tuple\n    for element in input_tuple:\n        # Check if the current element is in the list\n        if element in input_list:\n            # Increment the counter if the element is found in the list\n            counter += 1\n    \n    # Return the total count of occurrences\n    return counter\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 1, 1, 2, 2, 2, 3, 3, 3], [1, 1, 2, 2, 3, 3]]]}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "\ndef cube_nums(nums):\n    # Create an empty list to store the cubed values\n    cubed_list = []\n    \n    # Iterate over each number in the input list\n    for num in nums:\n        # Calculate the cube of the current number\n        cubed_value = num ** 3\n        \n        # Append the cubed value to the cubed_list\n        cubed_list.append(cubed_value)\n    \n    # Return the list of cubed values\n    return cubed_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "\ndef extract_string(string_list, size):\n    # Initialize an empty list to store strings of the specified length\n    result = []\n    \n    # Iterate over each string in the input list\n    for string in string_list:\n        # Check if the length of the current string matches the specified size\n        if len(string) == size:\n            # If it matches, add the string to the result list\n            result.append(string)\n    \n    # Return the list of strings that have the specified length\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "\ndef remove_whitespaces(s: str) -> str:\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is not a whitespace\n        if not char.isspace():\n            # Append the non-whitespace character to the result\n            result += char\n    \n    # Return the result string with all whitespaces removed\n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\n\t"]]}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "\ndef text_match_wordz(input_string: str) -> bool:\n    # Iterate over each character in the input string\n    for char in input_string:\n        # Check if the current character is 'z'\n        if char == 'z':\n            # If 'z' is found, return True\n            return True\n    # If no 'z' is found after checking all characters, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "\ndef check_monthnumb_number(month_number: int) -> bool:\n    # Set of month numbers that have 31 days\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    # Check if the given month number is in the set of months with 31 days\n    return month_number in months_with_31_days\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "\ndef reverse_string_list(strings: list) -> list:\n    # Initialize an empty list to store the reversed strings\n    reversed_list = []\n    \n    # Iterate over each string in the input list\n    for s in strings:\n        # Reverse the string using slicing and append to the reversed_list\n        reversed_list.append(s[::-1])\n    \n    # Return the list of reversed strings\n    return reversed_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "\ndef Find_Min(list_of_lists):\n    # If the input list is empty, return an empty list\n    if not list_of_lists:\n        return []\n    \n    # Assume the first sublist is the shortest initially\n    shortest_sublist = list_of_lists[0]\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # If the current sublist is shorter than the shortest found so far\n        if len(sublist) < len(shortest_sublist):\n            # Update the shortest sublist\n            shortest_sublist = sublist\n    \n    # Return the shortest sublist found\n    return shortest_sublist\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "\ndef rectangle_area(length: int, width: int) -> int:\n    # Calculate the area of the rectangle by multiplying length and width\n    area = length * width\n    # Return the calculated area\n    return area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "\ndef remove_uppercase(s: str) -> str:\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Boolean flag to track if we are in an uppercase sequence\n    in_uppercase = False\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is uppercase\n        if char.isupper():\n            # If it is uppercase, set the flag to True\n            in_uppercase = True\n        else:\n            # If it is not uppercase and we were in an uppercase sequence\n            if in_uppercase:\n                # Set the flag to False as we are exiting the uppercase sequence\n                in_uppercase = False\n            # Append the non-uppercase character to the result\n            result += char\n    \n    # Return the final result string\n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["ThiS%^%!s&a(mY)TesTStR%i*ng"]]}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "\ndef Extract(list_of_lists):\n    # Initialize an empty list to store the first elements\n    first_elements = []\n    \n    # Iterate over each sublist in the input list\n    for sublist in list_of_lists:\n        # Append the first element of the current sublist to the first_elements list\n        first_elements.append(sublist[0])\n    \n    # Return the list of first elements\n    return first_elements\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "\ndef combinations_list(elements):\n    # This will store all the combinations\n    result = []\n    \n    # Helper function to generate combinations\n    def generate_combinations(current_combination, index):\n        # Add the current combination to the result\n        result.append(current_combination)\n        \n        # Iterate over the remaining elements to generate new combinations\n        for i in range(index, len(elements)):\n            # Include the current element and move to the next\n            generate_combinations(current_combination + [elements[i]], i + 1)\n    \n    # Start generating combinations from an empty list and index 0\n    generate_combinations([], 0)\n    \n    return result\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["orange", "red", "green", "blue"]]], "plus_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]]]}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "\ndef max_subarray_product(arr):\n    if not arr:\n        return 0\n    \n    max_product = arr[0]\n    current_max = arr[0]\n    current_min = arr[0]\n    \n    for num in arr[1:]:\n        if num < 0:\n            current_max, current_min = current_min, current_max\n        \n        current_max = max(num, current_max * num)\n        current_min = min(num, current_min * num)\n        \n        max_product = max(max_product, current_max)\n    \n    return max_product\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "\ndef drop_empty(d: dict) -> dict:\n    # Initialize an empty dictionary to store non-empty items\n    non_empty_dict = {}\n    \n    # Iterate over each key-value pair in the input dictionary\n    for key, value in d.items():\n        # Check if the value is not None\n        if value is not None:\n            # Add the key-value pair to the new dictionary\n            non_empty_dict[key] = value\n    \n    # Return the new dictionary containing only non-empty items\n    return non_empty_dict\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "\ndef max_product(arr):\n    # If the array is empty, return 0 as there is no subsequence\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    # Initialize max_product array with the values of arr itself\n    max_product = arr[:]\n    \n    # Iterate over each element in the array starting from the second element\n    for i in range(1, n):\n        # Check all previous elements to see if they can form an increasing subsequence\n        for j in range(i):\n            if arr[j] < arr[i]:\n                # Update max_product[i] with the maximum product possible by including arr[i]\n                max_product[i] = max(max_product[i], max_product[j] * arr[i])\n    \n    # Return the maximum value found in max_product array\n    return max(max_product)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 100, 4, 5, 150, 6]]], "plus_fail_tests": [[[2, 3, 3, 4, 5, 3, 6]]]}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "\ndef add_pairwise(input_tuple):\n    # Initialize an empty list to store the sums\n    result = []\n    \n    # Iterate over the tuple, stopping before the last element\n    for i in range(len(input_tuple) - 1):\n        # Calculate the sum of the current element and the next element\n        pair_sum = input_tuple[i] + input_tuple[i + 1]\n        # Append the sum to the result list\n        result.append(pair_sum)\n    \n    # Convert the list of sums to a tuple\n    result_tuple = tuple(result)\n    \n    # Return the resulting tuple\n    return result_tuple\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "\ndef find_remainder(arr, n):\n    # Initialize the product to 1\n    product = 1\n    \n    # Iterate through each number in the array\n    for number in arr:\n        # Multiply the current product by the number\n        product *= number\n    \n    # Calculate the remainder of the product divided by n\n    remainder = product % n\n    \n    # Return the remainder\n    return remainder\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "\ndef check_Consecutive(lst: list) -> bool:\n    # Step 1: Sort the list\n    lst.sort()\n    \n    # Step 2: Iterate through the sorted list\n    for i in range(len(lst) - 1):\n        # Step 3: Check if the next element is exactly one more than the current element\n        if lst[i] + 1 != lst[i + 1]:\n            # If not, the list is not consecutive\n            return False\n    \n    # Step 4: If all elements are consecutive, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "\ndef tuple_intersection(list1, list2):\n    # Convert each tuple in list1 to a set and store in set1\n    set1 = {frozenset(t) for t in list1}\n    \n    # Convert each tuple in list2 to a set and store in set2\n    set2 = {frozenset(t) for t in list2}\n    \n    # Find the intersection of set1 and set2\n    intersection = set1.intersection(set2)\n    \n    # Convert each frozenset in the intersection back to a sorted tuple\n    result = {tuple(sorted(s)) for s in intersection}\n    \n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6, 4], [7, 8, 9]], [[4, 5, 6], [1, 2, 3]]]]}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "\ndef replace_char(s: str, old_char: str, new_char: str) -> str:\n    # Use the replace method to replace all occurrences of old_char with new_char\n    modified_string = s.replace(old_char, new_char)\n    # Return the modified string\n    return modified_string\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "\ndef big_sum(arr):\n    # Find the smallest number in the array\n    smallest = min(arr)\n    # Find the largest number in the array\n    largest = max(arr)\n    # Calculate the sum of the smallest and largest numbers\n    result = smallest + largest\n    # Return the result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "\ndef sort_counter(d: dict) -> list:\n    # Convert the dictionary into a list of tuples (key, value)\n    items = list(d.items())\n    \n    # Sort the list of tuples by the second element (value) in descending order\n    sorted_items = sorted(items, key=lambda item: item[1], reverse=True)\n    \n    # Return the sorted list of tuples\n    return sorted_items\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "\ndef is_lower(s: str) -> str:\n    # Convert the input string to lowercase using the lower() method\n    return s.lower()\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "\ndef remove_lowercase(input_string: str) -> str:\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the input string\n    for char in input_string:\n        # Check if the character is not lowercase\n        if not char.islower():\n            # Append the character to the result if it is not lowercase\n            result += char\n    \n    # Return the result string with all lowercase substrings removed\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "\ndef first_Digit(n: int) -> int:\n    # Convert the number to a string\n    n_str = str(n)\n    # Get the first character of the string\n    first_char = n_str[0]\n    # Convert the first character back to an integer\n    first_digit = int(first_char)\n    # Return the first digit\n    return first_digit\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "\ndef difference(n: int) -> int:\n    # Initialize sums\n    sum_of_cubes = 0\n    sum_of_numbers = 0\n    \n    # Calculate the sums\n    for i in range(1, n + 1):\n        sum_of_cubes += i ** 3\n        sum_of_numbers += i\n    \n    # Calculate the difference\n    diff = sum_of_cubes - sum_of_numbers\n    \n    # Return the result\n    return diff\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "\ndef Split(numbers):\n    # Create an empty list to store odd numbers\n    odd_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is odd\n        if number % 2 != 0:\n            # Add the odd number to the odd_numbers list\n            odd_numbers.append(number)\n    \n    # Return the list of odd numbers\n    return odd_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "\ndef digit_distance_nums(a: int, b: int) -> int:\n    # Convert both numbers to strings\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Determine the maximum length of the two numbers\n    max_length = max(len(str_a), len(str_b))\n    \n    # Pad the shorter number with leading zeros\n    str_a = str_a.zfill(max_length)\n    str_b = str_b.zfill(max_length)\n    \n    # Initialize the total difference\n    total_difference = 0\n    \n    # Iterate over the digits of both numbers\n    for digit_a, digit_b in zip(str_a, str_b):\n        # Calculate the absolute difference and add to the total\n        total_difference += abs(int(digit_a) - int(digit_b))\n    \n    # Return the total difference\n    return total_difference\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[12345, 9]]}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "\ndef find_Odd_Pair(arr, n):\n    # Initialize counters for odd and even numbers\n    odd_count = 0\n    even_count = 0\n    \n    # Count the number of odd and even numbers in the array\n    for num in arr:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with an odd XOR is the product of odd_count and even_count\n    return odd_count * even_count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2], 10]]}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "\ndef toggle_string(s: str) -> str:\n    # Initialize an empty list to store the toggled characters\n    toggled_chars = []\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Convert to lowercase and add to the list\n            toggled_chars.append(char.lower())\n        # Check if the character is lowercase\n        elif char.islower():\n            # Convert to uppercase and add to the list\n            toggled_chars.append(char.upper())\n        else:\n            # If it's neither, just add the character as is (for non-alphabetic characters)\n            toggled_chars.append(char)\n    \n    # Join the list of characters into a single string\n    toggled_string = ''.join(toggled_chars)\n    \n    # Return the final toggled string\n    return toggled_string\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "\ndef max_sub_array_sum(arr: list, n: int) -> int:\n    # Initialize the maximum sum so far to a very small number\n    max_so_far = float('-inf')\n    # Initialize the maximum sum ending at the current position to 0\n    max_ending_here = 0\n\n    # Iterate over each element in the array\n    for i in range(n):\n        # Update the maximum sum ending here by adding the current element\n        max_ending_here += arr[i]\n        \n        # Update the maximum sum so far if the current max ending here is greater\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        \n        # If the current max ending here is negative, reset it to 0\n        if max_ending_here < 0:\n            max_ending_here = 0\n\n    # Return the maximum sum found\n    return max_so_far\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 0]]}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "\ndef union_elements(t1: tuple, t2: tuple) -> tuple:\n    # Combine both tuples into a single list\n    combined_list = list(t1) + list(t2)\n    \n    # Convert the list to a set to remove duplicates\n    unique_elements = set(combined_list)\n    \n    # Convert the set back to a list and sort it\n    sorted_list = sorted(unique_elements)\n    \n    # Convert the sorted list to a tuple\n    result_tuple = tuple(sorted_list)\n    \n    # Return the resulting tuple\n    return result_tuple\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "\ndef check(n: int) -> bool:\n    # Convert the number to a string and reverse it\n    reversed_str = str(n)[::-1]\n    # Convert the reversed string back to an integer\n    reversed_number = int(reversed_str)\n    # Double the reversed number\n    doubled_reversed = 2 * reversed_number\n    # Check if the original number is one less than the doubled reversed number\n    return n == doubled_reversed - 1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "\ndef Find_Max_Length(list_of_lists):\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Calculate the length of the current sublist\n        current_length = len(sublist)\n        \n        # Update max_length if the current sublist is longer\n        if current_length > max_length:\n            max_length = current_length\n    \n    # Return the maximum length found\n    return max_length\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "\ndef extract_values(input_string: str) -> list:\n    # Initialize an empty list to store the extracted values\n    results = []\n    # Initialize a counter to iterate through the string\n    i = 0\n    # Loop through the string\n    while i < len(input_string):\n        # Check if the current character is a double quote\n        if input_string[i] == '\"':\n            # Move to the next character after the opening quote\n            i += 1\n            # Initialize an empty string to collect the value\n            value = ''\n            # Collect characters until the next double quote is found\n            while i < len(input_string) and input_string[i] != '\"':\n                value += input_string[i]\n                i += 1\n            # Add the collected value to the results list\n            results.append(value)\n        # Move to the next character\n        i += 1\n    # Return the list of extracted values\n    return results\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\"This is a \"nested\"\" input string.\""]]}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "\ndef sumofFactors(n: int) -> int:\n    # Initialize the sum of even factors to 0\n    sum_even_factors = 0\n    \n    # Loop through all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if the factor is even\n            if i % 2 == 0:\n                # Add the even factor to the sum\n                sum_even_factors += i\n    \n    # Return the sum of even factors\n    return sum_even_factors\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "\ndef count_Pairs(lst: list, n: int) -> int:\n    # Initialize a counter for the number of valid pairs\n    count = 0\n    \n    # Loop through each element in the list using index i\n    for i in range(n):\n        # Loop through each subsequent element using index j\n        for j in range(i + 1, n):\n            # Check if the elements at index i and j are different\n            if lst[i] != lst[j]:\n                # Increment the counter if they are different\n                count += 1\n    \n    # Return the total count of valid pairs\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "\ndef split(s: str) -> list:\n    # Convert the string 's' into a list of characters using the list() function\n    return list(s)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "\ndef sum_digits(n: int) -> int:\n    # Convert the integer to a string to iterate over each digit\n    str_n = str(n)\n    \n    # Initialize the sum of digits to 0\n    total_sum = 0\n    \n    # Iterate over each character in the string representation of the number\n    for char in str_n:\n        # Convert the character back to an integer and add it to the total sum\n        total_sum += int(char)\n    \n    # Return the total sum of the digits\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "\ndef issort_list(lst):\n    # Iterate through the list up to the second last element\n    for i in range(len(lst) - 1):\n        # Compare the current element with the next element\n        if lst[i] > lst[i + 1]:\n            # If the current element is greater, the list is not sorted\n            return False\n    # If no such pair is found, the list is sorted\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "\ndef empty_list(N: int) -> list:\n    # Create a list with N empty dictionaries using list comprehension\n    return [{} for _ in range(N)]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "\ndef find_Max_Num(digits):\n    # Step 1: Sort the digits in descending order\n    sorted_digits = sorted(digits, reverse=True)\n    \n    # Step 2: Convert each digit to a string and concatenate them\n    max_num_str = ''.join(str(digit) for digit in sorted_digits)\n    \n    # Step 3: Convert the concatenated string back to an integer\n    max_num = int(max_num_str)\n    \n    # Step 4: Return the resulting integer\n    return max_num\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "\ndef sort_sublists(list_of_lists):\n    # Iterate over each sublist in the main list\n    for sublist in list_of_lists:\n        # Sort the current sublist in place\n        sublist.sort()\n    # Return the modified list of lists\n    return list_of_lists\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "\ndef two_unique_nums(nums):\n    # Step 1: Count occurrences of each number\n    count_dict = {}\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Step 2: Filter numbers that appear exactly once\n    unique_nums = []\n    for num, count in count_dict.items():\n        if count == 1:\n            unique_nums.append(num)\n    \n    # Step 3: Return the list of unique numbers\n    return unique_nums\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "\ndef unique_product(numbers):\n    # Step 1: Convert the list to a set to get unique numbers\n    unique_numbers = set(numbers)\n    \n    # Step 2: Initialize the product variable\n    product = 1\n    \n    # Step 3: Calculate the product of unique numbers\n    for number in unique_numbers:\n        product *= number\n    \n    # Step 4: Return the product\n    return product\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "\ndef is_Sub_Array(list1, list2):\n    # If list2 is empty, it is trivially a sublist of any list\n    if not list2:\n        return True\n    \n    # If list1 is shorter than list2, list2 cannot be a sublist\n    if len(list1) < len(list2):\n        return False\n    \n    # Iterate over each possible starting index in list1\n    for i in range(len(list1) - len(list2) + 1):\n        # Check if the slice of list1 matches list2\n        if list1[i:i + len(list2)] == list2:\n            return True\n    \n    # If no match is found, return False\n    return False\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5], [1, 3, 5]]]}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "\ndef last_Digit_Factorial(n: int) -> int:\n    # If n is less than 5, calculate the factorial and return the last digit\n    if n < 5:\n        factorial = 1\n        for i in range(1, n + 1):\n            factorial *= i\n        return factorial % 10\n    else:\n        # If n is 5 or greater, the factorial will end in 0\n        return 0\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2.5]]}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "\ndef interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved elements\n    interleaved_list = []\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Append the element from the first list at index i\n        interleaved_list.append(list1[i])\n        # Append the element from the second list at index i\n        interleaved_list.append(list2[i])\n        # Append the element from the third list at index i\n        interleaved_list.append(list3[i])\n    \n    # Return the interleaved list\n    return interleaved_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "\ndef find_dissimilar(tuple1: tuple, tuple2: tuple) -> tuple:\n    # Convert tuples to sets\n    set1 = set(tuple1)\n    set2 = set(tuple2)\n    \n    # Find elements unique to each set\n    unique_in_first = set1 - set2\n    unique_in_second = set2 - set1\n    \n    # Create a list to maintain order based on first appearance\n    dissimilar_elements = []\n    \n    # Add unique elements from the first tuple in order\n    for element in tuple1:\n        if element in unique_in_first:\n            dissimilar_elements.append(element)\n    \n    # Add unique elements from the second tuple in order\n    for element in tuple2:\n        if element in unique_in_second:\n            dissimilar_elements.append(element)\n    \n    # Convert the list to a tuple and return\n    return tuple(dissimilar_elements)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "\ndef extract_even(t):\n    # Initialize an empty list to store the processed elements\n    result = []\n    \n    # Iterate over each element in the tuple\n    for elem in t:\n        # Check if the element is an integer\n        if isinstance(elem, int):\n            # If the integer is even, add it to the result list\n            if elem % 2 == 0:\n                result.append(elem)\n        # Check if the element is a tuple\n        elif isinstance(elem, tuple):\n            # Recursively process the nested tuple and add the result to the list\n            result.append(extract_even(elem))\n    \n    # Convert the list back to a tuple and return it\n    return tuple(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "\ndef opposite_Signs(a: int, b: int) -> bool:\n    # Multiply the two integers\n    product = a * b\n    \n    # Check if the product is less than zero\n    # If it is, the integers have opposite signs\n    return product < 0\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "\n# Helper function to calculate factorial of a number\ndef factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return n * factorial(n - 1)\n\n# Main function to calculate the nth Catalan number\ndef catalan_number(n: int) -> int:\n    # Calculate factorial of 2n\n    factorial_2n = factorial(2 * n)\n    # Calculate factorial of n+1\n    factorial_n1 = factorial(n + 1)\n    # Calculate factorial of n\n    factorial_n = factorial(n)\n    # Calculate the nth Catalan number using the formula\n    catalan_n = factorial_2n // (factorial_n1 * factorial_n)\n    # Return the result\n    return catalan_n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "\ndef surface_Area(base_edge: int, height: int) -> int:\n    # Calculate the area of the base (square)\n    base_area = base_edge * base_edge\n    \n    # Calculate the slant height using the Pythagorean theorem\n    slant_height = ((base_edge / 2) ** 2 + height ** 2) ** 0.5\n    \n    # Calculate the lateral surface area (4 triangles)\n    # Each triangle has an area of (1/2) * base_edge * slant_height\n    # Total lateral surface area is 4 * (1/2) * base_edge * slant_height = 2 * base_edge * slant_height\n    lateral_surface_area = 2 * base_edge * slant_height\n    \n    # Calculate the total surface area\n    total_surface_area = base_area + lateral_surface_area\n    \n    # Return the total surface area rounded to the nearest integer\n    return round(total_surface_area)\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[10, 20]]}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "\ndef split_Arr(arr, n):\n    # Split the list into two parts: from start to n-1 and from n to end\n    first_part = arr[0:n]\n    second_part = arr[n:]\n    \n    # Concatenate the second part with the first part\n    result = second_part + first_part\n    \n    # Return the rearranged list\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "\ndef expensive_items(items, n):\n    # Sort the items by 'price' in descending order\n    sorted_items = sorted(items, key=lambda item: item['price'], reverse=True)\n    # Select the first n items from the sorted list\n    most_expensive_items = sorted_items[:n]\n    # Return the selected items\n    return most_expensive_items\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "\ndef big_diff(lst):\n    # Find the maximum value in the list\n    max_value = max(lst)\n    # Find the minimum value in the list\n    min_value = min(lst)\n    # Calculate the difference between the maximum and minimum values\n    difference = max_value - min_value\n    # Return the difference\n    return difference\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "\ndef list_tuple(lst: list) -> tuple:\n    # Convert the input list to a tuple using the tuple() function\n    result = tuple(lst)\n    # Return the resulting tuple\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "\ndef is_octagonal(n: int) -> int:\n    # Calculate the nth octagonal number using the formula\n    # O_n = n * (3n - 2)\n    return n * (3 * n - 2)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "\ndef perfect_squares(start: int, end: int) -> list:\n    # Initialize an empty list to store perfect squares\n    squares = []\n    \n    # Start with the smallest integer whose square is greater than or equal to start\n    i = 1\n    \n    # Continue while the square of i is within the range\n    while i * i <= end:\n        # Check if the square of i is within the range [start, end]\n        if i * i >= start:\n            # Add the square to the list\n            squares.append(i * i)\n        # Move to the next integer\n        i += 1\n    \n    # Return the list of perfect squares\n    return squares\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1, 0]]}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "\nimport math\n\ndef polar_rect(r: float, theta: float):\n    # Calculate the Cartesian coordinates\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    \n    # Create the Cartesian coordinates tuple\n    cartesian_coords = (x, y)\n    \n    # Create the complex number\n    complex_number = complex(x, y)\n    \n    # Return both the Cartesian coordinates and the complex number\n    return cartesian_coords, complex_number\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[0, 0]]}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "\ndef swap_List(lst):\n    # Check if the list has more than one element\n    if len(lst) < 2:\n        # If not, return the list as is\n        return lst\n    \n    # Swap the first and last elements\n    lst[0], lst[-1] = lst[-1], lst[0]\n    \n    # Return the modified list\n    return lst\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "\ndef combinations_colors(colors: list, n: int) -> list:\n    # Helper function to generate combinations\n    def generate_combinations(current_combination, depth):\n        # If the current combination is of the desired length, add it to the result\n        if depth == n:\n            result.append(current_combination)\n            return\n        # Otherwise, continue building the combination\n        for color in colors:\n            generate_combinations(current_combination + (color,), depth + 1)\n    \n    # List to store the result combinations\n    result = []\n    # Start generating combinations with an empty tuple and depth 0\n    generate_combinations((), 0)\n    return result\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Blue"], 2]], "plus_fail_tests": [[["A", "B", "C", "D"], 4]]}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "\ndef removezero_ip(ip_address: str) -> str:\n    # Split the IP address into its segments\n    segments = ip_address.split('.')\n    \n    # Process each segment to remove leading zeros\n    processed_segments = []\n    for segment in segments:\n        # Convert to integer to remove leading zeros, then back to string\n        processed_segment = str(int(segment))\n        processed_segments.append(processed_segment)\n    \n    # Join the processed segments back into a single IP address string\n    return '.'.join(processed_segments)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["0.0.0.0"]]}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "\ndef diff_even_odd(numbers):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate over each number in the list\n    for number in numbers:\n        # Check if the number is even and first_even is not yet set\n        if first_even is None and number % 2 == 0:\n            first_even = number\n        # Check if the number is odd and first_odd is not yet set\n        if first_odd is None and number % 2 != 0:\n            first_odd = number\n        # If both first_even and first_odd are found, exit the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Return the difference between the first even and first odd numbers\n    return first_even - first_odd\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "\nimport sys\n\n# Define the function tuple_size\ndef tuple_size(tup: tuple) -> int:\n    # Use sys.getsizeof to get the size of the tuple in bytes\n    return sys.getsizeof(tup)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "\ndef find_kth(arr1, arr2, k):\n    # Initialize pointers for both arrays\n    i, j = 0, 0\n    # Initialize a counter to track the number of elements considered\n    count = 0\n    \n    # Loop until we find the k-th element\n    while count < k:\n        # If we have elements left in arr1 and either arr2 is exhausted or arr1[i] is smaller\n        if i < len(arr1) and (j >= len(arr2) or arr1[i] <= arr2[j]):\n            # Increment the count and move the pointer in arr1\n            count += 1\n            i += 1\n            # If we have reached the k-th element, return it\n            if count == k:\n                return arr1[i - 1]\n        else:\n            # Increment the count and move the pointer in arr2\n            count += 1\n            j += 1\n            # If we have reached the k-th element, return it\n            if count == k:\n                return arr2[j - 1]\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 1], [], 3]]}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "\ndef armstrong_number(number: int) -> bool:\n    # Convert the number to a string to easily iterate over digits\n    num_str = str(number)\n    # Determine the number of digits\n    num_digits = len(num_str)\n    # Initialize the sum of powers\n    armstrong_sum = 0\n    \n    # Calculate the sum of each digit raised to the power of the number of digits\n    for digit in num_str:\n        armstrong_sum += int(digit) ** num_digits\n    \n    # Check if the calculated sum is equal to the original number\n    return armstrong_sum == number\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "\ndef sum_average(n: int) -> tuple:\n    # Calculate the sum of the first n natural numbers using the formula\n    sum_n = (n * (n + 1)) // 2\n    \n    # Calculate the average by dividing the sum by n\n    average_n = sum_n / n\n    \n    # Return the sum and average as a tuple\n    return (sum_n, average_n)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    # Perform XOR operation on the two numbers\n    xor_result = a ^ b\n    \n    # Check if the result is a power of two\n    # A number is a power of two if it has exactly one bit set\n    # This can be checked using the condition: n & (n - 1) == 0 and n != 0\n    return xor_result != 0 and (xor_result & (xor_result - 1)) == 0\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "\ndef is_Even(number: int) -> bool:\n    # Check if the number is divisible by 2 with no remainder\n    if number % 2 == 0:\n        return True\n    else:\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "\ndef first_repeated_char(s: str) -> str:\n    # Create an empty set to keep track of seen characters\n    seen_chars = set()\n    \n    # Iterate over each character in the string\n    for c in s:\n        # Check if the character is already in the set\n        if c in seen_chars:\n            # If it is, return this character as it is the first repeated one\n            return c\n        else:\n            # If not, add the character to the set\n            seen_chars.add(c)\n    \n    # If no repeated character is found, return None\n    return None\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "\ndef get_ludic(n: int) -> list:\n    # Create a list of numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    # This will store the ludic numbers\n    ludic_numbers = []\n    \n    # Continue the process until there are no more numbers to process\n    while numbers:\n        # The first number in the list is always a ludic number\n        k = numbers[0]\n        ludic_numbers.append(k)\n        \n        # Remove every k-th number from the list\n        # Start from the k-th position and step by k\n        numbers = [num for i, num in enumerate(numbers) if (i + 1) % k != 0]\n    \n    return ludic_numbers\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[100]]}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "\ndef reverse_words(s: str) -> str:\n    # Split the input string into a list of words\n    words = s.split()\n    \n    # Reverse the list of words\n    reversed_words = words[::-1]\n    \n    # Join the reversed list of words into a single string with spaces\n    reversed_string = ' '.join(reversed_words)\n    \n    # Return the resulting reversed string\n    return reversed_string\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "\ndef radian_degree(degrees: float) -> float:\n    # Define the value of \u03c0 (pi)\n    pi = 3.141592653589793\n    # Convert degrees to radians using the formula: radians = degrees * (\u03c0 / 180)\n    radians = degrees * (pi / 180)\n    # Return the calculated radians\n    return radians\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "\ndef find_literals(text: str, pattern: str) -> tuple:\n    # Find the starting index of the pattern in the text\n    start_index = text.find(pattern)\n    \n    # Check if the pattern is found\n    if start_index != -1:\n        # Calculate the end index\n        end_index = start_index + len(pattern)\n        # Return the pattern, start index, and end index\n        return (pattern, start_index, end_index)\n    \n    # If pattern is not found, return a tuple indicating no match\n    return (\"\", -1, -1)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["", "rfvPtELLC"]]}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "\ndef prime_num(n: int) -> bool:\n    # If the number is less than or equal to 1, it is not prime\n    if n <= 1:\n        return False\n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    # If the number is even and greater than 2, it is not prime\n    if n % 2 == 0:\n        return False\n    # Check for factors from 3 to the square root of n\n    # Only check odd numbers since even numbers are not prime\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    # If no factors were found, the number is prime\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "\ndef bell_Number(n: int) -> int:\n    # Create a 2D list (triangle) with n+1 rows\n    bell_triangle = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Initialize the first element of the triangle as 1\n    bell_triangle[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # Set the first element of the current row to the last element of the previous row\n        bell_triangle[i][0] = bell_triangle[i - 1][i - 1]\n        \n        # Fill the rest of the row\n        for j in range(1, i + 1):\n            # Current element is the sum of the element to the left and the element above\n            bell_triangle[i][j] = bell_triangle[i][j - 1] + bell_triangle[i - 1][j - 1]\n    \n    # Return the first element of the nth row, which is the nth Bell number\n    return bell_triangle[n][0]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "\ndef remove_kth_element(lst, k):\n    # Adjust for 1-based index by subtracting 1 from k\n    # Return a new list that is the concatenation of:\n    # - the sublist from the start to just before index k-1\n    # - the sublist from index k to the end\n    return lst[:k-1] + lst[k:]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "\ndef count_Substrings(s: str) -> int:\n    # Initialize the count of valid substrings\n    count = 0\n    \n    # Iterate over each possible starting index of the substring\n    for i in range(len(s)):\n        # Initialize the sum of digits for the current starting index\n        sum_of_digits = 0\n        \n        # Iterate over each possible ending index of the substring\n        for j in range(i, len(s)):\n            # Add the current digit to the sum\n            sum_of_digits += int(s[j])\n            \n            # Calculate the length of the current substring\n            length_of_substring = j - i + 1\n            \n            # Check if the sum of digits equals the length of the substring\n            if sum_of_digits == length_of_substring:\n                # Increment the count if the condition is met\n                count += 1\n    \n    # Return the total count of valid substrings\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "\ndef max_of_nth(matrix, n):\n    # Initialize an empty list to store the values of the n-th column\n    column_values = []\n    \n    # Iterate over each row in the matrix\n    for row in matrix:\n        # Append the n-th element of the current row to column_values\n        column_values.append(row[n])\n    \n    # Return the maximum value from the collected n-th column values\n    return max(column_values)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "\ndef merge(list_of_lists):\n    # Initialize two empty lists to store the first and second elements\n    first_elements = []\n    second_elements = []\n    \n    # Iterate over each sublist in the input list\n    for sublist in list_of_lists:\n        # Append the first element of the sublist to first_elements\n        first_elements.append(sublist[0])\n        # Append the second element of the sublist to second_elements\n        second_elements.append(sublist[1])\n    \n    # Return a list containing the two lists\n    return [first_elements, second_elements]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "\ndef cummulative_sum(tuple_list):\n    # Initialize the cumulative sum to zero\n    total_sum = 0\n    \n    # Iterate over each tuple in the list\n    for tuple_ in tuple_list:\n        # Iterate over each number in the current tuple\n        for number in tuple_:\n            # Add the number to the cumulative sum\n            total_sum += number\n    \n    # Return the final cumulative sum\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "\ndef average_tuple(tuples_of_tuples):\n    # Initialize an empty list to store the averages\n    averages = []\n    \n    # Iterate over each tuple in the input tuple of tuples\n    for inner_tuple in tuples_of_tuples:\n        # Calculate the sum of the elements in the current tuple\n        total = sum(inner_tuple)\n        # Calculate the average by dividing the total by the number of elements\n        average = total / len(inner_tuple)\n        # Append the calculated average to the averages list\n        averages.append(average)\n    \n    # Return the list of averages\n    return averages\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]]], "plus_fail_tests": [[[[7, 8, 9], [-2, -4, -6], [0, 20, 30]]]]}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "\ndef tuple_modulo(tuple1: tuple, tuple2: tuple) -> tuple:\n    # Initialize an empty list to store the results of the modulo operations\n    result = []\n    \n    # Iterate over the indices of the tuples\n    for i in range(len(tuple1)):\n        # Compute the modulo of the elements at the current index\n        mod_result = tuple1[i] % tuple2[i]\n        # Append the result to the list\n        result.append(mod_result)\n    \n    # Convert the list to a tuple and return it\n    return tuple(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "\ndef move_num(s: str) -> str:\n    # Initialize empty strings for non-numeric and numeric characters\n    non_numeric = ''\n    numeric = ''\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Append to numeric string if it is a digit\n            numeric += char\n        else:\n            # Append to non-numeric string if it is not a digit\n            non_numeric += char\n    \n    # Concatenate non-numeric and numeric strings\n    result = non_numeric + numeric\n    \n    # Return the final result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "\ndef div_list(list1, list2):\n    # Check if both lists have the same length\n    if len(list1) != len(list2):\n        raise ValueError(\"Both lists must have the same length.\")\n    \n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the elements of both lists\n    for i in range(len(list1)):\n        # Perform element-wise division and append the result to the result list\n        result.append(list1[i] / list2[i])\n    \n    # Return the list of results\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "\ndef smallest_num(numbers):\n    # Check if the list is empty\n    if not numbers:\n        return None  # or raise an exception if empty lists are not allowed\n\n    # Initialize the smallest number with the first element of the list\n    smallest = numbers[0]\n\n    # Iterate through each number in the list\n    for number in numbers:\n        # If the current number is smaller than the smallest recorded number\n        if number < smallest:\n            # Update the smallest number\n            smallest = number\n\n    # Return the smallest number found\n    return smallest\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "\ndef largest_subset(nums):\n    # If the list is empty, the largest subset size is 0\n    if not nums:\n        return 0\n    \n    # Sort the numbers to facilitate the divisibility check\n    nums.sort()\n    \n    # Initialize the dp array where each element starts with a subset size of 1\n    dp = [1] * len(nums)\n    \n    # Iterate over each number in the sorted list\n    for i in range(1, len(nums)):\n        # Check all previous numbers to see if they divide the current number\n        for j in range(i):\n            # If nums[i] is divisible by nums[j], update the dp[i]\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    # The result is the maximum value in the dp array\n    return max(dp)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[9, 3, 12, 7, 16, 3, 11, 8, 4, 13, 13]]]}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "\ndef get_median(arr1, arr2, n):\n    # Initialize pointers for both arrays\n    i, j = 0, 0\n    # This will store the merged array\n    merged = []\n    \n    # Merge the two arrays\n    while i < n and j < n:\n        if arr1[i] < arr2[j]:\n            merged.append(arr1[i])\n            i += 1\n        else:\n            merged.append(arr2[j])\n            j += 1\n    \n    # If there are remaining elements in arr1\n    while i < n:\n        merged.append(arr1[i])\n        i += 1\n    \n    # If there are remaining elements in arr2\n    while j < n:\n        merged.append(arr2[j])\n        j += 1\n    \n    # Calculate the median\n    total_length = 2 * n\n    if total_length % 2 == 1:\n        # Odd length, return the middle element\n        return float(merged[total_length // 2])\n    else:\n        # Even length, return the average of the two middle elements\n        mid1 = total_length // 2 - 1\n        mid2 = total_length // 2\n        return (merged[mid1] + merged[mid2]) / 2.0\n\n# Example usage\nassert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1], [2], 0]]}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "\ndef nth_nums(numbers: list, n: int) -> list:\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over each number in the input list\n    for number in numbers:\n        # Compute the n-th power of the current number\n        powered_number = number ** n\n        # Append the computed power to the result list\n        result.append(powered_number)\n    \n    # Return the list containing all the n-th powers\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "\ndef is_upper(s: str) -> str:\n    # Convert the input string to uppercase using the upper() method\n    uppercase_string = s.upper()\n    # Return the uppercase string\n    return uppercase_string\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "\ndef replace_spaces(input_string: str) -> str:\n    # Initialize an empty string to build the result\n    result = \"\"\n    \n    # Iterate over each character in the input string\n    for char in input_string:\n        # If the character is a space, append '%20' to the result\n        if char == ' ':\n            result += '%20'\n        # Otherwise, append the character itself to the result\n        else:\n            result += char\n    \n    # Return the final result string with spaces replaced by '%20'\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "\ndef Split(numbers):\n    # Initialize an empty list to store even numbers\n    even_numbers = []\n    \n    # Iterate over each number in the input list\n    for number in numbers:\n        # Check if the number is even\n        if number % 2 == 0:\n            # If it is even, append it to the even_numbers list\n            even_numbers.append(number)\n    \n    # Return the list of even numbers\n    return even_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "\ndef triangle_area(radius: float) -> float:\n    # If the radius is negative, return None\n    if radius < 0:\n        return None\n    # Calculate the area of the largest inscribed triangle\n    # Area = (1/2) * radius * radius\n    area = 0.5 * radius * radius\n    return area\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[0.5]]}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "\ndef max_difference(tuple_list):\n    # Initialize the maximum difference to zero\n    max_diff = 0\n    \n    # Iterate over each tuple in the list\n    for a, b in tuple_list:\n        # Calculate the absolute difference between the two numbers in the tuple\n        diff = abs(a - b)\n        \n        # Update max_diff if the current difference is greater\n        if diff > max_diff:\n            max_diff = diff\n    \n    # Return the maximum difference found\n    return max_diff\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "\ndef move_zero(lst):\n    # Initialize an empty list to store non-zero elements\n    result = []\n    # Initialize a counter for zeroes\n    zero_count = 0\n    \n    # Iterate through each element in the input list\n    for element in lst:\n        # If the element is not zero, add it to the result list\n        if element != 0:\n            result.append(element)\n        else:\n            # If the element is zero, increment the zero counter\n            zero_count += 1\n    \n    # Append the counted number of zeroes to the end of the result list\n    result.extend([0] * zero_count)\n    \n    # Return the modified list with zeroes moved to the end\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "\ndef noprofit_noloss(cost_price: int, selling_price: int) -> bool:\n    # Check if the cost price is equal to the selling price\n    if cost_price == selling_price:\n        # If they are equal, there is no profit and no loss\n        return True\n    else:\n        # If they are not equal, there is either a profit or a loss\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "\ndef pair_xor_Sum(arr, n):\n    # Initialize the sum of XORs to zero\n    sum_xor = 0\n    \n    # Iterate over each element in the list\n    for i in range(n):\n        # For each element, iterate over the elements that come after it\n        for j in range(i + 1, n):\n            # Calculate the XOR of the current pair\n            xor_value = arr[i] ^ arr[j]\n            # Add the XOR value to the total sum\n            sum_xor += xor_value\n    \n    # Return the total sum of XORs\n    return sum_xor\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "\ndef replace_spaces(s: str) -> str:\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # If the character is a whitespace, replace it with an underscore\n        if char == ' ':\n            result += '_'\n        # If the character is an underscore, replace it with a whitespace\n        elif char == '_':\n            result += ' '\n        # Otherwise, keep the character unchanged\n        else:\n            result += char\n    \n    # Return the modified string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "\ndef heapify(arr, n, i):\n    # Initialize largest as root\n    largest = i\n    left = 2 * i + 1  # left = 2*i + 1\n    right = 2 * i + 2  # right = 2*i + 2\n\n    # If left child is larger than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]  # swap\n\n        # Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n\n    # Build a maxheap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # One by one extract elements\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # swap\n        heapify(arr, i, 0)\n\n    return arr\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "\ndef wind_chill(velocity: float, temperature: float) -> int:\n    # Calculate the wind chill index using the given formula\n    WCI = 13.12 + 0.6215 * temperature - 11.37 * (velocity ** 0.16) + 0.3965 * temperature * (velocity ** 0.16)\n    \n    # Round the wind chill index to the nearest integer\n    rounded_WCI = round(WCI)\n    \n    # Return the rounded wind chill index\n    return rounded_WCI\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "\ndef sample_nam(names: list) -> int:\n    # Initialize the total length to 0\n    total_length = 0\n    \n    # Iterate over each name in the list\n    for name in names:\n        # Check if the first character of the name is uppercase\n        if name[0].isupper():\n            # Add the length of the name to the total length\n            total_length += len(name)\n    \n    # Return the total length of names that start with an uppercase letter\n    return total_length\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["AbCdE", "fGH", "IJKLMnOp", "qrs", "TUVW", "xyz"]]]}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "\ndef subject_marks(marks_list):\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_list = sorted(marks_list, key=lambda x: x[1])\n    return sorted_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "\ndef is_nonagonal(n: int) -> int:\n    # Calculate the nth nonagonal number using the formula\n    nonagonal_number = (7 * n * n - 5 * n) // 2\n    # Return the calculated nonagonal number\n    return nonagonal_number\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "\ndef reverse_Array_Upto_K(arr, k):\n    # Reverse the subarray from the start up to the k-th position (exclusive)\n    reversed_part = arr[:k][::-1]\n    \n    # Concatenate the reversed part with the rest of the array starting from k\n    result = reversed_part + arr[k:]\n    \n    # Return the final array\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "\ndef recursive_list_sum(lst):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is a list, recursively sum its elements\n        if isinstance(element, list):\n            total_sum += recursive_list_sum(element)\n        else:\n            # Otherwise, add the element directly to the total sum\n            total_sum += element\n    \n    # Return the total sum of all elements\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "\ndef pos_count(numbers):\n    # Initialize a counter to keep track of positive numbers\n    count = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the current number is positive\n        if number > 0:\n            # Increment the counter if the number is positive\n            count += 1\n    \n    # Return the total count of positive numbers\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "\ndef text_match_wordz_middle(s: str) -> bool:\n    # If the string is too short to have a middle 'z', return False\n    if len(s) < 3:\n        return False\n    \n    # Iterate over the string from the second character to the second-to-last character\n    for i in range(1, len(s) - 1):\n        # Check if the current character is 'z'\n        if s[i] == 'z':\n            return True\n    \n    # If no 'z' was found in the middle, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "\ndef bell_number(n: int) -> int:\n    # Initialize the Bell triangle with the first Bell number\n    bell = [[1]]\n    \n    # Build the Bell triangle up to the nth row\n    for i in range(1, n + 1):\n        # Start the current row with the last element of the previous row\n        current = [bell[i - 1][-1]]\n        \n        # Fill the current row\n        for j in range(1, i + 1):\n            current.append(current[j - 1] + bell[i - 1][j - 1])\n        \n        # Append the current row to the Bell triangle\n        bell.append(current)\n    \n    # Return the first element of the nth row\n    return bell[n][0]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "\ndef is_Monotonic(array):\n    # An empty array or a single-element array is trivially monotonic\n    if len(array) <= 1:\n        return True\n    \n    # Initialize flags for non-decreasing and non-increasing\n    is_non_decreasing = True\n    is_non_increasing = True\n    \n    # Iterate through the array to check monotonicity\n    for i in range(len(array) - 1):\n        if array[i] > array[i + 1]:\n            is_non_decreasing = False\n        if array[i] < array[i + 1]:\n            is_non_increasing = False\n    \n    # The array is monotonic if it is either non-decreasing or non-increasing\n    return is_non_decreasing or is_non_increasing\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "\ndef is_sublist(main_list: list, sublist: list) -> bool:\n    # Get the lengths of the main list and the sublist\n    len_main = len(main_list)\n    len_sub = len(sublist)\n    \n    # If the sublist is longer than the main list, it cannot be a sublist\n    if len_sub > len_main:\n        return False\n    \n    # Iterate over possible starting indices in the main list\n    for i in range(len_main - len_sub + 1):\n        # Check if the slice of main_list matches the sublist\n        if main_list[i:i+len_sub] == sublist:\n            return True\n    \n    # If no match is found, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "\ndef find_char_long(s: str) -> list:\n    # Split the input string into words\n    words = s.split()\n    \n    # Initialize an empty list to store words that are at least 4 characters long\n    long_words = []\n    \n    # Iterate over each word in the list of words\n    for word in words:\n        # Check if the word is at least 4 characters long\n        if len(word) >= 4:\n            # Add the word to the list of long words\n            long_words.append(word)\n    \n    # Return the list of long words\n    return long_words\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["This is a very long string with no words that are at least 4 characters long."]]}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "\ndef comb_sort(arr):\n    # Initialize the gap as the length of the list\n    gap = len(arr)\n    # Define the shrink factor\n    shrink_factor = 1.3\n    # Initialize the sorted flag\n    sorted = False\n    \n    # Continue until the gap is 1 and the list is sorted\n    while gap > 1 or not sorted:\n        # Update the gap for the next comb\n        gap = int(gap // shrink_factor)\n        if gap < 1:\n            gap = 1\n        \n        # Assume the list is sorted\n        sorted = True\n        \n        # Compare elements with the current gap\n        for i in range(len(arr) - gap):\n            if arr[i] > arr[i + gap]:\n                # Swap if they are in the wrong order\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                # Since we made a swap, the list might not be sorted\n                sorted = False\n    \n    return arr\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "\ndef get_coordinates(coord: tuple) -> list:\n    # Initialize an empty list to store adjacent coordinates\n    adjacent_coordinates = []\n    \n    # Extract x and y from the input coordinate tuple\n    x, y = coord\n    \n    # Iterate over possible changes in x and y (-1, 0, 1)\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            # Calculate new coordinates\n            new_x = x + dx\n            new_y = y + dy\n            # Append the new coordinate to the list\n            adjacent_coordinates.append([new_x, new_y])\n    \n    # Return the list of adjacent coordinates\n    return adjacent_coordinates\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 1, 1]]]}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "\ndef get_equal(tuples: list) -> bool:\n    # If the list is empty, all tuples (none) have the same length by default\n    if not tuples:\n        return True\n    \n    # Get the length of the first tuple\n    first_length = len(tuples[0])\n    \n    # Check if all tuples have the same length as the first one\n    for t in tuples:\n        if len(t) != first_length:\n            return False\n    \n    # If all tuples have the same length, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "\ndef add_dict_to_tuple(input_tuple: tuple, input_dict: dict) -> tuple:\n    # Concatenate the input tuple with a tuple containing the input dictionary\n    result_tuple = input_tuple + (input_dict,)\n    # Return the resulting tuple\n    return result_tuple\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "\ndef dif_Square(n: int) -> bool:\n    # Check if n is odd\n    if n % 2 != 0:\n        return True\n    # Check if n is even and divisible by 4\n    elif n % 4 == 0:\n        return True\n    # If n is even but not divisible by 4\n    else:\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "\ndef maxAverageOfPath(cost):\n    N = len(cost)\n    dp = [[0] * N for _ in range(N)]\n    \n    # Initialize the starting point\n    dp[0][0] = cost[0][0]\n    \n    # Fill the first row and first column\n    for i in range(1, N):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        dp[0][i] = dp[0][i-1] + cost[0][i]\n    \n    # Fill the rest of the dp table\n    for i in range(1, N):\n        for j in range(1, N):\n            dp[i][j] = cost[i][j] + max(dp[i-1][j], dp[i][j-1])\n    \n    # Calculate the maximum average\n    max_total_cost = dp[N-1][N-1]\n    max_average = max_total_cost / (2 * N - 1)\n    \n    return max_average\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "\ndef filter_data(students: dict, min_height: float, min_weight: float) -> dict:\n    # Initialize an empty dictionary to store the filtered students\n    filtered_students = {}\n    \n    # Iterate over each student and their corresponding height and weight\n    for student, (height, weight) in students.items():\n        # Check if both height and weight meet the minimum requirements\n        if height >= min_height and weight >= min_weight:\n            # Add the student to the filtered dictionary\n            filtered_students[student] = (height, weight)\n    \n    # Return the dictionary of filtered students\n    return filtered_students\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "\ndef count_same_pair(list1, list2):\n    # Initialize a counter to keep track of matching indices\n    count = 0\n    \n    # Loop through the indices of the lists\n    for i in range(len(list1)):\n        # Check if the elements at the current index are the same in both lists\n        if list1[i] == list2[i]:\n            # Increment the counter if they are the same\n            count += 1\n    \n    # Return the total count of matching indices\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "\ndef extract_quotation(s: str) -> list:\n    # Initialize an empty list to store the extracted substrings\n    results = []\n    # Variable to track the position of the last opening quotation mark\n    start = None\n    \n    # Iterate over each character in the string with its index\n    for i, char in enumerate(s):\n        # Check if the character is a double quotation mark\n        if char == '\"':\n            # If start is None, this is an opening quote\n            if start is None:\n                start = i\n            else:\n                # This is a closing quote, extract the substring\n                results.append(s[start + 1:i])\n                # Reset start to None for the next pair of quotes\n                start = None\n    \n    # Return the list of extracted substrings\n    return results\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "\ndef multiply_elements(input_tuple):\n    # Initialize an empty list to store the products\n    products = []\n    \n    # Iterate over the input tuple, stopping before the last element\n    for i in range(len(input_tuple) - 1):\n        # Calculate the product of the current element and the next element\n        product = input_tuple[i] * input_tuple[i + 1]\n        # Append the product to the products list\n        products.append(product)\n    \n    # Convert the list of products to a tuple\n    result_tuple = tuple(products)\n    \n    # Return the resulting tuple\n    return result_tuple\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "\ndef sum_list(list1, list2):\n    # Initialize an empty list to store the sums\n    result = []\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Add the elements at the current index from both lists\n        # Append the sum to the result list\n        result.append(list1[i] + list2[i])\n    \n    # Return the list containing the sums\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "\ndef consecutive_duplicates(input_list):\n    # If the input list is empty, return an empty list\n    if not input_list:\n        return []\n    \n    # Initialize the result list with the first element of the input list\n    result_list = [input_list[0]]\n    \n    # Iterate over the input list starting from the second element\n    for element in input_list[1:]:\n        # If the current element is not the same as the last element in the result list\n        if element != result_list[-1]:\n            # Append the current element to the result list\n            result_list.append(element)\n    \n    # Return the result list\n    return result_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "\ndef power_base_sum(base: int, power: int) -> int:\n    # Step 1: Calculate the power\n    result = base ** power\n    \n    # Step 2: Convert the result to a string\n    result_str = str(result)\n    \n    # Step 3: Initialize the sum of digits\n    sum_of_digits = 0\n    \n    # Step 4: Sum the digits\n    for char in result_str:\n        sum_of_digits += int(char)\n    \n    # Step 5: Return the sum of the digits\n    return sum_of_digits\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "\nimport math\n\ndef lateralsurface_cone(r: float, h: float) -> float:\n    # Calculate the slant height using the Pythagorean theorem\n    l = math.sqrt(r**2 + h**2)\n    # Calculate the lateral surface area\n    lateral_surface_area = math.pi * r * l\n    # Return the lateral surface area\n    return lateral_surface_area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "\ndef replace_specialchar(s: str) -> str:\n    # Initialize an empty list to store the modified characters\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is a space, comma, or period\n        if char in ' ,.':\n            # Replace it with a colon\n            result.append(':')\n        else:\n            # Otherwise, keep the character as it is\n            result.append(char)\n    \n    # Join the list of characters into a single string and return it\n    return ''.join(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "\ndef find_first_occurrence(arr, target):\n    # Iterate over each element in the array\n    for index in range(len(arr)):\n        # Check if the current element is equal to the target\n        if arr[index] == target:\n            # If found, return the current index\n            return index\n    # If the loop completes without finding the target, return -1\n    return -1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "\ndef sum_Of_Subarray_Prod(lst):\n    # Initialize the total sum of products to 0\n    total_sum = 0\n    \n    # Iterate over each possible starting index of sublists\n    for i in range(len(lst)):\n        # Initialize the product for the current sublist starting at index i\n        product = 1\n        \n        # Iterate over each possible ending index of sublists starting from i\n        for j in range(i, len(lst)):\n            # Multiply the current product by the element at index j\n            product *= lst[j]\n            \n            # Add the current product to the total sum\n            total_sum += product\n    \n    # Return the total sum of products of all sublists\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "\ndef toggle_middle_bits(n: int) -> int:\n    # Convert the number to a binary string without the '0b' prefix\n    binary_str = bin(n)[2:]\n    \n    # If the binary representation has less than 3 bits, return the number as is\n    if len(binary_str) < 3:\n        return n\n    \n    # Extract the first and last bits\n    first_bit = binary_str[0]\n    last_bit = binary_str[-1]\n    \n    # Toggle the middle bits\n    middle_bits = binary_str[1:-1]\n    toggled_middle_bits = ''.join('1' if bit == '0' else '0' for bit in middle_bits)\n    \n    # Form the new binary string\n    new_binary_str = first_bit + toggled_middle_bits + last_bit\n    \n    # Convert the new binary string back to an integer\n    result = int(new_binary_str, 2)\n    \n    return result\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[true]]}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "\nimport re\n\ndef check_str(s: str) -> bool:\n    # Define a regular expression pattern to match a vowel at the start of the string.\n    # The pattern '^[aeiouAEIOU]' means:\n    # '^' asserts the position at the start of the string.\n    # '[aeiouAEIOU]' matches any single character that is a vowel (either lowercase or uppercase).\n    pattern = r'^[aeiouAEIOU]'\n    \n    # Use re.match to check if the string starts with a vowel.\n    # re.match returns a match object if the pattern is found at the start of the string, otherwise None.\n    if re.match(pattern, s):\n        return True\n    else:\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "\ndef left_insertion(sorted_list, value):\n    # Iterate over each index and element in the sorted list\n    for index in range(len(sorted_list)):\n        # If the current element is greater than or equal to the value\n        if sorted_list[index] >= value:\n            # Return the current index as the insertion point\n            return index\n    # If no such element is found, return the length of the list\n    # indicating the value should be inserted at the end\n    return len(sorted_list)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "\ndef tuple_to_dict(tup: tuple) -> dict:\n    # Initialize an empty dictionary to store the result\n    result = {}\n    \n    # Iterate over the tuple in steps of 2 to access pairs of elements\n    for i in range(0, len(tup), 2):\n        # Use the current element as the key and the next element as the value\n        result[tup[i]] = tup[i + 1]\n    \n    # Return the constructed dictionary\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "\ndef is_samepatterns(values, patterns):\n    # If the lengths of the lists are not equal, they cannot follow the same pattern\n    if len(values) != len(patterns):\n        return False\n    \n    # Dictionaries to store the mapping from patterns to values and vice versa\n    pattern_to_value = {}\n    value_to_pattern = {}\n    \n    # Iterate over both lists simultaneously\n    for value, pattern in zip(values, patterns):\n        # Check if the pattern is already mapped to a value\n        if pattern in pattern_to_value:\n            # If the current value does not match the mapped value, return False\n            if pattern_to_value[pattern] != value:\n                return False\n        else:\n            # Map the pattern to the current value\n            pattern_to_value[pattern] = value\n        \n        # Check if the value is already mapped to a pattern\n        if value in value_to_pattern:\n            # If the current pattern does not match the mapped pattern, return False\n            if value_to_pattern[value] != pattern:\n                return False\n        else:\n            # Map the value to the current pattern\n            value_to_pattern[value] = pattern\n    \n    # If all checks pass, the lists follow the same pattern\n    return True\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["red", "red", "red", "red", "red", "red"], ["a", "b", "c", "a", "b", "c"]]]}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "\ndef all_Characters_Same(s: str) -> bool:\n    # If the string is empty or has only one character, all characters are the same\n    if len(s) <= 1:\n        return True\n    \n    # Get the first character of the string\n    first_char = s[0]\n    \n    # Check each character in the string\n    for char in s:\n        # If any character is different from the first character, return False\n        if char != first_char:\n            return False\n    \n    # If all characters are the same as the first character, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "\ndef area_tetrahedron(a: float) -> float:\n    # Calculate the area of one equilateral triangle face\n    area_of_one_face = (3**0.5 / 4) * a**2\n    \n    # Calculate the total surface area of the tetrahedron\n    total_surface_area = 4 * area_of_one_face\n    \n    # Return the total surface area\n    return total_surface_area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "\ndef capital_words_spaces(s: str) -> str:\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each character in the string with its index\n    for i, c in enumerate(s):\n        # Check if the character is uppercase and not the first character\n        if c.isupper() and i != 0:\n            # Append a space before the character\n            result.append(' ')\n        # Append the character itself\n        result.append(c)\n    \n    # Join the list into a string and return it\n    return ''.join(result)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["MyNameIsAIAndIAmHereToHelpYou"]]}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "\ndef sort_numeric_strings(lst: list) -> list:\n    # Convert each string in the list to an integer\n    int_list = [int(num) for num in lst]\n    \n    # Sort the list of integers\n    int_list.sort()\n    \n    # Return the sorted list\n    return int_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "\ndef check_none(t: tuple) -> bool:\n    # Iterate over each element in the tuple\n    for element in t:\n        # Check if the current element is None\n        if element is None:\n            # If a None value is found, return True\n            return True\n    # If no None value is found, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "\ndef rotate_right(lst: list, k: int) -> list:\n    # Calculate the length of the list\n    n = len(lst)\n    \n    # Calculate the effective number of rotations needed\n    k = k % n\n    \n    # Slice the list into two parts and concatenate them in reverse order\n    return lst[-k:] + lst[:-k]\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 0]]}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "\ndef divisible_by_digits(startnum: int, endnum: int) -> list:\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate through each number in the specified range\n    for num in range(startnum, endnum + 1):\n        # Convert the number to a string to access each digit\n        num_str = str(num)\n        # Assume the number is divisible by all its digits\n        divisible = True\n        \n        # Check each digit\n        for digit_char in num_str:\n            digit = int(digit_char)\n            # If the digit is 0 or the number is not divisible by the digit\n            if digit == 0 or num % digit != 0:\n                divisible = False\n                break\n        \n        # If the number is divisible by all its digits, add it to the result\n        if divisible:\n            result.append(num)\n    \n    # Return the list of numbers that are divisible by all their digits\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "\ndef find_tuples(list_of_tuples, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the input list\n    for tup in list_of_tuples:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in tup):\n            # If true, append the tuple to the result list\n            result.append(tup)\n    \n    # Return the list of tuples that satisfy the condition\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "\ndef check_min_heap(arr):\n    # Get the length of the array\n    n = len(arr)\n    \n    # Iterate over each parent node\n    for i in range(n // 2):\n        # Calculate the left and right child indices\n        left = 2 * i + 1\n        right = 2 * i + 2\n        \n        # Check if the left child exists and is greater than the parent\n        if left < n and arr[i] > arr[left]:\n            return False\n        \n        # Check if the right child exists and is greater than the parent\n        if right < n and arr[i] > arr[right]:\n            return False\n    \n    # If all checks pass, the array is a min heap\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "\ndef add_tuple(lst: list, tpl: tuple) -> list:\n    # Convert the tuple to a list\n    tuple_as_list = list(tpl)\n    # Concatenate the list with the converted tuple list\n    result = lst + tuple_as_list\n    # Return the resulting list\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "\ndef jacobsthal_helper(n, memo):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n in memo:\n        return memo[n]\n    \n    # Calculate the nth Jacobsthal number using the recursive formula\n    result = jacobsthal_helper(n - 1, memo) + 2 * jacobsthal_helper(n - 2, memo)\n    memo[n] = result\n    return result\n\ndef jacobsthal_num(n: int) -> int:\n    memo = {}\n    return jacobsthal_helper(n, memo)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000]]}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "\ndef min_k(tuple_list, k):\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "\ndef extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the minimum length of the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate over the indices up to the minimum length\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, add the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    # Return the list of common elements\n    return common_elements\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "\ndef count_reverse_pairs(string_list):\n    # Initialize a counter to keep track of reverse pairs\n    count = 0\n    \n    # Convert the list to a set for faster lookup\n    string_set = set(string_list)\n    \n    # Iterate over each string in the original list\n    for string in string_list:\n        # Reverse the current string\n        reversed_string = string[::-1]\n        \n        # Check if the reversed string is in the set\n        if reversed_string in string_set:\n            # Increment the counter for a found pair\n            count += 1\n            \n            # Remove both the string and its reverse from the set\n            string_set.remove(string)\n            string_set.remove(reversed_string)\n    \n    # Return the total count of reverse pairs\n    return count\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["app", "123", "ad3", "apple", "elppa", "xyx", "bat", "tab", "tacocat", "racecar", "abc", "zyx", "def", "fed"]]]}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "\ndef second_smallest(numbers):\n    # Step 1: Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Step 2: Convert the set back to a list\n    unique_numbers = list(unique_numbers)\n    \n    # Step 3: Sort the list of unique numbers\n    unique_numbers.sort()\n    \n    # Step 4: Return the second element from the sorted list\n    return unique_numbers[1]\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 2]]], "plus_fail_tests": [[[]]]}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "\ndef is_decimal(s: str) -> bool:\n    # Check if there is exactly one decimal point in the string\n    if s.count('.') != 1:\n        return False\n    \n    # Split the string into two parts using the decimal point\n    integer_part, decimal_part = s.split('.')\n    \n    # Check if the integer part is a valid integer (it can be empty, which implies zero)\n    if integer_part and not integer_part.isdigit():\n        return False\n    \n    # Check if the decimal part has exactly two digits\n    if len(decimal_part) != 2 or not decimal_part.isdigit():\n        return False\n    \n    # If all checks pass, return True\n    return True\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["123"]]}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "\ndef unique_Element(numbers: list) -> bool:\n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # Check if the length of the set is 1\n    return len(unique_numbers) == 1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "\ndef check_monthnumber_number(month_number: int) -> bool:\n    # List of month numbers that have 30 days\n    months_with_30_days = [4, 6, 9, 11]\n    \n    # Check if the given month number is in the list\n    if month_number in months_with_30_days:\n        return True\n    else:\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "\ndef find_min_diff(arr: tuple, n: int) -> int:\n    # Convert the tuple to a list and sort it\n    sorted_arr = sorted(arr)\n    \n    # Initialize the minimum difference to a large number\n    min_diff = float('inf')\n    \n    # Iterate through the sorted list to find the minimum difference\n    for i in range(n - 1):\n        # Calculate the difference between consecutive elements\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        \n        # Update the minimum difference if a smaller one is found\n        if diff < min_diff:\n            min_diff = diff\n    \n    # Return the smallest difference found\n    return min_diff\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "\ndef unique_sublists(list_of_lists):\n    # Initialize an empty dictionary to store the counts of each tuple\n    count_dict = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple to use as a dictionary key\n        tuple_key = tuple(sublist)\n        \n        # Check if the tuple is already a key in the dictionary\n        if tuple_key in count_dict:\n            # If it is, increment its count by 1\n            count_dict[tuple_key] += 1\n        else:\n            # If it is not, add it to the dictionary with a count of 1\n            count_dict[tuple_key] = 1\n    \n    # Return the dictionary containing tuples and their counts\n    return count_dict\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "\ndef number_ctr(s: str) -> int:\n    # Initialize a counter to keep track of the number of digits\n    count = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if it is a digit\n            count += 1\n    \n    # Return the total count of digit characters\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "\ndef pair_wise(lst):\n    # Initialize an empty list to store the pairs\n    result = []\n    \n    # Loop through the list from the first element to the second-to-last element\n    for i in range(len(lst) - 1):\n        # Create a tuple with the current element and the next element\n        pair = (lst[i], lst[i + 1])\n        \n        # Append this tuple to the result list\n        result.append(pair)\n    \n    # Return the result list containing all pairs\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "\ndef get_pairs_count(numbers, target_sum):\n    # Initialize a dictionary to keep track of the frequency of each number\n    frequency_map = {}\n    # Initialize a counter to keep track of the number of valid pairs\n    pair_count = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Calculate the complement that would sum with the current number to reach the target sum\n        complement = target_sum - number\n        \n        # If the complement is already in the frequency map, it means we have found valid pairs\n        if complement in frequency_map:\n            # Increment the pair count by the number of times the complement has appeared\n            pair_count += frequency_map[complement]\n        \n        # Update the frequency map with the current number\n        if number not in frequency_map:\n            frequency_map[number] = 0\n        frequency_map[number] += 1\n    \n    # Return the total number of pairs found\n    return pair_count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "\ndef is_Diff(n: int) -> bool:\n    # Convert the number to a string to iterate over each digit\n    n_str = str(n)\n    \n    # Initialize sums for odd and even positioned digits\n    odd_sum = 0\n    even_sum = 0\n    \n    # Iterate over the digits with their index\n    for index, digit in enumerate(n_str):\n        # Convert the character to an integer\n        digit_value = int(digit)\n        \n        # Check if the index is even or odd\n        if index % 2 == 0:\n            # Add to odd_sum if index is even (0-based index)\n            odd_sum += digit_value\n        else:\n            # Add to even_sum if index is odd\n            even_sum += digit_value\n    \n    # Calculate the absolute difference between the sums\n    difference = abs(odd_sum - even_sum)\n    \n    # Check if the difference is divisible by 11\n    return difference % 11 == 0\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-1212]]}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "\ndef odd_num_sum(n: int) -> int:\n    # Initialize the sum to 0\n    sum = 0\n    \n    # Loop through the first n odd numbers\n    for i in range(n):\n        # Calculate the i-th odd number: 2*i + 1\n        odd_number = 2 * i + 1\n        \n        # Calculate the fourth power of the odd number\n        fourth_power = odd_number ** 4\n        \n        # Add the fourth power to the sum\n        sum += fourth_power\n    \n    # Return the total sum\n    return sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "\ndef check_expression(expression: str) -> bool:\n    # Stack to keep track of opening brackets\n    stack = []\n    \n    # Dictionary to map closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # If the stack is empty, it means there's no matching opening bracket\n            if not stack:\n                return False\n            # Pop the top element from the stack\n            top_element = stack.pop()\n            # Check if the popped element matches the corresponding opening bracket\n            if bracket_map[char] != top_element:\n                return False\n    \n    # If the stack is empty, all opening brackets have been matched\n    return not stack\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "\ndef Diff(list1, list2):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each element in the first list\n    for element in list1:\n        # Check if the element is not in the second list\n        if element not in result and element not in list2:\n            # If not, append it to the result list\n            result.append(element)\n    \n    # Return the result list containing elements only in list1\n    return result\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5], [6, 7, 1]]], "plus_fail_tests": [[[], [1, 2, 3]]]}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "\ndef occurance_substring(main_string: str, substring: str):\n    # Find the starting index of the substring in the main string\n    start_index = main_string.find(substring)\n    \n    # If the substring is not found, return None\n    if start_index == -1:\n        return None\n    \n    # Calculate the ending index of the substring\n    end_index = start_index + len(substring)\n    \n    # Return the tuple with the substring and its indices\n    return (substring, start_index, end_index)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "\ndef remove_length(s: str, k: int) -> str:\n    # Split the input string into a list of words\n    words = s.split()\n    \n    # Filter out words that have a length equal to k\n    filtered_words = [word for word in words if len(word) != k]\n    \n    # Join the filtered words back into a single string with spaces\n    result = ' '.join(filtered_words)\n    \n    # Return the resulting string\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "\ndef odd_position(lst):\n    # Iterate over the list, considering only odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current odd index is not odd\n        if lst[i] % 2 == 0:\n            # If any element at an odd index is even, return False\n            return False\n    # If all elements at odd indices are odd, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "\ndef pack_consecutive_duplicates(lst):\n    # If the input list is empty, return an empty list\n    if not lst:\n        return []\n    \n    # Initialize the result list and the first group with the first element\n    result = []\n    current_group = [lst[0]]\n    \n    # Iterate over the list starting from the second element\n    for element in lst[1:]:\n        # If the current element is the same as the last element in the current group\n        if element == current_group[-1]:\n            # Add the element to the current group\n            current_group.append(element)\n        else:\n            # Otherwise, add the current group to the result\n            result.append(current_group)\n            # Start a new group with the current element\n            current_group = [element]\n    \n    # Add the last group to the result\n    result.append(current_group)\n    \n    # Return the result list\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "\ndef find_combinations(tuple_list):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Get the length of the tuple list\n    n = len(tuple_list)\n    \n    # First pass: pair each first element with the second element of the next tuple\n    for i in range(n - 1):\n        # Calculate the sum of the first element of the current tuple\n        # and the second element of the next tuple\n        sum_tuple = (tuple_list[i][0] + tuple_list[i+1][1],)\n        \n        # Append the sum as a tuple to the result list\n        result.append(sum_tuple)\n    \n    # Wrap around: pair the first element of the last tuple with the second element of the first tuple\n    result.append((tuple_list[n-1][0] + tuple_list[0][1],))\n    \n    # Second pass: pair each first element with the second element of the tuple two places ahead\n    for i in range(n - 2):\n        # Calculate the sum of the first element of the current tuple\n        # and the second element of the tuple two places ahead\n        sum_tuple = (tuple_list[i][0] + tuple_list[i+2][1],)\n        \n        # Append the sum as a tuple to the result list\n        result.append(sum_tuple)\n    \n    # Wrap around: pair the first element of the second last tuple with the second element of the first tuple\n    result.append((tuple_list[n-2][0] + tuple_list[0][1],))\n    \n    # Wrap around: pair the first element of the last tuple with the second element of the second tuple\n    result.append((tuple_list[n-1][0] + tuple_list[1][1],))\n    \n    # Return the list of sum tuples\n    return result\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [3, 4, 5]]]], "plus_fail_tests": [[[[100, 200], [300, 400], [500, 600], [700, 800]]]]}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "\ndef find_sum(lst):\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    \n    # Count each element in the list\n    for element in lst:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n    \n    # Initialize the sum of non-repeated elements\n    sum_of_non_repeated = 0\n    \n    # Sum up elements that are not repeated\n    for key, value in count_dict.items():\n        if value == 1:\n            sum_of_non_repeated += key\n    \n    # Return the sum of non-repeated elements\n    return sum_of_non_repeated\n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 1, 1, 4, 5, 6]]], "plus_fail_tests": [[[-1, -2, -3, -1, -1, -4, -5, -6]]]}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "\ndef find_Index(n: int) -> int:\n    # Start with the first index\n    i = 1\n    while True:\n        # Calculate the ith triangular number\n        triangular_number = (i * (i + 1)) // 2\n        # Check the number of digits in the triangular number\n        if len(str(triangular_number)) == n:\n            # If it has n digits, return the index\n            return i\n        # Increment the index\n        i += 1\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "\ndef mul_even_odd(lst):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate over the list to find the first even and odd numbers\n    for num in lst:\n        # Check if the number is even and first_even is not yet set\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        # Check if the number is odd and first_odd is not yet set\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        # If both first_even and first_odd are found, break the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Calculate and return the product of the first even and odd numbers\n    return first_even * first_odd\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "\ndef odd_length_sum(arr):\n    # Initialize the total sum of odd-length subarrays\n    total_sum = 0\n    \n    # Iterate over all possible starting indices of subarrays\n    for i in range(len(arr)):\n        # Iterate over all possible ending indices of subarrays\n        for j in range(i, len(arr)):\n            # Check if the length of the subarray is odd\n            if (j - i + 1) % 2 == 1:\n                # Calculate the sum of the current subarray\n                subarray_sum = sum(arr[i:j+1])\n                # Add the subarray sum to the total sum\n                total_sum += subarray_sum\n    \n    # Return the total sum of all odd-length subarrays\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "\ndef right_insertion(sorted_list, value):\n    # Iterate through the list to find the right insertion point\n    for index in range(len(sorted_list)):\n        # If the current element is greater than the value, return the current index\n        if sorted_list[index] > value:\n            return index\n    # If no such element is found, return the length of the list\n    return len(sorted_list)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[50.64327388212607, -72.16612625583227, 95.25630303581863, -75.73998556144497, 11.857449640680656, 90.05081633927793, -90.20293226837086, -12.02758648076636, -35.964731488229475], 7]]}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "\ndef text_match_three(text: str) -> bool:\n    # Loop through each character in the string up to the length minus 3\n    for i in range(len(text) - 3):\n        # Check if the current character is 'a' and the next three are 'b'\n        if text[i] == 'a' and text[i+1] == 'b' and text[i+2] == 'b' and text[i+3] == 'b':\n            return True\n    # If no such pattern is found, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "\ndef tuple_str_int(s: str) -> tuple:\n    # Remove the parentheses from the string\n    s = s.strip(\"()\")\n    \n    # Split the string by commas to get a list of string numbers\n    str_numbers = s.split(\", \")\n    \n    # Convert each string number to an integer\n    int_numbers = tuple(int(num) for num in str_numbers)\n    \n    # Return the tuple of integers\n    return int_numbers\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "\ndef new_tuple(lst: list, s: str) -> tuple:\n    # Convert the list to a tuple\n    list_as_tuple = tuple(lst)\n    \n    # Create a tuple from the string\n    string_as_tuple = (s,)\n    \n    # Concatenate the two tuples\n    result_tuple = list_as_tuple + string_as_tuple\n    \n    # Return the resulting tuple\n    return result_tuple\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "\ndef word_len(word: str) -> bool:\n    # Calculate the length of the word\n    length = len(word)\n    \n    # Check if the length is odd\n    if length % 2 != 0:\n        return True\n    else:\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "\ndef even_position(lst):\n    # Iterate over the list with a step of 2 to check only even indices\n    for i in range(0, len(lst), 2):\n        # Check if the element at the current even index is not even\n        if lst[i] % 2 != 0:\n            return False\n    # If all elements at even indices are even, return True\n    return True\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 1, 4, 2, 6, 1, 8, 2, 10, 1, 12]]]}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "\ndef count_list(list_of_lists: list) -> int:\n    # Use the len() function to count the number of lists in the input list\n    return len(list_of_lists)\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 3, [4, [5, [6, [7, [8, 9]]]]]]]]}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "\ndef last(sorted_list, target):\n    # Iterate over the list from the last element to the first\n    for index in range(len(sorted_list) - 1, -1, -1):\n        # Check if the current element is the target\n        if sorted_list[index] == target:\n            # Return the index if the target is found\n            return index\n    # Return -1 if the target is not found in the list\n    return -1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "\ndef remove_nested(input_tuple):\n    # Initialize an empty list to store non-tuple elements\n    result = []\n    \n    # Iterate over each element in the input tuple\n    for element in input_tuple:\n        # Check if the element is not a tuple\n        if not isinstance(element, tuple):\n            # Append non-tuple elements to the result list\n            result.append(element)\n    \n    # Convert the result list back to a tuple\n    return tuple(result)\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "\ndef text_starta_endb(s: str) -> bool:\n    # Check if the string has at least two characters\n    if len(s) < 2:\n        return False\n    # Check if the string starts with 'a' and ends with 'b'\n    return s[0] == 'a' and s[-1] == 'b'\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["xaabbyz1323ababb"]]}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "\ndef return_sum(d: dict) -> int:\n    # Get all the values from the dictionary\n    values = d.values()\n    # Calculate the sum of the values\n    total_sum = sum(values)\n    # Return the sum\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "\ndef left_rotate(n: int, d: int) -> int:\n    # Step 1: Normalize d to be within 0 to 31\n    d = d % 32\n    \n    # Step 2: Perform the left rotation\n    # Left shift the number by d positions\n    left_shifted = n << d\n    \n    # Step 3: Capture the overflow bits\n    # Right shift the number by (32 - d) positions\n    overflow_bits = n >> (32 - d)\n    \n    # Step 4: Combine the left shifted and overflow bits using bitwise OR\n    result = (left_shifted | overflow_bits) & 0xFFFFFFFF\n    \n    # Step 5: Return the result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "\ndef square_nums(nums):\n    # Create an empty list to store squared numbers\n    squared_list = []\n    \n    # Iterate over each number in the input list\n    for num in nums:\n        # Calculate the square of the current number\n        squared_value = num * num\n        \n        # Append the squared value to the squared_list\n        squared_list.append(squared_value)\n    \n    # Return the list of squared numbers\n    return squared_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "\ndef _sum(arr):\n    # Initialize the total sum to 0\n    total = 0\n    # Iterate over each number in the array\n    for num in arr:\n        # Add the current number to the total sum\n        total += num\n    # Return the total sum\n    return total\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "\ndef sum_in_range(l: int, r: int) -> int:\n    # Initialize the sum of odd numbers to 0\n    sum_of_odds = 0\n    \n    # Iterate through each number from l to r\n    for n in range(l, r + 1):\n        # Check if the number is odd\n        if n % 2 != 0:\n            # Add the odd number to the sum\n            sum_of_odds += n\n    \n    # Return the total sum of odd numbers\n    return sum_of_odds\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "\ndef tetrahedral_number(n: int) -> int:\n    # Calculate the nth tetrahedral number using the formula:\n    # T(n) = n * (n + 1) * (n + 2) / 6\n    # This formula gives the sum of the first n triangular numbers.\n    return n * (n + 1) * (n + 2) // 6\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "\ndef is_polite(n: int) -> int:\n    def is_power_of_two(x: int) -> bool:\n        # A number is a power of two if it has only one bit set in its binary representation\n        return (x & (x - 1)) == 0 and x != 0\n\n    count = 0\n    number = 1\n    while count < n:\n        if not is_power_of_two(number):\n            count += 1\n        number += 1\n    \n    # The loop exits when count == n, but number has been incremented one extra time\n    return number - 1\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[10000000]]}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "\ndef remove_all_spaces(s: str) -> str:\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is not a whitespace\n        if char != ' ':\n            # Append the character to the result string\n            result += char\n    \n    # Return the result string with all whitespaces removed\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "\ndef is_perfect_square(n: int) -> bool:\n    # Negative numbers cannot be perfect squares\n    if n < 0:\n        return False\n    \n    # Calculate the integer square root\n    integer_sqrt = int(n ** 0.5)\n    \n    # Check if the square of the integer square root equals the original number\n    return integer_sqrt * integer_sqrt == n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "\ndef is_product_even(numbers):\n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the current number is even\n        if number % 2 == 0:\n            # If an even number is found, the product is even\n            return True\n    # If no even number is found, the product is not even\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "\ndef max_sum_list(list_of_lists):\n    # Initialize variables to keep track of the list with the maximum sum\n    max_list = None\n    max_sum = float('-inf')  # Start with the smallest possible number\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum(lst)\n        \n        # If the current sum is greater than the max sum found so far\n        if current_sum > max_sum:\n            # Update the max sum and the list with the max sum\n            max_sum = current_sum\n            max_list = lst\n    \n    # Return the list with the maximum sum\n    return max_list\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "\ndef max_run_uppercase(s: str) -> int:\n    # Initialize the maximum length of consecutive uppercase characters\n    max_length = 0\n    # Initialize the current length of consecutive uppercase characters\n    current_length = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Increment the current length counter\n            current_length += 1\n        else:\n            # Update the maximum length if the current run is longer\n            if current_length > max_length:\n                max_length = current_length\n            # Reset the current length counter\n            current_length = 0\n    \n    # Final check in case the string ends with an uppercase run\n    if current_length > max_length:\n        max_length = current_length\n    \n    # Return the maximum length found\n    return max_length\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["Aaa"]]}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "\ndef test_three_equal(a: int, b: int, c: int) -> int:\n    # Check if all three numbers are equal\n    if a == b == c:\n        return 3\n    # Check if any two numbers are equal\n    elif a == b or b == c or a == c:\n        return 2\n    # If none are equal\n    else:\n        return 0\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "\ndef first_odd(numbers):\n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is odd\n        if number % 2 != 0:\n            # Return the first odd number found\n            return number\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "\ndef check_K(tuple_of_integers, k):\n    # Check if k is present in the tuple_of_integers\n    if k in tuple_of_integers:\n        # If k is found, return True\n        return True\n    else:\n        # If k is not found, return False\n        return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "\nimport math\n\ndef volume_sphere(radius: float) -> float:\n    # Calculate the volume of the sphere using the formula (4/3) * pi * radius^3\n    volume = (4/3) * math.pi * (radius ** 3)\n    # Return the calculated volume\n    return volume\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "\ndef check_smaller(tuple1, tuple2):\n    # Iterate over the indices of the tuples\n    for i in range(len(tuple1)):\n        # Check if the element in the second tuple is not smaller than the element in the first tuple\n        if tuple2[i] >= tuple1[i]:\n            # If any element in the second tuple is not smaller, return False\n            return False\n    # If all elements in the second tuple are smaller, return True\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "\nimport math\n\n# Function to calculate the surface area of a sphere\ndef surfacearea_sphere(radius: float) -> float:\n    # Calculate the surface area using the formula 4 * pi * r^2\n    surface_area = 4 * math.pi * radius ** 2\n    # Return the calculated surface area\n    return surface_area\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "\ndef centered_hexagonal_number(n: int) -> int:\n    # Calculate the nth centered hexagonal number using the formula\n    # Centered hexagonal number formula: 3n(n-1) + 1\n    return 3 * n * (n - 1) + 1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "\ndef freq_count(lst):\n    # Initialize an empty dictionary to store frequencies\n    frequency_dict = {}\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency_dict[element] = 1\n    \n    # Return the dictionary containing frequencies of all elements\n    return frequency_dict\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "\ndef merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    # Create an empty dictionary to store the merged result\n    merged_dict = {}\n    \n    # Update the merged dictionary with key-value pairs from the first dictionary\n    merged_dict.update(dict1)\n    \n    # Update the merged dictionary with key-value pairs from the second dictionary\n    merged_dict.update(dict2)\n    \n    # Update the merged dictionary with key-value pairs from the third dictionary\n    merged_dict.update(dict3)\n    \n    # Return the merged dictionary\n    return merged_dict\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "\ndef closest_num(n: int) -> int:\n    # Return the closest smaller number than n, which is n - 1\n    return n - 1\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "\ndef find_Rotations(s: str) -> int:\n    n = len(s)\n    # Loop through possible rotations\n    for i in range(1, n):\n        # Rotate the string by i positions\n        rotated = s[i:] + s[:i]\n        # Check if the rotated string matches the original\n        if rotated == s:\n            return i\n    # If no rotation matches, return the length of the string\n    return n\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "\ndef count_divisors(n: int) -> bool:\n    # Initialize the count of divisors to 0\n    count = 0\n    \n    # Iterate over all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Increment the count of divisors\n            count += 1\n    \n    # Check if the count of divisors is even\n    return count % 2 == 0\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321]]}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "\ndef len_log(words: list) -> int:\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Calculate the length of the current word\n        current_length = len(word)\n        \n        # If the current word's length is greater than the max_length, update max_length\n        if current_length > max_length:\n            max_length = current_length\n    \n    # Return the maximum length found\n    return max_length\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "\ndef find_substring(list_of_strings, substring):\n    # Iterate over each string in the provided list\n    for string in list_of_strings:\n        # Check if the substring is present in the current string\n        if substring in string:\n            # If found, return True immediately\n            return True\n    # If the loop completes without finding the substring, return False\n    return False\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "\ndef is_undulating(n: int) -> bool:\n    # Convert the number to a string to easily access each digit\n    num_str = str(n)\n    \n    # If the number has less than 2 digits, it cannot be undulating\n    if len(num_str) < 2:\n        return False\n    \n    # Get the first two digits\n    first_digit = num_str[0]\n    second_digit = num_str[1]\n    \n    # If the first two digits are the same, it cannot be undulating\n    if first_digit == second_digit:\n        return False\n    \n    # Iterate through the number starting from the third digit\n    for i in range(2, len(num_str)):\n        # Check if the current digit alternates correctly with the previous one\n        if num_str[i] != num_str[i - 2]:\n            return False\n    \n    # If all checks pass, the number is undulating\n    return True\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "\ndef power(a: int, b: int) -> int:\n    # Calculate a raised to the power of b using the ** operator\n    result = a ** b\n    # Return the result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "\ndef index_minimum(tuples_list):\n    # Initialize the smallest number to a very large value\n    smallest_number = float('inf')\n    # Initialize the name associated with the smallest number\n    smallest_name = None\n    \n    # Iterate through each tuple in the list\n    for name, number in tuples_list:\n        # Check if the current number is smaller than the smallest number found so far\n        if number < smallest_number:\n            # Update the smallest number\n            smallest_number = number\n            # Update the name associated with the smallest number\n            smallest_name = name\n    \n    # Return the name associated with the smallest number\n    return smallest_name\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[["Adam", 150, "NYC", true], ["Benjamin", 100, "LA", false], ["Charlie", 200, "Chicago", true], ["David", 125, "Miami", false]]]]}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "\ndef Find_Min_Length(list_of_lists):\n    # Initialize min_length with a large number\n    min_length = float('inf')\n    \n    # Iterate over each list in the list of lists\n    for lst in list_of_lists:\n        # Calculate the length of the current list\n        current_length = len(lst)\n        \n        # Update min_length if the current list's length is smaller\n        if current_length < min_length:\n            min_length = current_length\n    \n    # Return the smallest length found\n    return min_length\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "\ndef frequency_lists(list_of_lists):\n    # Initialize an empty list to store all elements from the sublists\n    flattened_list = []\n    \n    # Flatten the list of lists into a single list\n    for sublist in list_of_lists:\n        flattened_list.extend(sublist)\n    \n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Count the frequency of each element in the flattened list\n    for element in flattened_list:\n        if element not in frequency_dict:\n            # If the element is not in the dictionary, add it with a count of 1\n            frequency_dict[element] = 1\n        else:\n            # If the element is already in the dictionary, increment its count\n            frequency_dict[element] += 1\n    \n    # Return the dictionary containing the frequencies\n    return frequency_dict\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "\ndef multiply_num(numbers):\n    # Initialize the product to 1\n    product = 1\n    \n    # Multiply all numbers in the list\n    for number in numbers:\n        product *= number\n    \n    # Calculate the length of the list\n    length_of_list = len(numbers)\n    \n    # Divide the product by the length of the list\n    result = product / length_of_list\n    \n    # Return the result\n    return result\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "\ndef divisor(n: int) -> int:\n    # Initialize the count of divisors to 0\n    count = 0\n    \n    # Iterate over all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Increment the count if i is a divisor\n            count += 1\n    \n    # Return the total count of divisors\n    return count\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "\ndef decimal_to_binary(n: int) -> str:\n    # Handle the special case where the input is 0\n    if n == 0:\n        return \"0\"\n    \n    # Initialize an empty string to build the binary representation\n    binary_string = \"\"\n    \n    # Loop until the number becomes zero\n    while n > 0:\n        # Get the remainder of the division by 2 (either 0 or 1)\n        remainder = n % 2\n        # Prepend the remainder to the binary string\n        binary_string = str(remainder) + binary_string\n        # Update the number to be the quotient of the division by 2\n        n = n // 2\n    \n    # Return the constructed binary string\n    return binary_string\n", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-5]]}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "\ndef even_Power_Sum(n: int) -> int:\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the first n even numbers\n    for i in range(1, n + 1):\n        # Calculate the ith even number\n        even_number = 2 * i\n        # Raise the even number to the power of 5\n        power_five = even_number ** 5\n        # Add the result to the total sum\n        total_sum += power_five\n    \n    # Return the total sum\n    return total_sum\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "\ndef sequence(n: int) -> int:\n    # Base cases for the sequence\n    if n == 1 or n == 2:\n        return 1\n    \n    # Initialize a list to store sequence values, with n+1 elements\n    seq = [0] * (n + 1)\n    \n    # Set the first two known values of the sequence\n    seq[1] = 1\n    seq[2] = 1\n    \n    # Calculate the sequence values from 3 to n\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    \n    # Return the nth value in the sequence\n    return seq[n]\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "\ndef factorial(x: int) -> int:\n    if x == 0 or x == 1:\n        return 1\n    result = 1\n    for i in range(2, x + 1):\n        result *= i\n    return result\n\ndef binomial_coefficient(n: int, k: int) -> int:\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef sum_Of_product(n: int) -> int:\n    sum_product = 0\n    for k in range(n):\n        product = binomial_coefficient(n, k) * binomial_coefficient(n, k + 1)\n        sum_product += product\n    return sum_product\n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}]}}