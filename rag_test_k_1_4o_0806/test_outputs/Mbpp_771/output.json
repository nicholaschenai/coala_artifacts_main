{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert check_expression(\"{()}[{}]\") == True\n\nTests failed:\nNone",
    "code": "\ndef check_expression(expression: str) -> bool:\n    # Define a mapping of closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    # Initialize an empty list to use as a stack\n    stack = []\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is empty or the top of the stack is not the matching opening bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the top of the stack as it is a matching pair\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched correctly\n    return not stack\n",
    "full_code": "\ndef check_expression(expression: str) -> bool:\n    # Define a mapping of closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    # Initialize an empty list to use as a stack\n    stack = []\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is empty or the top of the stack is not the matching opening bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the top of the stack as it is a matching pair\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched correctly\n    return not stack\n",
    "reward": true,
    "program_code": "\ndef check_expression(expression: str) -> bool:\n    # Define a mapping of closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    # Initialize an empty list to use as a stack\n    stack = []\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is empty or the top of the stack is not the matching opening bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the top of the stack as it is a matching pair\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched correctly\n    return not stack\n",
    "program_name": "check_expression",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n\n   We need to write a function that checks if a given string of brackets is balanced. A balanced string means that every opening bracket has a corresponding closing bracket in the correct order.\n\n2. **Conceptualize a solution in plain English:**\n\n   To determine if a string of brackets is balanced, we can use a stack data structure. As we iterate through each character in the string:\n   - If the character is an opening bracket (like `{`, `(`, or `[`), we push it onto the stack.\n   - If the character is a closing bracket (like `}`, `)`, or `]`), we check if the stack is not empty and if the top of the stack is the matching opening bracket. If it is, we pop the stack. If not, the string is unbalanced.\n   - At the end of the iteration, if the stack is empty, the string is balanced. If not, it is unbalanced.\n\n3. **Write a pseudocode solution:**\n\n   ```\n   function check_expression(expression):\n       create an empty stack\n       for each character in expression:\n           if character is an opening bracket:\n               push it onto the stack\n           else if character is a closing bracket:\n               if stack is empty or top of stack is not the matching opening bracket:\n                   return False\n               pop the stack\n       return True if stack is empty, otherwise False\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n\n```python\ndef check_expression(expression: str) -> bool:\n    # Define a mapping of closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    # Initialize an empty list to use as a stack\n    stack = []\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is empty or the top of the stack is not the matching opening bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the top of the stack as it is a matching pair\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched correctly\n    return not stack\n```\n\nThis code will correctly determine if a string of brackets is balanced by using a stack to track unmatched opening brackets and ensuring each closing bracket has a corresponding opening bracket.",
    "no_parent": true,
    "dependency_used": false
}