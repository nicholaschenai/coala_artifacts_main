{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert search([1,1,2,2,3]) == 3\n\nTests failed:\nNone",
    "code": "\ndef search(arr):\n    # Initialize the low and high pointers for binary search\n    low, high = 0, len(arr) - 1\n    \n    # Perform binary search\n    while low < high:\n        # Calculate the middle index\n        mid = (low + high) // 2\n        \n        # Check if mid is even\n        if mid % 2 == 0:\n            # If the element at mid is equal to the next element, the unique element is in the right half\n            if arr[mid] == arr[mid + 1]:\n                low = mid + 2\n            else:\n                # Otherwise, the unique element is in the left half\n                high = mid\n        else:\n            # If mid is odd, check if the element at mid is equal to the previous element\n            if arr[mid] == arr[mid - 1]:\n                low = mid + 1\n            else:\n                # Otherwise, the unique element is in the left half\n                high = mid\n    \n    # The low pointer will point to the unique element\n    return arr[low]\n",
    "full_code": "\ndef search(arr):\n    # Initialize the low and high pointers for binary search\n    low, high = 0, len(arr) - 1\n    \n    # Perform binary search\n    while low < high:\n        # Calculate the middle index\n        mid = (low + high) // 2\n        \n        # Check if mid is even\n        if mid % 2 == 0:\n            # If the element at mid is equal to the next element, the unique element is in the right half\n            if arr[mid] == arr[mid + 1]:\n                low = mid + 2\n            else:\n                # Otherwise, the unique element is in the left half\n                high = mid\n        else:\n            # If mid is odd, check if the element at mid is equal to the previous element\n            if arr[mid] == arr[mid - 1]:\n                low = mid + 1\n            else:\n                # Otherwise, the unique element is in the left half\n                high = mid\n    \n    # The low pointer will point to the unique element\n    return arr[low]\n",
    "reward": true,
    "program_code": "\ndef search(arr):\n    # Initialize the low and high pointers for binary search\n    low, high = 0, len(arr) - 1\n    \n    # Perform binary search\n    while low < high:\n        # Calculate the middle index\n        mid = (low + high) // 2\n        \n        # Check if mid is even\n        if mid % 2 == 0:\n            # If the element at mid is equal to the next element, the unique element is in the right half\n            if arr[mid] == arr[mid + 1]:\n                low = mid + 2\n            else:\n                # Otherwise, the unique element is in the left half\n                high = mid\n        else:\n            # If mid is odd, check if the element at mid is equal to the previous element\n            if arr[mid] == arr[mid - 1]:\n                low = mid + 1\n            else:\n                # Otherwise, the unique element is in the left half\n                high = mid\n    \n    # The low pointer will point to the unique element\n    return arr[low]\n",
    "program_name": "search",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n\n   We need to find the single element in a sorted array where every other element appears exactly twice. The array is sorted in non-decreasing order.\n\n2. **Conceptualize a solution in plain English:**\n\n   Since the array is sorted and all elements except one appear twice, the unique element will disrupt the pattern of pairs. We can use a binary search approach to efficiently find this unique element. The idea is to check the middle of the array and determine if the unique element is in the left or right half by checking the pairing pattern. If the middle element is part of a pair, the unique element is in the other half. If not, it is in the half where the middle element is located.\n\n3. **Write a pseudocode solution:**\n\n   ```\n   function search(arr):\n       set low to 0\n       set high to length of arr - 1\n       \n       while low is less than high:\n           set mid to (low + high) // 2\n           \n           if mid is even:\n               if arr[mid] is equal to arr[mid + 1]:\n                   set low to mid + 2\n               else:\n                   set high to mid\n           else:\n               if arr[mid] is equal to arr[mid - 1]:\n                   set low to mid + 1\n               else:\n                   set high to mid\n       \n       return arr[low]\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n\n```python\ndef search(arr):\n    # Initialize the low and high pointers for binary search\n    low, high = 0, len(arr) - 1\n    \n    # Perform binary search\n    while low < high:\n        # Calculate the middle index\n        mid = (low + high) // 2\n        \n        # Check if mid is even\n        if mid % 2 == 0:\n            # If the element at mid is equal to the next element, the unique element is in the right half\n            if arr[mid] == arr[mid + 1]:\n                low = mid + 2\n            else:\n                # Otherwise, the unique element is in the left half\n                high = mid\n        else:\n            # If mid is odd, check if the element at mid is equal to the previous element\n            if arr[mid] == arr[mid - 1]:\n                low = mid + 1\n            else:\n                # Otherwise, the unique element is in the left half\n                high = mid\n    \n    # The low pointer will point to the unique element\n    return arr[low]\n```",
    "no_parent": true,
    "dependency_used": false
}