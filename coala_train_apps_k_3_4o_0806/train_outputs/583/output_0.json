{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['2', '1', '-1', '2', '1 2'] Expected output: [{'NO'}, {'YES'}] # Execution output: ['YES', 'YES']",
    "code": "\ndef is_good_sequence_possible(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N = test_case[0]\n        A = test_case[1]\n        \n        sum_A = sum(A)\n        sum_indices = N * (N + 1) // 2  # Sum of first N natural numbers\n        \n        if sum_A % sum_indices == 0:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = list(map(int, data[index:index + N]))\n        index += N\n        test_cases.append((N, A))\n    \n    is_good_sequence_possible(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\ndef is_good_sequence_possible(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N = test_case[0]\n        A = test_case[1]\n        \n        sum_A = sum(A)\n        sum_indices = N * (N + 1) // 2  # Sum of first N natural numbers\n        \n        if sum_A % sum_indices == 0:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = list(map(int, data[index:index + N]))\n        index += N\n        test_cases.append((N, A))\n    \n    is_good_sequence_possible(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": false,
    "program_code": "\ndef is_good_sequence_possible(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N = test_case[0]\n        A = test_case[1]\n        \n        sum_A = sum(A)\n        sum_indices = N * (N + 1) // 2  # Sum of first N natural numbers\n        \n        if sum_A % sum_indices == 0:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = list(map(int, data[index:index + N]))\n        index += N\n        test_cases.append((N, A))\n    \n    is_good_sequence_possible(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe have a sequence of integers, and we want to determine if it's possible to make the sum of the sequence equal to zero by performing a series of operations. In each operation, we can choose an index `i` and decrease the element at that index by `i`. We need to determine if it's possible to make the sequence \"good\" (i.e., sum to zero) for multiple test cases.\n\n### Conceptual Solution\n\n1. **Understanding the Operation**: For each element `A[i]` in the sequence, we can decrease it by `i` any number of times. This means we can effectively reduce `A[i]` by any multiple of `i`.\n\n2. **Key Insight**: The operation allows us to reduce the sum of the sequence by any multiple of the sum of indices. Therefore, the problem boils down to checking if the sum of the sequence is a multiple of the sum of indices.\n\n3. **Solution Strategy**:\n   - Calculate the sum of the sequence.\n   - Calculate the sum of indices from `1` to `N`.\n   - Check if the sum of the sequence is a multiple of the sum of indices. If it is, print \"YES\", otherwise print \"NO\".\n\n### Pseudocode\n\n```\nfunction is_good_sequence_possible(T, test_cases):\n    for each test_case in test_cases:\n        N = test_case[0]\n        A = test_case[1]\n        \n        sum_A = sum(A)\n        sum_indices = N * (N + 1) / 2  # Sum of first N natural numbers\n        \n        if sum_A % sum_indices == 0:\n            print \"YES\"\n        else:\n            print \"NO\"\n```\n\n### Python Code\n\n```python\ndef is_good_sequence_possible(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N = test_case[0]\n        A = test_case[1]\n        \n        sum_A = sum(A)\n        sum_indices = N * (N + 1) // 2  # Sum of first N natural numbers\n        \n        if sum_A % sum_indices == 0:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        A = list(map(int, data[index:index + N]))\n        index += N\n        test_cases.append((N, A))\n    \n    is_good_sequence_possible(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation of the Code\n\n- **Input Handling**: The `main` function reads all input data at once and splits it into manageable parts. It then constructs the list of test cases.\n- **Sum Calculation**: For each test case, the sum of the sequence and the sum of indices are calculated.\n- **Divisibility Check**: The core logic checks if the sum of the sequence is divisible by the sum of indices. If it is, the sequence can be made good; otherwise, it cannot.\n- **Output**: The results for each test case are collected and printed at the end.",
    "no_parent": false,
    "dependency_used": false
}