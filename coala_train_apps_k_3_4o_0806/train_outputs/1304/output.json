{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['3 2', '3 1 2', '2 3 1', ''] Output: 3 2 1\n3 1 2 \n\nTests failed:\nNone",
    "code": "\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        # Find the element just larger than perm[i]\n        while perm[j] <= perm[i]:\n            j -= 1\n        # Swap them\n        perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef process_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    results = []\n    \n    for _ in range(K):\n        perm = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(perm)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\nprocess_permutations()\n",
    "full_code": "\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        # Find the element just larger than perm[i]\n        while perm[j] <= perm[i]:\n            j -= 1\n        # Swap them\n        perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef process_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    results = []\n    \n    for _ in range(K):\n        perm = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(perm)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\nprocess_permutations()\n",
    "reward": true,
    "program_code": "\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        # Find the element just larger than perm[i]\n        while perm[j] <= perm[i]:\n            j -= 1\n        # Swap them\n        perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef process_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    results = []\n    \n    for _ in range(K):\n        perm = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(perm)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\nprocess_permutations()\n",
    "program_name": "process_permutations",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe are given a permutation of numbers from 1 to N and need to find the next permutation in lexicographic order. The input consists of multiple permutations, and for each permutation, we need to output the next permutation in lexicographic order.\n\n### Conceptual Solution\n\n1. **Understanding Lexicographic Order**: \n   - Lexicographic order is similar to dictionary order. For permutations, it means arranging numbers in the smallest possible order that is greater than the current permutation.\n\n2. **Finding the Next Permutation**:\n   - Start from the end of the permutation and find the first pair where the earlier number is smaller than the later number. This identifies the point where the order can be increased.\n   - Swap this number with the smallest number that is larger than it to the right of it.\n   - Reverse the sequence to the right of the original position to get the smallest possible order.\n\n3. **Edge Case**:\n   - If the permutation is the largest possible (i.e., in descending order), the next permutation is the smallest possible (i.e., in ascending order).\n\n### Pseudocode\n\n```\nfunction next_permutation(perm):\n    n = length of perm\n    i = n - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        while perm[j] <= perm[i]:\n            j -= 1\n        swap perm[i] and perm[j]\n    reverse perm from i + 1 to end\n    return perm\n\nfunction process_permutations(N, K, permutations):\n    results = []\n    for perm in permutations:\n        next_perm = next_permutation(perm)\n        results.append(next_perm)\n    return results\n```\n\n### Final Python Code\n\n```python\ndef next_permutation(perm):\n    n = len(perm)\n    i = n - 2\n    # Find the first decreasing element from the end\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    if i >= 0:\n        j = n - 1\n        # Find the element just larger than perm[i]\n        while perm[j] <= perm[i]:\n            j -= 1\n        # Swap them\n        perm[i], perm[j] = perm[j], perm[i]\n    # Reverse the sequence from i+1 to end\n    perm[i + 1:] = reversed(perm[i + 1:])\n    return perm\n\ndef process_permutations():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    index = 2\n    results = []\n    \n    for _ in range(K):\n        perm = list(map(int, data[index:index + N]))\n        index += N\n        next_perm = next_permutation(perm)\n        results.append(\" \".join(map(str, next_perm)))\n    \n    for result in results:\n        print(result)\n\nprocess_permutations()\n```\n\n### Explanation\n\n- **next_permutation**: This function finds the next lexicographic permutation by identifying the first decreasing element from the end, swapping it with the smallest larger element to its right, and then reversing the sequence to the right of the original position.\n- **process_permutations**: This function reads input, processes each permutation using `next_permutation`, and outputs the results. It handles reading from standard input and writing to standard output.",
    "no_parent": false,
    "dependency_used": false
}