INFO - DB skill doc count: 0

INFO - DB non_func doc count: 30

INFO - DB semantic doc count: 429

INFO - DB summaries doc count: 41

INFO - DB reflections doc count: 41

INFO - DB episodic doc count: 88

INFO - [train iter]: 41/100 

INFO - The task prompt is Tara was completing an Algorithms assignment and got stuck on a question. She thought of who can help her, and got reminded of Kabir who has good problem solving skills. The question is:
Given N$N$ the number of elements in the sequence A1$A_1$,A2$A_2$ â€¦ An$A_n$. Find out the prime factor which o...

INFO - Attempting task_id 759
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] 759 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Tara was completing an Algorithms assignment and got stuck on a question. She thought of who can help her, and got reminded of Kabir who has good problem solving skills. The question is:
Given N$N$ the number of elements in the sequence A1$A_1$,A2$A_2$ â€¦ An$A_n$. Find out the prime factor which occurred maximum number of times among the largest prime factor corresponding to each element. if there are more than one such prime factors print the largest one.
You are friends with Kabir, help him to solve the problem for Tara.

-----Input:-----
- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T test cases follows. 
- First line of each test case contains N$N$, the number of elements in the sequence.
- Second line contains N space separated elements A1$A_1$,A2$A_2$ â€¦ An$A_n$.

-----Output:-----
- For each test case, print a single line, the number which occurs maximum number of times from the largest prime factor corresponding to each element.

-----Constraints-----
- 1â‰¤Tâ‰¤10$1 \leq T \leq 10$
- 1â‰¤Nâ‰¤105$1 \leq N \leq 10^5$
- 2â‰¤A[i]â‰¤105$2 \leq A[i] \leq 10^5$

-----Sample Input:-----
1
7

3 2 15 6 8 5 10

-----Sample Output:-----
5

-----EXPLANATION:-----
The largest prime factors of numbers are:
3 2  5  3  2  5  5 , of which 5 is most frequent.

The output code needs to read from and write to standard IO


[END PROBLEM]

INFO - [Task id] 759 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] 759 [generation text] ### Problem Restatement

We are given multiple test cases. For each test case, we have a sequence of numbers. For each number in the sequence, we need to find its largest prime factor. Then, we determine which of these largest prime factors appears most frequently in the sequence. If there is a tie, we choose the largest prime factor among the most frequent ones.

### Conceptual Solution

1. **Prime Factorization**: For each number in the sequence, determine its largest prime factor. This can be done by dividing the number by the smallest possible prime numbers until the number itself becomes a prime.

2. **Frequency Counting**: Keep track of how often each largest prime factor appears in the sequence.

3. **Determine the Result**: Identify the prime factor that appears most frequently. If there is a tie, select the largest prime factor among the most frequent ones.

### Pseudocode

1. Define a function `largest_prime_factor` to find the largest prime factor of a given number.
   - Start with the smallest prime (2) and divide the number as long as it is divisible.
   - Continue with the next possible divisors (odd numbers) until the number becomes 1.
   - The last divisor used is the largest prime factor.

2. For each test case:
   - Read the number of elements `N`.
   - Initialize a dictionary to count occurrences of each largest prime factor.
   - For each number in the sequence:
     - Find its largest prime factor using `largest_prime_factor`.
     - Update the count in the dictionary.
   - Determine the prime factor with the highest count. In case of a tie, choose the largest one.

3. Print the result for each test case.

### Python Code

```python
def largest_prime_factor(n):
    # Start with the smallest prime number
    largest_factor = 1
    # Check for number of 2s that divide n
    while n % 2 == 0:
        largest_factor = 2
        n //= 2
    # n must be odd at this point, so a skip of 2 (i.e., i = i + 2) can be used
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            largest_factor = i
            n //= i
    # This condition is to check if n is a prime number greater than 2
    if n > 2:
        largest_factor = n
    return largest_factor

def solve():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    T = int(data[index])
    index += 1
    results = []
    
    for _ in range(T):
        N = int(data[index])
        index += 1
        sequence = map(int, data[index:index + N])
        index += N
        
        prime_count = {}
        
        for number in sequence:
            largest_prime = largest_prime_factor(number)
            if largest_prime in prime_count:
                prime_count[largest_prime] += 1
            else:
                prime_count[largest_prime] = 1
        
        # Find the prime factor with the maximum frequency
        max_count = -1
        result_prime = -1
        
        for prime, count in prime_count.items():
            if count > max_count or (count == max_count and prime > result_prime):
                max_count = count
                result_prime = prime
        
        results.append(result_prime)
    
    for result in results:
        print(result)

```

This code reads input from standard input, processes each test case to find the most frequent largest prime factor, and prints the result for each test case. The `largest_prime_factor` function efficiently finds the largest prime factor of a number by trial division.
INFO - [35m Rollout attempt 1/4[0m
INFO - [33m Retrieving 3 entries for db: episodic 
 [0m
INFO - Retrieved (score=0.4149):

[Task]:
    The chef is trying to solve some series problems, Chef wants your help to code it. Chef has one number N. Help the chef to find N'th number in the series.
    0, 1, 5, 14, 30, 55 â€¦..

    -----Input:-----
    - First-line will contain $T$, the number of test cases. Then the test case...


INFO - Retrieved (score=0.4190):

[Task]:
    Given a set of  N  natural numbers 1,2,3........N and Q query.For each query you have to calculate the total number of subset in which  Ith.
    number of set come at Kth postion.Elements of every subset should be in sorted order.
    The answer could  be very large so you have to pr...


INFO - Retrieved (score=0.4313):

[Task]:
    The MarkiT online virtual market startup wants to organize its grand opening in NIT Patna.
    but they want maximum crowd for their inauguration. So the manager told  this  to Praveen a student in NITP who suggested them:
    The first-year students come to campus  every x hour,
   ...


INFO - [33m Retrieving 3 entries for db: semantic 
 [0m
INFO - Retrieved (score=0.4447):
Title: Integer factorization
Part: 1/3
# Integer factorization

In this article we list several algorithms for factorizing integers, each of them can be both fast and also slow (some slower than others) depending on their input.

Notice, if the number that you want to factorize is actually a prim...


INFO - Retrieved (score=0.4478):
Title: Finding Power of Factorial Divisor
Part: 1/1
# Finding Power of Factorial Divisor

You are given two numbers $n$ and $k$. Find the largest power of $k$ $x$ such that $n!$ is divisible by $k^x$.

## Prime $k$ {data-toc-label="Prime k"}

Let's first consider the case of prime $k$. The explic...


INFO - Retrieved (score=0.4495):
Chapter: Number theory
Section: Primes and factors
Part: 2/2
$};
\node at (13.5,1.5) {$15$};
\node at (14.5,1.5) {$16$};
\node at (15.5,1.5) {$17$};
\node at (16.5,1.5) {$18$};
\node at (17.5,1.5) {$19$};
\node at (18.5,1.5) {$20$};

\end{tikzpicture}
\end{center}

The following code implements t...


INFO - [33m Retrieving 3 entries for db: reflections 
 [0m
INFO - Retrieved (score=0.4327):
The official solution provides an efficient way to handle the problem by precomputing factorials modulo `10^6 + 3` up to a certain limit. This approach is insightful because it leverages the fact that factorials grow very quickly, and for any `n` greater than or equal to `10^6 + 3`, the factorial...


INFO - Retrieved (score=0.4658):
The problem was straightforward, and my solution was similar to the official one, both in logic and efficiency. However, the official solution uses a slightly different approach to calculate the sum of multiples of 10, which is worth noting for its simplicity.

### Key Insights from the Official ...


INFO - Retrieved (score=0.4730):
In this problem, both my solution and the official solution aim to find the N'th term in a series defined by a specific pattern. The series is generated by summing the squares of integers starting from 1. My approach used a direct mathematical formula for the sum of squares, which is efficient an...


INFO - [33m Retrieving 3 entries for db: summaries 
 [0m
INFO - Retrieved (score=0.3933):
In this problem, the task was to calculate the mean of the maximum possible scores for students after processing a series of questions with complexity factors. Each student starts with a score of 10, and their score is multiplied by the complexity factor for each question they solve.

### Key Con...


INFO - Retrieved (score=0.4011):
### Summary of Attempts to Solve the Problem

#### Core Concepts and Patterns
The problem revolves around maximizing an alternating sum of a subsequence of PokÃ©mon strengths. The alternating sum is calculated by adding the first element, subtracting the second, adding the third, and so on. The ke...


INFO - Retrieved (score=0.4192):
In this problem, the core concept was understanding how to compute the number of particles in a box at a given time `N`, starting with `X` particles at time `t=0`. The number of particles at each time `t` is `t` times the number of particles at time `t-1`. This results in a factorial-like growth,...


INFO - [33m Retrieving 3 entries for db: non_func 
 [0m
INFO - Retrieved (score=0.4393):

[description for function: main]
The function reads input from standard input, where the first line contains an integer T representing the number of test cases, followed by T integers. For each integer N, it calculates the N'th term using a specific formula and stores the result. After processin...


INFO - Retrieved (score=0.4849):

[description for function: process_test_cases]
The function reads input from standard input, which includes a number of test cases, and for each test case, it reads an integer N and three integers x, y, and z. It calculates the total number of hours in N days and then determines the least common...


INFO - Retrieved (score=0.4894):

[description for function: main]
The function reads input from standard input, which includes a number of test cases, and for each test case, it reads two integers, N and X. It then calculates the number of particles at time N using a helper function and modular arithmetic, where the result is c...


INFO - Retrieved (score=0.3933): 
[Summary]:
    In this problem, the task was to calculate the mean of the maximum possible scores for students after processing a series of questions with complexity factors. Each student starts with a score of 10, and their score is multiplied by the complexity factor for each question they sol...
INFO - Retrieved (score=0.4011): 
[Summary]:
    ### Summary of Attempts to Solve the Problem

    #### Core Concepts and Patterns
    The problem revolves around maximizing an alternating sum of a subsequence of PokÃ©mon strengths. The alternating sum is calculated by adding the first element, subtracting the second, adding the ...
INFO - Retrieved (score=0.4149): 
[Past Memory]:

    [Task]:
        The chef is trying to solve some series problems, Chef wants your help to code it. Chef has one number N. Help the chef to find N'th number in the series.
        0, 1, 5, 14, 30, 55 â€¦..

        -----Input:-----
        - First-line will contain $T$, the numb...
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] 759 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Tara was completing an Algorithms assignment and got stuck on a question. She thought of who can help her, and got reminded of Kabir who has good problem solving skills. The question is:
Given N$N$ the number of elements in the sequence A1$A_1$,A2$A_2$ â€¦ An$A_n$. Find out the prime factor which occurred maximum number of times among the largest prime factor corresponding to each element. if there are more than one such prime factors print the largest one.
You are friends with Kabir, help him to solve the problem for Tara.

-----Input:-----
- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T test cases follows. 
- First line of each test case contains N$N$, the number of elements in the sequence.
- Second line contains N space separated elements A1$A_1$,A2$A_2$ â€¦ An$A_n$.

-----Output:-----
- For each test case, print a single line, the number which occurs maximum number of times from the largest prime factor corresponding to each element.

-----Constraints-----
- 1â‰¤Tâ‰¤10$1 \leq T \leq 10$
- 1â‰¤Nâ‰¤105$1 \leq N \leq 10^5$
- 2â‰¤A[i]â‰¤105$2 \leq A[i] \leq 10^5$

-----Sample Input:-----
1
7

3 2 15 6 8 5 10

-----Sample Output:-----
5

-----EXPLANATION:-----
The largest prime factors of numbers are:
3 2  5  3  2  5  5 , of which 5 is most frequent.

The output code needs to read from and write to standard IO


[END PROBLEM]

INFO - [Task id] 759 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] 759 [prompt] 
Also, here are some of your memories.
Feel free to use the given information to aid your problem solving process if necessary.
Do not confuse the memories with the problem statement.

## Memories

[Summary]:
    In this problem, the task was to calculate the mean of the maximum possible scores for students after processing a series of questions with complexity factors. Each student starts with a score of 10, and their score is multiplied by the complexity factor for each question they solve.

    ### Key Concepts and Patterns
    - **Array Manipulation**: The problem required updating scores for a range of students, which is efficiently handled using array operations.
    - **Input Parsing**: Handling large input efficiently by reading all data at once and parsing it using indices.
    - **Mean Calculation**: Calculating the mean of scores and using floor division to get the desired result.

    ### Strategies and Fixes
    - **Function Execution**: Initially, the main function was not being called, which resulted in no output. Adding a call to `main()` using the `if __name__ == "__main__":` construct fixed this issue.
    - **Index Management**: Ensuring correct 0-based indexing when parsing input data was crucial to avoid off-by-one errors.
    - **Efficiency**: The solution efficiently handles up to 100,000 students and questions by iterating over the necessary ranges and using list operations.

    ### Code Snippet
    The final solution involved defining a `process_test_case` function to handle each test case and a `main` function to manage input/output. The key was ensuring the main function was executed and that input parsing was handled correctly.

    ```python
    def process_test_case(N, M, questions):
        scores = [10] * N
        for i, j, k in questions:
            for student in range(i, j + 1):
                scores[student] *= k
        total_score = sum(scores)
        mean_score = total_score // N
        return mean_score

    def main():
        import sys
        input = sys.stdin.read
        data = input().split()
        index = 0
        T = int(data[index])
        index += 1
        results = []
        for _ in range(T):
            N = int(data[index])
            M = int(data[index + 1])
            index += 2
            questions = []
            for _ in range(M):
                i = int(data[index]) - 1
                j = int(data[index + 1]) - 1
                k = int(data[index + 2])
                index += 3
                questions.append((i, j, k))
            result = process_test_case(N, M, questions)
            results.append(result)
        for result in results:
            print(result)

    if __name__ == "__main__":
        main()
    ```

    This experience reinforced the importance of correctly managing input/output and ensuring that the main logic of a script is executed, especially in competitive programming and large input scenarios.
[/Summary]


[Summary]:
    ### Summary of Attempts to Solve the Problem

    #### Core Concepts and Patterns
    The problem revolves around maximizing an alternating sum of a subsequence of PokÃ©mon strengths. The alternating sum is calculated by adding the first element, subtracting the second, adding the third, and so on. The key insight is that sorting the strengths in descending order allows us to maximize the sum by adding the largest numbers and subtracting the smaller ones.

    #### Strategies and Mistakes
    Initially, the strategy was to sort the strengths in descending order and then calculate the alternating sum by adding elements at even indices and subtracting elements at odd indices. This approach seemed logical but failed to account for the flexibility in choosing any subsequence, which means we can skip elements to maximize the sum.

    The mistake was in assuming a strict alternation based on index position in the sorted list, rather than considering the potential to skip elements that would decrease the sum.

    #### Correct Approach
    The correct approach involves sorting the strengths in descending order and then iterating through the list, adding elements at even indices and subtracting elements at odd indices. This ensures that the largest values are added first, maximizing the alternating sum.

    #### Unexpected Errors and Fixes
    The main error was in the logic of calculating the alternating sum. The solution was corrected by ensuring that the alternating sum is calculated by leveraging the largest available values, sorted in descending order. The implementation was adjusted to handle input/output correctly, ensuring that the solution is efficient and handles large input sizes effectively.

    ### Code Snippet

    ```python
    def max_alternating_sum(t, test_cases):
        results = []
        for test_case in test_cases:
            n, strengths = test_case
            strengths.sort(reverse=True)
            alternating_sum = 0
            for i in range(n):
                if i % 2 == 0:
                    alternating_sum += strengths[i]
                else:
                    alternating_sum -= strengths[i]
            results.append(alternating_sum)
        return results

    def main():
        import sys
        input = sys.stdin.read
        data = input().split()
    
        index = 0
        t = int(data[index])
        index += 1
        test_cases = []
    
        for _ in range(t):
            n = int(data[index])
            q = int(data[index + 1])
            index += 2
            strengths = list(map(int, data[index:index + n]))
            index += n
            test_cases.append((n, strengths))
    
        results = max_alternating_sum(t, test_cases)
    
        for result in results:
            print(result)

    if __name__ == "__main__":
        main()
    ```

    This experience highlighted the importance of understanding the flexibility in subsequence selection and ensuring that the implementation aligns with the problem's requirements.
[/Summary]


[Past Memory]:

    [Task]:
        The chef is trying to solve some series problems, Chef wants your help to code it. Chef has one number N. Help the chef to find N'th number in the series.
        0, 1, 5, 14, 30, 55 â€¦..

        -----Input:-----
        - First-line will contain $T$, the number of test cases. Then the test cases follow. 
        - Each test case contains a single line of input, one integer $N$. 

        -----Output:-----
        For each test case, output as the pattern.

        -----Constraints-----
        - $1 \leq T \leq 10^4$
        - $1 \leq N \leq 10^4$

        -----Sample Input:-----
        3
        1
        7
        8

        -----Sample Output:-----
        0
        91
        140
    [/Task]

    [Previous Critique]:
        None
    [/Previous Critique]

    [Thought Process and Code]:
        ### Problem Restatement

        We need to find the N'th number in a specific series: 0, 1, 5, 14, 30, 55, ... for multiple test cases. Each test case provides a single integer N, and we need to output the N'th number in the series.

        ### Conceptual Solution

        1. **Identify the Pattern**: 
           - The series starts with 0, 1, 5, 14, 30, 55, ...
           - The differences between consecutive terms are: 1, 4, 9, 16, 25, ...
           - These differences are perfect squares: 1^2, 2^2, 3^2, 4^2, 5^2, ...

        2. **Formulate the Series**:
           - The N'th term can be expressed as a sum of squares: 
             - \( S(N) = 0 + 1^2 + 2^2 + 3^2 + ... + (N-1)^2 \)
           - This is a known mathematical series where the sum of squares of the first (N-1) natural numbers is given by:
             - \( S(N) = \frac{(N-1) \cdot N \cdot (2N-1)}{6} \)

        3. **Plan the Solution**:
           - For each test case, compute the N'th term using the formula for the sum of squares.
           - Output the result for each test case.

        ### Pseudocode

        ```
        function calculate_nth_term(N):
            return (N-1) * N * (2*N-1) // 6

        function main():
            read T
            for each test case:
                read N
                result = calculate_nth_term(N)
                print result
        ```

        ### Final Python Solution

        ```python
        def calculate_nth_term(N):
            # Calculate the N'th term using the sum of squares formula
            return (N - 1) * N * (2 * N - 1) // 6

        def main():
            import sys
            input = sys.stdin.read
            data = input().split()
    
            T = int(data[0])
            results = []
    
            for i in range(1, T + 1):
                N = int(data[i])
                result = calculate_nth_term(N)
                results.append(result)
    
            for result in results:
                print(result)

        if __name__ == "__main__":
            main()
        ```

        ### Explanation

        - **calculate_nth_term**: This function computes the N'th term in the series using the formula for the sum of squares.
        - **main**: This function handles input and output. It reads all input at once for efficiency, especially given the constraints, and processes each test case to compute and print the result.
    [/Thought Process and Code]

    [Environment Feedback]:
        Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.
        Tests passed:

         Input: ['3', '1', '7', '8'] Output: 0
        91
        140

        Tests failed:
        None
    [/Environment Feedback]

    [Result]:
        Success
    [/Result]

[/Past Memory]


INFO - [Task id] 759 [generation text] ### Problem Restatement

We need to find the most frequently occurring largest prime factor among a list of numbers for multiple test cases. If there are ties, we should return the largest prime factor among those that occur most frequently.

### Conceptual Solution

1. **Prime Factorization**: For each number in the list, determine its largest prime factor.
2. **Frequency Counting**: Count the occurrences of each largest prime factor across all numbers in the list.
3. **Determine the Result**: Identify the prime factor that occurs most frequently. If there is a tie, choose the largest prime factor.

### Pseudocode

```
function largest_prime_factor(n):
    Initialize max_prime as -1
    While n is divisible by 2:
        Set max_prime to 2
        Divide n by 2
    For each odd number i from 3 to sqrt(n):
        While n is divisible by i:
            Set max_prime to i
            Divide n by i
    If n is greater than 2:
        Set max_prime to n
    Return max_prime

function process_test_case(N, A):
    Initialize a dictionary to count prime factors
    For each number in A:
        Find the largest prime factor using largest_prime_factor function
        Increment the count of this prime factor in the dictionary
    Find the prime factor with the maximum count
    If there is a tie, choose the largest prime factor
    Return the result

function main():
    Read T (number of test cases)
    For each test case:
        Read N (number of elements)
        Read the list A of N elements
        Call process_test_case with N and A
        Print the result
```

### Final Python Solution

```python
def largest_prime_factor(n):
    max_prime = -1
    # Check for number of 2s
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    # Check for odd factors
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    # If n is a prime number greater than 2
    if n > 2:
        max_prime = n
    return max_prime

def process_test_case(N, A):
    prime_count = {}
    for number in A:
        largest_prime = largest_prime_factor(number)
        if largest_prime in prime_count:
            prime_count[largest_prime] += 1
        else:
            prime_count[largest_prime] = 1
    # Find the prime factor with the maximum count
    max_count = -1
    result_prime = -1
    for prime, count in prime_count.items():
        if count > max_count or (count == max_count and prime > result_prime):
            max_count = count
            result_prime = prime
    return result_prime

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    T = int(data[index])
    index += 1
    results = []
    
    for _ in range(T):
        N = int(data[index])
        index += 1
        A = list(map(int, data[index:index + N]))
        index += N
        result = process_test_case(N, A)
        results.append(result)
    
    for result in results:
        print(result)

if __name__ == "__main__":
    main()
```

### Explanation

- **largest_prime_factor**: This function finds the largest prime factor of a given number by dividing out factors starting from 2 and then odd numbers up to the square root of the number.
- **process_test_case**: This function processes each test case by counting the occurrences of the largest prime factors and determining the most frequent one.
- **main**: This function handles input and output, reading all data at once for efficiency, especially given the constraints, and processes each test case to compute and print the result.
INFO - program_code:
 
def largest_prime_factor(n):
    max_prime = -1
    # Check for number of 2s
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    # Check for odd factors
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    # If n is a prime number greater than 2
    if n > 2:
        max_prime = n
    return max_prime

def process_test_case(N, A):
    prime_count = {}
    for number in A:
        largest_prime = largest_prime_factor(number)
        if largest_prime in prime_count:
            prime_count[largest_prime] += 1
        else:
            prime_count[largest_prime] = 1
    # Find the prime factor with the maximum count
    max_count = -1
    result_prime = -1
    for prime, count in prime_count.items():
        if count > max_count or (count == max_count and prime > result_prime):
            max_count = count
            result_prime = prime
    return result_prime

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    T = int(data[index])
    index += 1
    results = []
    
    for _ in range(T):
        N = int(data[index])
        index += 1
        A = list(map(int, data[index:index + N]))
        index += N
        result = process_test_case(N, A)
        results.append(result)
    
    for result in results:
        print(result)

if __name__ == "__main__":
    main()


INFO - program_name:
 main

INFO - dependencies:
 []

INFO - raw_msg:
 ### Problem Restatement

We need to find the most frequently occurring largest prime factor among a list of numbers for multiple test cases. If there are ties, we should return the largest prime factor among those that occur most frequently.

### Conceptual Solution

1. **Prime Factorization**: For each number in the list, determine its largest prime factor.
2. **Frequency Counting**: Count the occurrences of each largest prime factor across all numbers in the list.
3. **Determine the Result**: Identify the prime factor that occurs most frequently. If there is a tie, choose the largest prime factor.

### Pseudocode

```
function largest_prime_factor(n):
    Initialize max_prime as -1
    While n is divisible by 2:
        Set max_prime to 2
        Divide n by 2
    For each odd number i from 3 to sqrt(n):
        While n is divisible by i:
            Set max_prime to i
            Divide n by i
    If n is greater than 2:
        Set max_prime to n
    Return max_prime

function process_test_case(N, A):
    Initialize a dictionary to count prime factors
    For each number in A:
        Find the largest prime factor using largest_prime_factor function
        Increment the count of this prime factor in the dictionary
    Find the prime factor with the maximum count
    If there is a tie, choose the largest prime factor
    Return the result

function main():
    Read T (number of test cases)
    For each test case:
        Read N (number of elements)
        Read the list A of N elements
        Call process_test_case with N and A
        Print the result
```

### Final Python Solution

```python
def largest_prime_factor(n):
    max_prime = -1
    # Check for number of 2s
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    # Check for odd factors
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    # If n is a prime number greater than 2
    if n > 2:
        max_prime = n
    return max_prime

def process_test_case(N, A):
    prime_count = {}
    for number in A:
        largest_prime = largest_prime_factor(number)
        if largest_prime in prime_count:
            prime_count[largest_prime] += 1
        else:
            prime_count[largest_prime] = 1
    # Find the prime factor with the maximum count
    max_count = -1
    result_prime = -1
    for prime, count in prime_count.items():
        if count > max_count or (count == max_count and prime > result_prime):
            max_count = count
            result_prime = prime
    return result_prime

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    T = int(data[index])
    index += 1
    results = []
    
    for _ in range(T):
        N = int(data[index])
        index += 1
        A = list(map(int, data[index:index + N]))
        index += N
        result = process_test_case(N, A)
        results.append(result)
    
    for result in results:
        print(result)

if __name__ == "__main__":
    main()
```

### Explanation

- **largest_prime_factor**: This function finds the largest prime factor of a given number by dividing out factors starting from 2 and then odd numbers up to the square root of the number.
- **process_test_case**: This function processes each test case by counting the occurrences of the largest prime factors and determining the most frequent one.
- **main**: This function handles input and output, reading all data at once for efficiency, especially given the constraints, and processes each test case to compute and print the result.

INFO - no_parent:
 False

INFO - full code to be executed: 
 
def largest_prime_factor(n):
    max_prime = -1
    # Check for number of 2s
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    # Check for odd factors
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    # If n is a prime number greater than 2
    if n > 2:
        max_prime = n
    return max_prime

def process_test_case(N, A):
    prime_count = {}
    for number in A:
        largest_prime = largest_prime_factor(number)
        if largest_prime in prime_count:
            prime_count[largest_prime] += 1
        else:
            prime_count[largest_prime] = 1
    # Find the prime factor with the maximum count
    max_count = -1
    result_prime = -1
    for prime, count in prime_count.items():
        if count > max_count or (count == max_count and prime > result_prime):
            max_count = count
            result_prime = prime
    return result_prime

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    T = int(data[index])
    index += 1
    results = []
    
    for _ in range(T):
        N = int(data[index])
        index += 1
        A = list(map(int, data[index:index + N]))
        index += N
        result = process_test_case(N, A)
        results.append(result)
    
    for result in results:
        print(result)

if __name__ == "__main__":
    main()


INFO - obs: Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.
Tests passed:

 Input: ['1', '7', '3 2 15 6 8 5 10'] Output: 5

Tests failed:
None
reward: True
done: None
info: {'individual_results': [True]}
INFO - Updated entry: 
[Task]:
    Tara was completing an Algorithms assignment and got stuck on a question. She thought of who can help her, and got reminded of Kabir who has good problem solving skills. The question is:
    Given N$N$ the number of elements in the sequence A1$A_1$,A2$A_2$ â€¦ An$A_n$. Find out the pri...,

INFO - Metadata: {
    "raw_msg": "### Problem Restatement\n\nWe need to find the most frequently occurring largest prime factor among a list of numbers for multiple test cases. If there are ties, we should return the largest prime factor among those that occur most frequently.\n\n### Conceptual Solution\n\n1. **...

INFO - LM call n parse attempt 1 / 3

INFO - [Task id] 759 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Tara was completing an Algorithms assignment and got stuck on a question. She thought of who can help her, and got reminded of Kabir who has good problem solving skills. The question is:
Given N$N$ the number of elements in the sequence A1$A_1$,A2$A_2$ â€¦ An$A_n$. Find out the prime factor which occurred maximum number of times among the largest prime factor corresponding to each element. if there are more than one such prime factors print the largest one.
You are friends with Kabir, help him to solve the problem for Tara.

-----Input:-----
- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T test cases follows. 
- First line of each test case contains N$N$, the number of elements in the sequence.
- Second line contains N space separated elements A1$A_1$,A2$A_2$ â€¦ An$A_n$.

-----Output:-----
- For each test case, print a single line, the number which occurs maximum number of times from the largest prime factor corresponding to each element.

-----Constraints-----
- 1â‰¤Tâ‰¤10$1 \leq T \leq 10$
- 1â‰¤Nâ‰¤105$1 \leq N \leq 10^5$
- 2â‰¤A[i]â‰¤105$2 \leq A[i] \leq 10^5$

-----Sample Input:-----
1
7

3 2 15 6 8 5 10

-----Sample Output:-----
5

-----EXPLANATION:-----
The largest prime factors of numbers are:
3 2  5  3  2  5  5 , of which 5 is most frequent.

The output code needs to read from and write to standard IO


[END PROBLEM]

INFO - [Task id] 759 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] 759 [prompt] ### Problem Restatement

We need to find the most frequently occurring largest prime factor among a list of numbers for multiple test cases. If there are ties, we should return the largest prime factor among those that occur most frequently.

### Conceptual Solution

1. **Prime Factorization**: For each number in the list, determine its largest prime factor.
2. **Frequency Counting**: Count the occurrences of each largest prime factor across all numbers in the list.
3. **Determine the Result**: Identify the prime factor that occurs most frequently. If there is a tie, choose the largest prime factor.

### Pseudocode

```
function largest_prime_factor(n):
    Initialize max_prime as -1
    While n is divisible by 2:
        Set max_prime to 2
        Divide n by 2
    For each odd number i from 3 to sqrt(n):
        While n is divisible by i:
            Set max_prime to i
            Divide n by i
    If n is greater than 2:
        Set max_prime to n
    Return max_prime

function process_test_case(N, A):
    Initialize a dictionary to count prime factors
    For each number in A:
        Find the largest prime factor using largest_prime_factor function
        Increment the count of this prime factor in the dictionary
    Find the prime factor with the maximum count
    If there is a tie, choose the largest prime factor
    Return the result

function main():
    Read T (number of test cases)
    For each test case:
        Read N (number of elements)
        Read the list A of N elements
        Call process_test_case with N and A
        Print the result
```

### Final Python Solution

```python
def largest_prime_factor(n):
    max_prime = -1
    # Check for number of 2s
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    # Check for odd factors
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    # If n is a prime number greater than 2
    if n > 2:
        max_prime = n
    return max_prime

def process_test_case(N, A):
    prime_count = {}
    for number in A:
        largest_prime = largest_prime_factor(number)
        if largest_prime in prime_count:
            prime_count[largest_prime] += 1
        else:
            prime_count[largest_prime] = 1
    # Find the prime factor with the maximum count
    max_count = -1
    result_prime = -1
    for prime, count in prime_count.items():
        if count > max_count or (count == max_count and prime > result_prime):
            max_count = count
            result_prime = prime
    return result_prime

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    T = int(data[index])
    index += 1
    results = []
    
    for _ in range(T):
        N = int(data[index])
        index += 1
        A = list(map(int, data[index:index + N]))
        index += N
        result = process_test_case(N, A)
        results.append(result)
    
    for result in results:
        print(result)

if __name__ == "__main__":
    main()
```

### Explanation

- **largest_prime_factor**: This function finds the largest prime factor of a given number by dividing out factors starting from 2 and then odd numbers up to the square root of the number.
- **process_test_case**: This function processes each test case by counting the occurrences of the largest prime factors and determining the most frequent one.
- **main**: This function handles input and output, reading all data at once for efficiency, especially given the constraints, and processes each test case to compute and print the result.
INFO - [Task id] 759 [prompt] 
[Environment Feedback]:
    Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.
    Tests passed:

     Input: ['1', '7', '3 2 15 6 8 5 10'] Output: 5

    Tests failed:
    None
[/Environment Feedback]

INFO - [Task id] 759 [prompt] 
## Instructions
Now, summarize your attempts as a **standalone** document for your own future reference. (can skip formalities, be concise)

- Only include the most relevant information and code snippets that could be useful in the future.
- If you did not learn much from the current experience (e.g. the problem was too easy), feel free to write less or nothing at all.
- Here are some ideas if the experience was useful:
    - Identifying the core concepts and patterns that problem appears to test for
    - Describing the strategies that seemed to work but did not, and vice versa
    - Describing unexpected errors and how they were fixed

Your summary should be at most a few paragraphs.

INFO - [Task id] 759 [generation text] In this problem, the core concept was to efficiently determine the largest prime factor for each number in a list and then identify the most frequently occurring largest prime factor across multiple test cases. The challenge was to handle large input sizes efficiently, given the constraints.

The solution involved two main functions: `largest_prime_factor` and `process_test_case`. The `largest_prime_factor` function used trial division to find the largest prime factor of a number, starting with the smallest prime (2) and then checking odd numbers up to the square root of the number. This approach is efficient for numbers up to 100,000, as required by the problem constraints.

The `process_test_case` function counted the occurrences of each largest prime factor using a dictionary and determined the most frequent one. If there was a tie, the largest prime factor was chosen.

The main function handled input and output efficiently by reading all data at once and processing each test case in sequence. This approach ensured that the solution was both time and space efficient, which is crucial for handling the upper limits of the input constraints.

Overall, the problem reinforced the importance of efficient prime factorization and frequency counting techniques, especially when dealing with large datasets.
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] 759 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Tara was completing an Algorithms assignment and got stuck on a question. She thought of who can help her, and got reminded of Kabir who has good problem solving skills. The question is:
Given N$N$ the number of elements in the sequence A1$A_1$,A2$A_2$ â€¦ An$A_n$. Find out the prime factor which occurred maximum number of times among the largest prime factor corresponding to each element. if there are more than one such prime factors print the largest one.
You are friends with Kabir, help him to solve the problem for Tara.

-----Input:-----
- The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T test cases follows. 
- First line of each test case contains N$N$, the number of elements in the sequence.
- Second line contains N space separated elements A1$A_1$,A2$A_2$ â€¦ An$A_n$.

-----Output:-----
- For each test case, print a single line, the number which occurs maximum number of times from the largest prime factor corresponding to each element.

-----Constraints-----
- 1â‰¤Tâ‰¤10$1 \leq T \leq 10$
- 1â‰¤Nâ‰¤105$1 \leq N \leq 10^5$
- 2â‰¤A[i]â‰¤105$2 \leq A[i] \leq 10^5$

-----Sample Input:-----
1
7

3 2 15 6 8 5 10

-----Sample Output:-----
5

-----EXPLANATION:-----
The largest prime factors of numbers are:
3 2  5  3  2  5  5 , of which 5 is most frequent.

The output code needs to read from and write to standard IO


[END PROBLEM]

INFO - [Task id] 759 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] 759 [prompt] ### Problem Restatement

We need to find the most frequently occurring largest prime factor among a list of numbers for multiple test cases. If there are ties, we should return the largest prime factor among those that occur most frequently.

### Conceptual Solution

1. **Prime Factorization**: For each number in the list, determine its largest prime factor.
2. **Frequency Counting**: Count the occurrences of each largest prime factor across all numbers in the list.
3. **Determine the Result**: Identify the prime factor that occurs most frequently. If there is a tie, choose the largest prime factor.

### Pseudocode

```
function largest_prime_factor(n):
    Initialize max_prime as -1
    While n is divisible by 2:
        Set max_prime to 2
        Divide n by 2
    For each odd number i from 3 to sqrt(n):
        While n is divisible by i:
            Set max_prime to i
            Divide n by i
    If n is greater than 2:
        Set max_prime to n
    Return max_prime

function process_test_case(N, A):
    Initialize a dictionary to count prime factors
    For each number in A:
        Find the largest prime factor using largest_prime_factor function
        Increment the count of this prime factor in the dictionary
    Find the prime factor with the maximum count
    If there is a tie, choose the largest prime factor
    Return the result

function main():
    Read T (number of test cases)
    For each test case:
        Read N (number of elements)
        Read the list A of N elements
        Call process_test_case with N and A
        Print the result
```

### Final Python Solution

```python
def largest_prime_factor(n):
    max_prime = -1
    # Check for number of 2s
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    # Check for odd factors
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    # If n is a prime number greater than 2
    if n > 2:
        max_prime = n
    return max_prime

def process_test_case(N, A):
    prime_count = {}
    for number in A:
        largest_prime = largest_prime_factor(number)
        if largest_prime in prime_count:
            prime_count[largest_prime] += 1
        else:
            prime_count[largest_prime] = 1
    # Find the prime factor with the maximum count
    max_count = -1
    result_prime = -1
    for prime, count in prime_count.items():
        if count > max_count or (count == max_count and prime > result_prime):
            max_count = count
            result_prime = prime
    return result_prime

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    T = int(data[index])
    index += 1
    results = []
    
    for _ in range(T):
        N = int(data[index])
        index += 1
        A = list(map(int, data[index:index + N]))
        index += N
        result = process_test_case(N, A)
        results.append(result)
    
    for result in results:
        print(result)

if __name__ == "__main__":
    main()
```

### Explanation

- **largest_prime_factor**: This function finds the largest prime factor of a given number by dividing out factors starting from 2 and then odd numbers up to the square root of the number.
- **process_test_case**: This function processes each test case by counting the occurrences of the largest prime factors and determining the most frequent one.
- **main**: This function handles input and output, reading all data at once for efficiency, especially given the constraints, and processes each test case to compute and print the result.
INFO - [Task id] 759 [prompt] 
[Environment Feedback]:
    Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.
    Tests passed:

     Input: ['1', '7', '3 2 15 6 8 5 10'] Output: 5

    Tests failed:
    None
[/Environment Feedback]

INFO - [Task id] 759 [prompt] 
Below is the official solution (do exercise discretion as official solutions can also have mistakes).

You will be reflecting on your attempts to solve the problem.
This will be a **standalone** document for your own future reference. (can skip formalities, be concise)

## Instructions
- Only include the most relevant insights and code snippets that could be useful in the future.
- If you did not learn much from the current experience (e.g. the problem was too easy / official solution was obvious), feel free to write less or nothing at all.
- Here are some ideas if the experience was useful:
    - If the official solution is insightful (e.g. better than yours in time and space complexity or more effective in breaking down the problem statement), distil the key approach of the official solution, step by step.
    - If your approach failed the test cases, reason why the official solution works but yours does not

Your reflection should be at most a few paragraphs.

## Official solution
# cook your dish here
store=[0]*(10**5+1)
def sieve():
	for i in range(2,10**5+1):
		if(store[i]==0):
			store[i]=1
			for j in range(i,10**5+1,i):
				store[j]=i
sieve()
# print(store)
for _ in range(int(input())):
	
	n=int(input())
	li=[int(x) for x in input().split()]

	dp=[0]*(10**5+1)
	for i in li:
		dp[store[i]]+=1
	max_re=0
	res=0
	for i in li:
		if(dp[store[i]]==max_re):
			if(store[i]>res):
				res=store[i]
		elif(dp[store[i]]>max_re):
			max_re=dp[store[i]]
			res=store[i]
	
	print(res)





INFO - [Task id] 759 [generation text] The official solution uses a more efficient approach by leveraging the Sieve of Eratosthenes to precompute the largest prime factor for every number up to 100,000. This is a significant optimization over my initial approach, which computed the largest prime factor for each number individually during each test case. Here's a breakdown of the key insights from the official solution:

1. **Precomputation with Sieve of Eratosthenes**:
   - The solution uses a modified Sieve of Eratosthenes to precompute the largest prime factor for every number up to 100,000. This is stored in an array `store`, where `store[i]` gives the largest prime factor of `i`.
   - This precomputation step is efficient and only needs to be done once, making the solution very fast for multiple test cases.

2. **Efficient Counting**:
   - For each test case, the solution uses an array `dp` to count the occurrences of each largest prime factor across the numbers in the list.
   - This avoids the need for a dictionary and simplifies the counting process.

3. **Finding the Result**:
   - The solution iterates over the list of numbers to determine the most frequent largest prime factor, handling ties by selecting the largest prime factor.

This approach is more efficient in both time and space compared to my initial solution, especially given the constraints. The precomputation step significantly reduces the complexity of finding the largest prime factor for each number, which is crucial for handling large inputs efficiently. This is a valuable technique to remember for similar problems involving prime factorization or divisibility checks.
INFO - Updated entry: In this problem, the core concept was to efficiently determine the largest prime factor for each number in a list and then identify the most frequently occurring largest prime factor across multiple test cases. The challenge was to handle large input sizes efficiently, given the constraints.

The...,

INFO - Metadata: {
    "task_id": 759
}

INFO - Updated entry: The official solution uses a more efficient approach by leveraging the Sieve of Eratosthenes to precompute the largest prime factor for every number up to 100,000. This is a significant optimization over my initial approach, which computed the largest prime factor for each number individually dur...,

INFO - Metadata: {
    "task_id": 759
}

INFO - LM call n parse attempt 1 / 3

INFO - [Task id] 759 [prompt] 
You are a helpful assistant that writes a description of the given function written in the Python programming language.

1) Do not mention the function name.
2) Do not mention anything about helper functions.
3) There might be some helper functions before the main function, but you only need to describe the main function.
4) Try to summarize the function in no more than 6 sentences.
5) Your response should be a single line of text.

INFO - [Task id] 759 [prompt] 
def largest_prime_factor(n):
    max_prime = -1
    # Check for number of 2s
    while n % 2 == 0:
        max_prime = 2
        n //= 2
    # Check for odd factors
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            max_prime = i
            n //= i
    # If n is a prime number greater than 2
    if n > 2:
        max_prime = n
    return max_prime

def process_test_case(N, A):
    prime_count = {}
    for number in A:
        largest_prime = largest_prime_factor(number)
        if largest_prime in prime_count:
            prime_count[largest_prime] += 1
        else:
            prime_count[largest_prime] = 1
    # Find the prime factor with the maximum count
    max_count = -1
    result_prime = -1
    for prime, count in prime_count.items():
        if count > max_count or (count == max_count and prime > result_prime):
            max_count = count
            result_prime = prime
    return result_prime

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    
    index = 0
    T = int(data[index])
    index += 1
    results = []
    
    for _ in range(T):
        N = int(data[index])
        index += 1
        A = list(map(int, data[index:index + N]))
        index += N
        result = process_test_case(N, A)
        results.append(result)
    
    for result in results:
        print(result)

if __name__ == "__main__":
    main()


The main function is `main`.
INFO - [Task id] 759 [generation text] The function reads input from standard input, which includes multiple test cases. For each test case, it reads an integer N followed by a list of N integers. It processes each test case to determine the largest prime factor that appears most frequently among the integers in the list. If there is a tie in frequency, it selects the largest prime factor. The function collects the results for all test cases and prints each result on a new line.
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] 759 [prompt] 
You are a helpful assistant that extracts important information from problems and solutions to aid in searchability and education.

## Instructions
- Read through the problem and solution carefully.
- Reason out, step by step, in what scenarios this knowledge would be useful.
- Focus on general patterns and situations to help connect this knowledge to new situations.
- Then, include a list of keywords that are useful for searching this problem/solution pair.

## Response format
Respond in JSON, and follow the keys and expected format of the values strictly.

The output should be formatted as a JSON instance that conforms to the JSON schema below.

As an example, for the schema {"properties": {"foo": {"title": "Foo", "description": "a list of strings", "type": "array", "items": {"type": "string"}}}, "required": ["foo"]}
the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema. The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.

Here is the output schema:
```
{"properties": {"scenarios": {"description": "In what scenarios will this knowledge be useful? Answer in a paragraph.", "title": "Scenarios", "type": "string"}, "keywords": {"description": "List of keywords that are useful for searching this problem/solution pair", "items": {"type": "string"}, "title": "Keywords", "type": "array"}}, "required": ["scenarios", "keywords"]}
```

INFO - [Task id] 759 [prompt] 
[Problem]
    Tara was completing an Algorithms assignment and got stuck on a question. She thought of who can help her, and got reminded of Kabir who has good problem solving skills. The question is:
    Given N$N$ the number of elements in the sequence A1$A_1$,A2$A_2$ â€¦ An$A_n$. Find out the prime factor which occurred maximum number of times among the largest prime factor corresponding to each element. if there are more than one such prime factors print the largest one.
    You are friends with Kabir, help him to solve the problem for Tara.

    -----Input:-----
    - The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T test cases follows. 
    - First line of each test case contains N$N$, the number of elements in the sequence.
    - Second line contains N space separated elements A1$A_1$,A2$A_2$ â€¦ An$A_n$.

    -----Output:-----
    - For each test case, print a single line, the number which occurs maximum number of times from the largest prime factor corresponding to each element.

    -----Constraints-----
    - 1â‰¤Tâ‰¤10$1 \leq T \leq 10$
    - 1â‰¤Nâ‰¤105$1 \leq N \leq 10^5$
    - 2â‰¤A[i]â‰¤105$2 \leq A[i] \leq 10^5$

    -----Sample Input:-----
    1
    7

    3 2 15 6 8 5 10

    -----Sample Output:-----
    5

    -----EXPLANATION:-----
    The largest prime factors of numbers are:
    3 2  5  3  2  5  5 , of which 5 is most frequent.
[/Problem]

[Solution]

    def largest_prime_factor(n):
        max_prime = -1
        # Check for number of 2s
        while n % 2 == 0:
            max_prime = 2
            n //= 2
        # Check for odd factors
        for i in range(3, int(n**0.5) + 1, 2):
            while n % i == 0:
                max_prime = i
                n //= i
        # If n is a prime number greater than 2
        if n > 2:
            max_prime = n
        return max_prime

    def process_test_case(N, A):
        prime_count = {}
        for number in A:
            largest_prime = largest_prime_factor(number)
            if largest_prime in prime_count:
                prime_count[largest_prime] += 1
            else:
                prime_count[largest_prime] = 1
        # Find the prime factor with the maximum count
        max_count = -1
        result_prime = -1
        for prime, count in prime_count.items():
            if count > max_count or (count == max_count and prime > result_prime):
                max_count = count
                result_prime = prime
        return result_prime

    def main():
        import sys
        input = sys.stdin.read
        data = input().split()
    
        index = 0
        T = int(data[index])
        index += 1
        results = []
    
        for _ in range(T):
            N = int(data[index])
            index += 1
            A = list(map(int, data[index:index + N]))
            index += N
            result = process_test_case(N, A)
            results.append(result)
    
        for result in results:
            print(result)

    if __name__ == "__main__":
        main()

[/Solution]

INFO - [Task id] 759 [generation text] 
INFO - {
    "scenarios": "This knowledge is useful in scenarios where one needs to analyze sequences of numbers to determine the most frequently occurring largest prime factor. This can be applied in cryptography, number theory, and algorithm design where prime factorization plays a crucial role. It is also useful in competitive programming and coding interviews where similar problems involving prime factors and frequency analysis are common. Understanding how to efficiently compute the largest prime factor and count occurrences can help in optimizing solutions for large datasets, as seen in the constraints of this problem.",
    "keywords": [
        "prime factorization",
        "largest prime factor",
        "frequency analysis",
        "algorithm design",
        "competitive programming",
        "number theory",
        "sequence analysis",
        "optimization",
        "coding interview"
    ]
}
INFO - {
    "scenarios": "This knowledge is useful in scenarios where one needs to analyze sequences of numbers to determine the most frequently occurring largest prime factor. This can be applied in cryptography, number theory, and algorithm design where prime factorization plays a crucial role. It is also useful in competitive programming and coding interviews where similar problems involving prime factors and frequency analysis are common. Understanding how to efficiently compute the largest prime factor and count occurrences can help in optimizing solutions for large datasets, as seen in the constraints of this problem.",
    "keywords": [
        "prime factorization",
        "largest prime factor",
        "frequency analysis",
        "algorithm design",
        "competitive programming",
        "number theory",
        "sequence analysis",
        "optimization",
        "coding interview"
    ]
}
INFO - Updated entry: 
[description for function: main]
The function reads input from standard input, which includes multiple test cases. For each test case, it reads an integer N followed by a list of N integers. It processes each test case to determine the largest prime factor that appears most frequently among the ...,

INFO - Metadata: {
    "task": 759,
    "code": "\ndef largest_prime_factor(n):\n    max_prime = -1\n    # Check for number of 2s\n    while n % 2 == 0:\n        max_prime = 2\n        n //= 2\n    # Check for odd factors\n    for i in range(3, int(n**0.5) + 1, 2):\n        while n % i == 0:\n            max_prim...

