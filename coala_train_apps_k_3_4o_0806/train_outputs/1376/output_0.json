{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['1', '2 4', '3 4 1'] Expected output: [{'2', '1', '3'}, {'1', '0', '3'}] # Execution output: ['1 4 0 0', '0 3 2 1']",
    "code": "\ndef distribute_ducks(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N, K = test_case[0]\n        duck_counts = test_case[1]\n        \n        # Create a list of (color, count) and sort by count descending\n        color_counts = [(i, duck_counts[i]) for i in range(N + 1)]\n        color_counts.sort(key=lambda x: x[1], reverse=True)\n        \n        boxes = []\n        \n        while len(boxes) < N:\n            # Take the first color with the most ducks\n            c1, m1 = color_counts[0]\n            if m1 >= K:\n                # If we can fill a box with this color alone\n                boxes.append((c1, K, 0, 0))\n                color_counts[0] = (c1, m1 - K)\n            else:\n                # Otherwise, fill with this color and the next\n                c2, m2 = color_counts[1]\n                if m1 + m2 <= K:\n                    boxes.append((c1, m1, c2, K - m1))\n                    color_counts[0] = (c1, 0)\n                    color_counts[1] = (c2, m2 - (K - m1))\n                else:\n                    boxes.append((c1, m1, c2, K - m1))\n                    color_counts[0] = (c1, 0)\n                    color_counts[1] = (c2, m2 - (K - m1))\n            \n            # Remove colors with zero ducks left\n            color_counts = [(c, m) for c, m in color_counts if m > 0]\n            color_counts.sort(key=lambda x: x[1], reverse=True)\n        \n        results.append(boxes)\n    \n    for result in results:\n        for box in result:\n            print(f\"{box[0]} {box[1]} {box[2]} {box[3]}\")\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(T):\n        N, K = map(int, data[index:index + 2])\n        index += 2\n        duck_counts = list(map(int, data[index:index + N + 1]))\n        index += N + 1\n        test_cases.append(((N, K), duck_counts))\n    \n    distribute_ducks(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\ndef distribute_ducks(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N, K = test_case[0]\n        duck_counts = test_case[1]\n        \n        # Create a list of (color, count) and sort by count descending\n        color_counts = [(i, duck_counts[i]) for i in range(N + 1)]\n        color_counts.sort(key=lambda x: x[1], reverse=True)\n        \n        boxes = []\n        \n        while len(boxes) < N:\n            # Take the first color with the most ducks\n            c1, m1 = color_counts[0]\n            if m1 >= K:\n                # If we can fill a box with this color alone\n                boxes.append((c1, K, 0, 0))\n                color_counts[0] = (c1, m1 - K)\n            else:\n                # Otherwise, fill with this color and the next\n                c2, m2 = color_counts[1]\n                if m1 + m2 <= K:\n                    boxes.append((c1, m1, c2, K - m1))\n                    color_counts[0] = (c1, 0)\n                    color_counts[1] = (c2, m2 - (K - m1))\n                else:\n                    boxes.append((c1, m1, c2, K - m1))\n                    color_counts[0] = (c1, 0)\n                    color_counts[1] = (c2, m2 - (K - m1))\n            \n            # Remove colors with zero ducks left\n            color_counts = [(c, m) for c, m in color_counts if m > 0]\n            color_counts.sort(key=lambda x: x[1], reverse=True)\n        \n        results.append(boxes)\n    \n    for result in results:\n        for box in result:\n            print(f\"{box[0]} {box[1]} {box[2]} {box[3]}\")\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(T):\n        N, K = map(int, data[index:index + 2])\n        index += 2\n        duck_counts = list(map(int, data[index:index + N + 1]))\n        index += N + 1\n        test_cases.append(((N, K), duck_counts))\n    \n    distribute_ducks(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": false,
    "program_code": "\ndef distribute_ducks(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N, K = test_case[0]\n        duck_counts = test_case[1]\n        \n        # Create a list of (color, count) and sort by count descending\n        color_counts = [(i, duck_counts[i]) for i in range(N + 1)]\n        color_counts.sort(key=lambda x: x[1], reverse=True)\n        \n        boxes = []\n        \n        while len(boxes) < N:\n            # Take the first color with the most ducks\n            c1, m1 = color_counts[0]\n            if m1 >= K:\n                # If we can fill a box with this color alone\n                boxes.append((c1, K, 0, 0))\n                color_counts[0] = (c1, m1 - K)\n            else:\n                # Otherwise, fill with this color and the next\n                c2, m2 = color_counts[1]\n                if m1 + m2 <= K:\n                    boxes.append((c1, m1, c2, K - m1))\n                    color_counts[0] = (c1, 0)\n                    color_counts[1] = (c2, m2 - (K - m1))\n                else:\n                    boxes.append((c1, m1, c2, K - m1))\n                    color_counts[0] = (c1, 0)\n                    color_counts[1] = (c2, m2 - (K - m1))\n            \n            # Remove colors with zero ducks left\n            color_counts = [(c, m) for c, m in color_counts if m > 0]\n            color_counts.sort(key=lambda x: x[1], reverse=True)\n        \n        results.append(boxes)\n    \n    for result in results:\n        for box in result:\n            print(f\"{box[0]} {box[1]} {box[2]} {box[3]}\")\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(T):\n        N, K = map(int, data[index:index + 2])\n        index += 2\n        duck_counts = list(map(int, data[index:index + N + 1]))\n        index += N + 1\n        test_cases.append(((N, K), duck_counts))\n    \n    distribute_ducks(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nSalmon has a collection of rubber ducks, each with a specific color. He wants to organize these ducks into boxes. Each box can hold exactly `K` ducks, and there are `N` boxes available. The ducks come in `N+1` different colors. The goal is to distribute the ducks into the boxes such that each box contains at most two distinct colors.\n\n### Conceptual Solution\n\n1. **Input Parsing**: For each test case, read the number of colors `N`, the capacity `K` of each box, and the list of duck counts for each color.\n\n2. **Distribution Strategy**:\n   - Use a greedy approach to fill each box with ducks from at most two colors.\n   - Start with the color that has the most ducks and fill the boxes until the count is exhausted or the box is full.\n   - If the box isn't full after using one color, fill the remaining space with ducks from the next available color.\n   - Continue this process until all ducks are placed in boxes.\n\n3. **Output**: For each box, output the two colors and the number of ducks from each color in the box.\n\n### Pseudocode\n\n```\nfunction distribute_ducks(T, test_cases):\n    for each test_case in test_cases:\n        N, K = test_case[0]\n        duck_counts = test_case[1]\n        \n        create a list of tuples (color, count) from duck_counts\n        sort the list by count in descending order\n        \n        initialize an empty list for boxes\n        \n        while there are ducks to place:\n            take the first color with the most ducks\n            if its count is greater than or equal to K:\n                place K ducks of this color in a new box\n                reduce the count of this color by K\n            else:\n                place all ducks of this color in a new box\n                reduce the count of this color to 0\n                fill the remaining space in the box with ducks from the next color\n                reduce the count of the second color accordingly\n            \n            add the box configuration to the boxes list\n        \n        output the boxes list for the current test case\n```\n\n### Final Python Code\n\n```python\ndef distribute_ducks(T, test_cases):\n    results = []\n    for test_case in test_cases:\n        N, K = test_case[0]\n        duck_counts = test_case[1]\n        \n        # Create a list of (color, count) and sort by count descending\n        color_counts = [(i, duck_counts[i]) for i in range(N + 1)]\n        color_counts.sort(key=lambda x: x[1], reverse=True)\n        \n        boxes = []\n        \n        while len(boxes) < N:\n            # Take the first color with the most ducks\n            c1, m1 = color_counts[0]\n            if m1 >= K:\n                # If we can fill a box with this color alone\n                boxes.append((c1, K, 0, 0))\n                color_counts[0] = (c1, m1 - K)\n            else:\n                # Otherwise, fill with this color and the next\n                c2, m2 = color_counts[1]\n                if m1 + m2 <= K:\n                    boxes.append((c1, m1, c2, K - m1))\n                    color_counts[0] = (c1, 0)\n                    color_counts[1] = (c2, m2 - (K - m1))\n                else:\n                    boxes.append((c1, m1, c2, K - m1))\n                    color_counts[0] = (c1, 0)\n                    color_counts[1] = (c2, m2 - (K - m1))\n            \n            # Remove colors with zero ducks left\n            color_counts = [(c, m) for c, m in color_counts if m > 0]\n            color_counts.sort(key=lambda x: x[1], reverse=True)\n        \n        results.append(boxes)\n    \n    for result in results:\n        for box in result:\n            print(f\"{box[0]} {box[1]} {box[2]} {box[3]}\")\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    test_cases = []\n    \n    for _ in range(T):\n        N, K = map(int, data[index:index + 2])\n        index += 2\n        duck_counts = list(map(int, data[index:index + N + 1]))\n        index += N + 1\n        test_cases.append(((N, K), duck_counts))\n    \n    distribute_ducks(T, test_cases)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis code reads input, processes each test case to distribute ducks into boxes according to the constraints, and outputs the configuration of ducks in each box.",
    "no_parent": false,
    "dependency_used": false
}