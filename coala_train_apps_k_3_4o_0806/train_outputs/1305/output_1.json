{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['2', '4', '1 0 1 0', '0 0 0 1', '0 1 0 0', '1 0 0 1', '4', '1 0 1 0', '0 0 0 0', '1 0 1 1', '0 1 0 0'] Expected output: [{'SAFE'}, {'UNSAFE'}] # Execution output: ['UNSAFE', 'UNSAFE']",
    "code": "\ndef is_safe(grid, N):\n    # Directions for all 8 possible adjacent positions\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 1:\n                        return \"UNSAFE\"\n    return \"SAFE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\ndef is_safe(grid, N):\n    # Directions for all 8 possible adjacent positions\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 1:\n                        return \"UNSAFE\"\n    return \"SAFE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": false,
    "program_code": "\ndef is_safe(grid, N):\n    # Directions for all 8 possible adjacent positions\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 1:\n                        return \"UNSAFE\"\n    return \"SAFE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "Let's address the issue with the previous solution. The logic for checking adjacent beds is correct, but there might be an issue with how the input is being processed or how the results are being stored and printed. Let's ensure that the input parsing and result handling are correct.\n\nHere's the revised code:\n\n```python\ndef is_safe(grid, N):\n    # Directions for all 8 possible adjacent positions\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 1:\n                        return \"UNSAFE\"\n    return \"SAFE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation of Fixes\n\n- **Input Parsing**: The input is read as a single string and split into a list of strings. We ensure that the grid is correctly constructed by slicing the input list with the correct indices.\n- **Result Handling**: Each result is stored in a list and printed on a new line to match the expected output format.\n\nThis code should correctly handle the input and output, ensuring that each test case is processed independently and results are printed correctly.",
    "no_parent": false,
    "dependency_used": false
}