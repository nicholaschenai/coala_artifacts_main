{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['2', '4', '1 0 1 0', '0 0 0 1', '0 1 0 0', '1 0 0 1', '4', '1 0 1 0', '0 0 0 0', '1 0 1 1', '0 1 0 0'] Expected output: [{'SAFE'}, {'UNSAFE'}] # Execution output: ['UNSAFE', 'UNSAFE']",
    "code": "\ndef is_safe(grid, N):\n    # Directions for all 8 possible adjacent positions\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 1:\n                        return \"UNSAFE\"\n    return \"SAFE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\ndef is_safe(grid, N):\n    # Directions for all 8 possible adjacent positions\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 1:\n                        return \"UNSAFE\"\n    return \"SAFE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": false,
    "program_code": "\ndef is_safe(grid, N):\n    # Directions for all 8 possible adjacent positions\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 1:\n                        return \"UNSAFE\"\n    return \"SAFE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe are given a grid of size \\( N \\times N \\) where each cell can either have a bed (denoted by 1) or be empty (denoted by 0). The task is to determine if the arrangement of beds is \"SAFE\" or \"UNSAFE\". An arrangement is considered \"SAFE\" if no two beds are adjacent horizontally, vertically, or diagonally. We need to check multiple test cases and output \"SAFE\" or \"UNSAFE\" for each.\n\n### Conceptual Solution\n\n1. **Input Parsing**: Read the number of test cases \\( T \\). For each test case, read the size \\( N \\) and then the \\( N \\times N \\) grid.\n2. **Safety Check**: For each grid, check every cell that contains a bed (1). Ensure that no adjacent cell (including diagonals) also contains a bed.\n3. **Output**: If any adjacent beds are found, mark the grid as \"UNSAFE\". If no such pairs are found, mark it as \"SAFE\".\n\n### Pseudocode\n\n```\nfunction is_safe(grid, N):\n    for each row i from 0 to N-1:\n        for each column j from 0 to N-1:\n            if grid[i][j] == 1:\n                # Check all 8 possible adjacent positions\n                for each (di, dj) in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n                    ni = i + di\n                    nj = j + dj\n                    if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 1:\n                        return \"UNSAFE\"\n    return \"SAFE\"\n\nfunction main():\n    read T\n    for each test case:\n        read N\n        read the N x N grid\n        result = is_safe(grid, N)\n        print(result)\n```\n\n### Final Python Code\n\n```python\ndef is_safe(grid, N):\n    # Directions for all 8 possible adjacent positions\n    directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 1:\n                for di, dj in directions:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < N and 0 <= nj < N and grid[ni][nj] == 1:\n                        return \"UNSAFE\"\n    return \"SAFE\"\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        index += 1\n        grid = []\n        for _ in range(N):\n            row = list(map(int, data[index:index + N]))\n            index += N\n            grid.append(row)\n        \n        result = is_safe(grid, N)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n- **is_safe Function**: This function checks each cell in the grid. If a bed is found, it checks all 8 possible adjacent cells. If any of these cells also contain a bed, the grid is marked as \"UNSAFE\".\n- **main Function**: This function handles input and output. It reads the number of test cases, processes each grid, and prints whether it is \"SAFE\" or \"UNSAFE\".",
    "no_parent": false,
    "dependency_used": false
}