{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: [[6, 4, 14, 6, 8, 13, 9, 7, 10, 6, 12], 2] Output: 4\n\nTests failed:\nNone",
    "code": "\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        dp = [1] * n\n        indices = list(range(n))\n        indices.sort(key=lambda i: arr[i])\n\n        for i in indices:\n            # Check right jumps\n            for x in range(1, d + 1):\n                if i + x < n and arr[i] > arr[i + x]:\n                    dp[i] = max(dp[i], dp[i + x] + 1)\n                else:\n                    break\n            # Check left jumps\n            for x in range(1, d + 1):\n                if i - x >= 0 and arr[i] > arr[i - x]:\n                    dp[i] = max(dp[i], dp[i - x] + 1)\n                else:\n                    break\n\n        return max(dp)\n",
    "full_code": "\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        dp = [1] * n\n        indices = list(range(n))\n        indices.sort(key=lambda i: arr[i])\n\n        for i in indices:\n            # Check right jumps\n            for x in range(1, d + 1):\n                if i + x < n and arr[i] > arr[i + x]:\n                    dp[i] = max(dp[i], dp[i + x] + 1)\n                else:\n                    break\n            # Check left jumps\n            for x in range(1, d + 1):\n                if i - x >= 0 and arr[i] > arr[i - x]:\n                    dp[i] = max(dp[i], dp[i - x] + 1)\n                else:\n                    break\n\n        return max(dp)\n",
    "reward": true,
    "program_code": "\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        dp = [1] * n\n        indices = list(range(n))\n        indices.sort(key=lambda i: arr[i])\n\n        for i in indices:\n            # Check right jumps\n            for x in range(1, d + 1):\n                if i + x < n and arr[i] > arr[i + x]:\n                    dp[i] = max(dp[i], dp[i + x] + 1)\n                else:\n                    break\n            # Check left jumps\n            for x in range(1, d + 1):\n                if i - x >= 0 and arr[i] > arr[i - x]:\n                    dp[i] = max(dp[i], dp[i - x] + 1)\n                else:\n                    break\n\n        return max(dp)\n",
    "program_name": "",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe are given an array of integers `arr` and an integer `d`. We can jump from an index `i` to another index `j` if:\n- `arr[i] > arr[j]`\n- All elements between `i` and `j` are less than `arr[i]`\n- The jump distance `|i - j|` is less than or equal to `d`\n\nThe task is to determine the maximum number of indices we can visit starting from any index in the array.\n\n### Conceptual Solution\n\n1. **Dynamic Programming Approach**: We can use dynamic programming to solve this problem. We'll maintain a `dp` array where `dp[i]` represents the maximum number of indices that can be visited starting from index `i`.\n\n2. **Sorting by Value**: To efficiently determine the order of processing, we can sort the indices based on the values in `arr`. This allows us to process the indices in increasing order of their values, ensuring that when we process an index, all possible jumps to lower values have already been considered.\n\n3. **Updating the DP Array**: For each index `i`, we will:\n   - Check all possible jumps to the right (i.e., `i + x` where `1 <= x <= d`).\n   - Check all possible jumps to the left (i.e., `i - x` where `1 <= x <= d`).\n   - Update `dp[i]` based on valid jumps to indices with smaller values.\n\n4. **Result**: The result will be the maximum value in the `dp` array, as it represents the maximum number of indices that can be visited starting from any index.\n\n### Pseudocode\n\n```\nfunction maxJumps(arr, d):\n    n = length of arr\n    dp = array of size n initialized to 1\n    indices = array of indices from 0 to n-1\n    sort indices based on values in arr\n\n    for each index i in indices:\n        for x from 1 to d:\n            if i + x < n and arr[i] > arr[i + x]:\n                dp[i] = max(dp[i], dp[i + x] + 1)\n            else:\n                break\n        for x from 1 to d:\n            if i - x >= 0 and arr[i] > arr[i - x]:\n                dp[i] = max(dp[i], dp[i - x] + 1)\n            else:\n                break\n\n    return max value in dp\n```\n\n### Final Python Solution\n\n```python\nclass Solution:\n    def maxJumps(self, arr: List[int], d: int) -> int:\n        n = len(arr)\n        dp = [1] * n\n        indices = list(range(n))\n        indices.sort(key=lambda i: arr[i])\n\n        for i in indices:\n            # Check right jumps\n            for x in range(1, d + 1):\n                if i + x < n and arr[i] > arr[i + x]:\n                    dp[i] = max(dp[i], dp[i + x] + 1)\n                else:\n                    break\n            # Check left jumps\n            for x in range(1, d + 1):\n                if i - x >= 0 and arr[i] > arr[i - x]:\n                    dp[i] = max(dp[i], dp[i - x] + 1)\n                else:\n                    break\n\n        return max(dp)\n```\n\n### Explanation of the Code\n\n- We initialize a `dp` array where each element is set to 1, indicating that each index can at least visit itself.\n- We sort the indices based on the values in `arr` to ensure we process smaller values first.\n- For each index, we attempt to jump both to the right and left within the allowed distance `d`, updating the `dp` array based on valid jumps.\n- Finally, we return the maximum value in the `dp` array, which represents the maximum number of indices that can be visited starting from any index.",
    "no_parent": false,
    "dependency_used": false
}