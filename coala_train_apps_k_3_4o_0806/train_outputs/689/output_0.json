{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['2', '0 1', '1 -1'] Expected output: [{'YES'}] # Execution output: ['NO']",
    "code": "\ndef check_zebras_spitting(t, zebras):\n    # Dictionary to store the target position each zebra can hit\n    spit_targets = {}\n    \n    # Populate the spit_targets dictionary\n    for a, b in zebras:\n        target_position = a + b\n        spit_targets[a] = target_position\n    \n    # Check if any zebra can be hit by another zebra\n    for a, b in zebras:\n        # Calculate the position from which this zebra can be hit\n        hit_position = a - b\n        # Check if this position is a key in spit_targets and maps to the current zebra's position\n        if hit_position in spit_targets and spit_targets[hit_position] == a:\n            print(\"YES\")\n            return\n    \n    # If no such pair is found, output \"NO\"\n    print(\"NO\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nt = int(data[0])\nzebras = []\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    zebras.append((a, b))\n    index += 2\n\n# Call the function with the parsed input\ncheck_zebras_spitting(t, zebras)\n",
    "full_code": "\ndef check_zebras_spitting(t, zebras):\n    # Dictionary to store the target position each zebra can hit\n    spit_targets = {}\n    \n    # Populate the spit_targets dictionary\n    for a, b in zebras:\n        target_position = a + b\n        spit_targets[a] = target_position\n    \n    # Check if any zebra can be hit by another zebra\n    for a, b in zebras:\n        # Calculate the position from which this zebra can be hit\n        hit_position = a - b\n        # Check if this position is a key in spit_targets and maps to the current zebra's position\n        if hit_position in spit_targets and spit_targets[hit_position] == a:\n            print(\"YES\")\n            return\n    \n    # If no such pair is found, output \"NO\"\n    print(\"NO\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nt = int(data[0])\nzebras = []\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    zebras.append((a, b))\n    index += 2\n\n# Call the function with the parsed input\ncheck_zebras_spitting(t, zebras)\n",
    "reward": false,
    "program_code": "\ndef check_zebras_spitting(t, zebras):\n    # Dictionary to store the target position each zebra can hit\n    spit_targets = {}\n    \n    # Populate the spit_targets dictionary\n    for a, b in zebras:\n        target_position = a + b\n        spit_targets[a] = target_position\n    \n    # Check if any zebra can be hit by another zebra\n    for a, b in zebras:\n        # Calculate the position from which this zebra can be hit\n        hit_position = a - b\n        # Check if this position is a key in spit_targets and maps to the current zebra's position\n        if hit_position in spit_targets and spit_targets[hit_position] == a:\n            print(\"YES\")\n            return\n    \n    # If no such pair is found, output \"NO\"\n    print(\"NO\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nt = int(data[0])\nzebras = []\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    zebras.append((a, b))\n    index += 2\n\n# Call the function with the parsed input\ncheck_zebras_spitting(t, zebras)\n",
    "program_name": "check_zebras_spitting",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n\n   We have a list of zebras, each with a position and a distance they can spit. We need to determine if there are any two zebras that can spit at each other. A zebra at position `a` spits `b` meters, hitting a zebra at position `a + b`. We need to check if there exists a pair of zebras such that one spits and hits the other, and vice versa.\n\n2. **Conceptualize a solution in plain English:**\n\n   To solve this problem, we can use a dictionary to map each zebra's position to the position it can hit when it spits. For each zebra, calculate the position it can hit and store this in the dictionary. Then, for each zebra, check if its position is a target of another zebra's spit. If we find such a pair, we output \"YES\". If no such pair exists after checking all zebras, we output \"NO\".\n\n3. **Write a pseudocode solution:**\n\n   ```\n   Initialize an empty dictionary `spit_targets`.\n   For each zebra with position `a` and spit distance `b`:\n       Calculate the target position as `a + b`.\n       Store this target position in `spit_targets` with `a` as the key.\n   \n   For each zebra with position `a`:\n       Calculate the position it can be hit from as `a - b`.\n       Check if this position is a key in `spit_targets` and if it maps to `a`.\n       If such a position exists, output \"YES\" and exit.\n   \n   If no such pair is found, output \"NO\".\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n\n```python\ndef check_zebras_spitting(t, zebras):\n    # Dictionary to store the target position each zebra can hit\n    spit_targets = {}\n    \n    # Populate the spit_targets dictionary\n    for a, b in zebras:\n        target_position = a + b\n        spit_targets[a] = target_position\n    \n    # Check if any zebra can be hit by another zebra\n    for a, b in zebras:\n        # Calculate the position from which this zebra can be hit\n        hit_position = a - b\n        # Check if this position is a key in spit_targets and maps to the current zebra's position\n        if hit_position in spit_targets and spit_targets[hit_position] == a:\n            print(\"YES\")\n            return\n    \n    # If no such pair is found, output \"NO\"\n    print(\"NO\")\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\n# Parse input\nt = int(data[0])\nzebras = []\nindex = 1\nfor _ in range(t):\n    a = int(data[index])\n    b = int(data[index + 1])\n    zebras.append((a, b))\n    index += 2\n\n# Call the function with the parsed input\ncheck_zebras_spitting(t, zebras)\n```\n\nThis solution efficiently checks for pairs of zebras that can spit at each other by leveraging a dictionary to map spit targets and checking for mutual hits.",
    "no_parent": false,
    "dependency_used": false
}