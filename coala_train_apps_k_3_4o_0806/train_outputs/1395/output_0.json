{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['1', '2 6'] Expected output: [{'3'}] # Execution output: []\nNo output detected. You might want to check the reading from / writing to standard IO.\nA common mistake is to put the IO inside a function, but the function is not called.\n",
    "code": "\ndef countDivisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        A = int(data[index])\n        B = int(data[index + 1])\n        index += 2\n        \n        diff = abs(A - B)\n        if diff == 0:\n            results.append(-1)\n        else:\n            results.append(countDivisors(diff))\n    \n    for result in results:\n        print(result)\n\n",
    "full_code": "\ndef countDivisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        A = int(data[index])\n        B = int(data[index + 1])\n        index += 2\n        \n        diff = abs(A - B)\n        if diff == 0:\n            results.append(-1)\n        else:\n            results.append(countDivisors(diff))\n    \n    for result in results:\n        print(result)\n\n",
    "reward": false,
    "program_code": "\ndef countDivisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        A = int(data[index])\n        B = int(data[index + 1])\n        index += 2\n        \n        diff = abs(A - B)\n        if diff == 0:\n            results.append(-1)\n        else:\n            results.append(countDivisors(diff))\n    \n    for result in results:\n        print(result)\n\n",
    "program_name": "solve",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nRam and Shyam want to cheat on an exam by getting the same set of questions. The exam board has `p` different sets of questions, and each student gets a set based on their roll number `r` using the formula `((r-1) % p)`. Given the roll numbers `A` and `B` for Ram and Shyam, we need to find how many values of `p` allow them to get the same set of questions. If there are infinitely many such values, we should return `-1`.\n\n### Conceptual Solution\n\n1. **Understanding the Condition**: Ram and Shyam can cheat if `((A-1) % p) == ((B-1) % p)`. This implies that `(A-1) % p` should equal `(B-1) % p`.\n\n2. **Simplifying the Condition**: The condition can be rewritten as `(A-1) % p == (B-1) % p`, which implies `(A-1) - (B-1) = k * p` for some integer `k`. This simplifies to `(A-B) % p == 0`.\n\n3. **Finding Valid `p` Values**: The number of valid `p` values is the number of divisors of `|A-B|`. If `A == B`, then `|A-B| = 0`, and any positive integer `p` will satisfy the condition, leading to infinitely many solutions.\n\n4. **Algorithm**:\n   - For each test case, calculate `|A-B|`.\n   - If `A == B`, output `-1` (infinite solutions).\n   - Otherwise, count the divisors of `|A-B|`.\n\n### Pseudocode\n\n```\nfunction countDivisors(n):\n    count = 0\n    for i from 1 to sqrt(n):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n\nfunction solve(T, test_cases):\n    for each (A, B) in test_cases:\n        diff = abs(A - B)\n        if diff == 0:\n            print(-1)\n        else:\n            print(countDivisors(diff))\n```\n\n### Python Code\n\n```python\ndef countDivisors(n):\n    count = 0\n    i = 1\n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n        i += 1\n    return count\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    T = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(T):\n        A = int(data[index])\n        B = int(data[index + 1])\n        index += 2\n        \n        diff = abs(A - B)\n        if diff == 0:\n            results.append(-1)\n        else:\n            results.append(countDivisors(diff))\n    \n    for result in results:\n        print(result)\n\n```\n\nThis code reads the number of test cases and for each test case, calculates the absolute difference between the roll numbers. It then determines the number of divisors of this difference, which corresponds to the number of valid `p` values. If the difference is zero, it outputs `-1` to indicate infinite solutions.",
    "no_parent": false,
    "dependency_used": false
}