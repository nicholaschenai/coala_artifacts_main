{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\n Input: ['10 3', '1', '3', '7', '6', '-1', '5', '-1', '18', '9', '11', '2', '-1', '4'] Output: 7\n6\n18\n\nTests failed:\nNone",
    "code": "\nimport sys\nimport heapq\n\ndef process_wealth_and_visits(N, M, events):\n    # Max-heap to store the wealth of citizens\n    max_heap = []\n    results = []\n\n    for event in events:\n        if event > 0:\n            # Push negative of wealth to simulate max-heap using min-heap\n            heapq.heappush(max_heap, -event)\n        elif event == -1:\n            # Pop the richest (max) wealth, which is the smallest negative number\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    events = list(map(int, data[2:]))\n    \n    results = process_wealth_and_visits(N, M, events)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "full_code": "\nimport sys\nimport heapq\n\ndef process_wealth_and_visits(N, M, events):\n    # Max-heap to store the wealth of citizens\n    max_heap = []\n    results = []\n\n    for event in events:\n        if event > 0:\n            # Push negative of wealth to simulate max-heap using min-heap\n            heapq.heappush(max_heap, -event)\n        elif event == -1:\n            # Pop the richest (max) wealth, which is the smallest negative number\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    events = list(map(int, data[2:]))\n    \n    results = process_wealth_and_visits(N, M, events)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "reward": true,
    "program_code": "\nimport sys\nimport heapq\n\ndef process_wealth_and_visits(N, M, events):\n    # Max-heap to store the wealth of citizens\n    max_heap = []\n    results = []\n\n    for event in events:\n        if event > 0:\n            # Push negative of wealth to simulate max-heap using min-heap\n            heapq.heappush(max_heap, -event)\n        elif event == -1:\n            # Pop the richest (max) wealth, which is the smallest negative number\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    events = list(map(int, data[2:]))\n    \n    results = process_wealth_and_visits(N, M, events)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n",
    "program_name": "main",
    "dependencies": [],
    "raw_msg": "### Problem Restatement\n\nWe have a sequence of citizens entering a court, each declaring their wealth. Occasionally, the king visits the court, and during each visit, the richest citizen who has appeared so far and is still alive is executed. We need to determine the wealth of the citizen executed during each of the king's visits.\n\n### Conceptual Solution\n\n1. **Data Structure Choice**: Use a max-heap to efficiently track the richest citizen who is still alive. A max-heap allows us to quickly retrieve and remove the maximum element, which is ideal for this problem.\n\n2. **Processing the Input**: As we process each line of input:\n   - If it's a positive integer, it represents a citizen's wealth. Add this wealth to the max-heap.\n   - If it's `-1`, it represents a king's visit. Remove the richest citizen from the heap and record their wealth as the executed citizen.\n\n3. **Handling Execution**: Since the problem guarantees that there will always be someone to execute when the king visits, we don't need to handle cases where the heap is empty.\n\n### Pseudocode\n\n```\nfunction process_wealth_and_visits(N, M, events):\n    initialize a max-heap\n    initialize an empty list for results\n\n    for each event in events:\n        if event is a positive integer:\n            add event to the max-heap\n        else if event is -1:\n            extract the maximum from the max-heap\n            append the extracted value to results\n\n    return results\n```\n\n### Python Code\n\n```python\nimport sys\nimport heapq\n\ndef process_wealth_and_visits(N, M, events):\n    # Max-heap to store the wealth of citizens\n    max_heap = []\n    results = []\n\n    for event in events:\n        if event > 0:\n            # Push negative of wealth to simulate max-heap using min-heap\n            heapq.heappush(max_heap, -event)\n        elif event == -1:\n            # Pop the richest (max) wealth, which is the smallest negative number\n            richest = -heapq.heappop(max_heap)\n            results.append(richest)\n\n    return results\n\ndef main():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    events = list(map(int, data[2:]))\n    \n    results = process_wealth_and_visits(N, M, events)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation of the Code\n\n- **Heap Usage**: We use a min-heap to simulate a max-heap by storing negative values. This allows us to efficiently retrieve the maximum wealth.\n- **Input Handling**: The input is read from standard input, and the events are processed in sequence.\n- **Output**: The results are printed line by line, corresponding to each king's visit.",
    "no_parent": false,
    "dependency_used": false
}