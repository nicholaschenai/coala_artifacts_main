{
    "env_feedback": "Note: Inputs/outputs here are automatically extracted/truncated so formatting may be a bit off.\nTests passed:\n\nNone\n\nTests failed:\n Input: ['3', '4 12', '2 2', '5 14'] Expected output: [{'-1'}, {'1', '2'}, {'5', '1', '3', '4', '2'}] # Execution output: []\nNo output detected. You might want to check the reading from / writing to standard IO.\nA common mistake is to put the IO inside a function, but the function is not called.\n",
    "code": "\ndef find_permutation(T, test_cases):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        if K < N - 1 or K > (N * (N + 1) // 2) - 1:\n            results.append(\"-1\")\n        else:\n            permutation = list(range(N, 0, -1))\n            current_sum = (N * (N + 1) // 2) - 1\n            i = 0\n            while current_sum > K:\n                if permutation[i] > permutation[i + 1]:\n                    permutation[i], permutation[i + 1] = permutation[i + 1], permutation[i]\n                    current_sum -= 1\n                i += 1\n            results.append(\" \".join(map(str, permutation)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n",
    "full_code": "\ndef find_permutation(T, test_cases):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        if K < N - 1 or K > (N * (N + 1) // 2) - 1:\n            results.append(\"-1\")\n        else:\n            permutation = list(range(N, 0, -1))\n            current_sum = (N * (N + 1) // 2) - 1\n            i = 0\n            while current_sum > K:\n                if permutation[i] > permutation[i + 1]:\n                    permutation[i], permutation[i + 1] = permutation[i + 1], permutation[i]\n                    current_sum -= 1\n                i += 1\n            results.append(\" \".join(map(str, permutation)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n",
    "reward": false,
    "program_code": "\ndef find_permutation(T, test_cases):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        if K < N - 1 or K > (N * (N + 1) // 2) - 1:\n            results.append(\"-1\")\n        else:\n            permutation = list(range(N, 0, -1))\n            current_sum = (N * (N + 1) // 2) - 1\n            i = 0\n            while current_sum > K:\n                if permutation[i] > permutation[i + 1]:\n                    permutation[i], permutation[i + 1] = permutation[i + 1], permutation[i]\n                    current_sum -= 1\n                i += 1\n            results.append(\" \".join(map(str, permutation)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n",
    "program_name": "find_permutation",
    "dependencies": [],
    "raw_msg": "To solve the problem, let's break it down step by step:\n\n### Problem Restatement\nWe are given a permutation of numbers from 1 to N and need to find a permutation such that the sum of the maximum of each consecutive pair equals a given integer K. If such a permutation exists, we should output it; otherwise, we should output -1.\n\n### Conceptual Solution\n1. **Understanding f(P)**: The function f(P) is defined as the sum of the maximum of each consecutive pair in the permutation. For a permutation of size N, this is calculated as:\n   \\[\n   f(P) = \\max(p_1, p_2) + \\max(p_2, p_3) + \\ldots + \\max(p_{N-1}, p_N)\n   \\]\n\n2. **Constraints and Observations**:\n   - The minimum value of f(P) is N-1, which occurs when the permutation is sorted in increasing order.\n   - The maximum value of f(P) is the sum of the largest N-1 numbers, which is \\(\\frac{N \\times (N + 1)}{2} - 1\\).\n\n3. **Approach**:\n   - If K is less than N-1 or greater than the maximum possible sum, output -1.\n   - Otherwise, construct a permutation that achieves the desired sum K.\n\n4. **Constructing the Permutation**:\n   - Start with the permutation in decreasing order, which gives the maximum possible sum.\n   - Adjust the permutation by swapping elements to decrease the sum to K.\n\n### Pseudocode\n```\nfunction find_permutation(T, test_cases):\n    for each (N, K) in test_cases:\n        if K < N-1 or K > (N * (N + 1) / 2) - 1:\n            output -1\n        else:\n            permutation = [N, N-1, ..., 1]\n            current_sum = (N * (N + 1) / 2) - 1\n            i = 0\n            while current_sum > K:\n                if permutation[i] > permutation[i+1]:\n                    swap permutation[i] and permutation[i+1]\n                    current_sum -= 1\n                i += 1\n            output permutation\n```\n\n### Final Python Code\n```python\ndef find_permutation(T, test_cases):\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    T = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(T):\n        N = int(data[index])\n        K = int(data[index + 1])\n        index += 2\n        \n        if K < N - 1 or K > (N * (N + 1) // 2) - 1:\n            results.append(\"-1\")\n        else:\n            permutation = list(range(N, 0, -1))\n            current_sum = (N * (N + 1) // 2) - 1\n            i = 0\n            while current_sum > K:\n                if permutation[i] > permutation[i + 1]:\n                    permutation[i], permutation[i + 1] = permutation[i + 1], permutation[i]\n                    current_sum -= 1\n                i += 1\n            results.append(\" \".join(map(str, permutation)))\n    \n    sys.stdout.write(\"\\n\".join(results) + \"\\n\")\n\n```\n\n### Explanation\n- We start with the permutation in descending order, which gives the maximum possible sum.\n- We then iteratively swap adjacent elements to reduce the sum until it matches K.\n- This approach ensures that we efficiently find a permutation that satisfies the condition or determine that it's impossible.",
    "no_parent": false,
    "dependency_used": false
}