{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert find_adverb_position(\"clearly!! we can see the sky\")==(0, 7, 'clearly')\n\nTests failed:\nNone",
    "code": "\ndef find_adverb_position(sentence: str) -> tuple:\n    # Initialize the current index to track position in the sentence\n    current_index = 0\n    length = len(sentence)\n    \n    # Iterate over the sentence manually to handle punctuation\n    while current_index < length:\n        # Find the start of the next word\n        while current_index < length and not sentence[current_index].isalpha():\n            current_index += 1\n        \n        # If we reach the end of the sentence, break\n        if current_index >= length:\n            break\n        \n        # Find the end of the current word\n        start_index = current_index\n        while current_index < length and (sentence[current_index].isalpha() or sentence[current_index] in \"-'\"):\n            current_index += 1\n        \n        # Extract the word and strip punctuation from the end\n        word = sentence[start_index:current_index].rstrip('!.,?')\n        \n        # Check if the word ends with 'ly'\n        if word.endswith('ly'):\n            # Return the tuple with start index, end index, and the adverb\n            return (start_index, current_index, word)\n        \n        # Move past any trailing punctuation or spaces\n        while current_index < length and not sentence[current_index].isalpha():\n            current_index += 1\n    \n    # If no adverb is found, return None\n    return None\n",
    "full_code": "\ndef find_adverb_position(sentence: str) -> tuple:\n    # Initialize the current index to track position in the sentence\n    current_index = 0\n    length = len(sentence)\n    \n    # Iterate over the sentence manually to handle punctuation\n    while current_index < length:\n        # Find the start of the next word\n        while current_index < length and not sentence[current_index].isalpha():\n            current_index += 1\n        \n        # If we reach the end of the sentence, break\n        if current_index >= length:\n            break\n        \n        # Find the end of the current word\n        start_index = current_index\n        while current_index < length and (sentence[current_index].isalpha() or sentence[current_index] in \"-'\"):\n            current_index += 1\n        \n        # Extract the word and strip punctuation from the end\n        word = sentence[start_index:current_index].rstrip('!.,?')\n        \n        # Check if the word ends with 'ly'\n        if word.endswith('ly'):\n            # Return the tuple with start index, end index, and the adverb\n            return (start_index, current_index, word)\n        \n        # Move past any trailing punctuation or spaces\n        while current_index < length and not sentence[current_index].isalpha():\n            current_index += 1\n    \n    # If no adverb is found, return None\n    return None\n",
    "reward": true,
    "program_code": "\ndef find_adverb_position(sentence: str) -> tuple:\n    # Initialize the current index to track position in the sentence\n    current_index = 0\n    length = len(sentence)\n    \n    # Iterate over the sentence manually to handle punctuation\n    while current_index < length:\n        # Find the start of the next word\n        while current_index < length and not sentence[current_index].isalpha():\n            current_index += 1\n        \n        # If we reach the end of the sentence, break\n        if current_index >= length:\n            break\n        \n        # Find the end of the current word\n        start_index = current_index\n        while current_index < length and (sentence[current_index].isalpha() or sentence[current_index] in \"-'\"):\n            current_index += 1\n        \n        # Extract the word and strip punctuation from the end\n        word = sentence[start_index:current_index].rstrip('!.,?')\n        \n        # Check if the word ends with 'ly'\n        if word.endswith('ly'):\n            # Return the tuple with start index, end index, and the adverb\n            return (start_index, current_index, word)\n        \n        # Move past any trailing punctuation or spaces\n        while current_index < length and not sentence[current_index].isalpha():\n            current_index += 1\n    \n    # If no adverb is found, return None\n    return None\n",
    "program_name": "find_adverb_position",
    "dependencies": [],
    "raw_msg": "```python\ndef find_adverb_position(sentence: str) -> tuple:\n    # Initialize the current index to track position in the sentence\n    current_index = 0\n    length = len(sentence)\n    \n    # Iterate over the sentence manually to handle punctuation\n    while current_index < length:\n        # Find the start of the next word\n        while current_index < length and not sentence[current_index].isalpha():\n            current_index += 1\n        \n        # If we reach the end of the sentence, break\n        if current_index >= length:\n            break\n        \n        # Find the end of the current word\n        start_index = current_index\n        while current_index < length and (sentence[current_index].isalpha() or sentence[current_index] in \"-'\"):\n            current_index += 1\n        \n        # Extract the word and strip punctuation from the end\n        word = sentence[start_index:current_index].rstrip('!.,?')\n        \n        # Check if the word ends with 'ly'\n        if word.endswith('ly'):\n            # Return the tuple with start index, end index, and the adverb\n            return (start_index, current_index, word)\n        \n        # Move past any trailing punctuation or spaces\n        while current_index < length and not sentence[current_index].isalpha():\n            current_index += 1\n    \n    # If no adverb is found, return None\n    return None\n```",
    "no_parent": true,
    "dependency_used": false
}