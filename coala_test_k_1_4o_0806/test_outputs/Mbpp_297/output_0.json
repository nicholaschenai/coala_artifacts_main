{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n\nTests failed:\nNone",
    "code": "\ndef flatten_list(nested_list):\n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n    \n    # Iterate over each element in the input list\n    for element in nested_list:\n        # If the element is a list, recursively flatten it and extend the flat_list\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        # If the element is not a list, append it directly to the flat_list\n        else:\n            flat_list.append(element)\n    \n    # Return the fully flattened list\n    return flat_list\n",
    "full_code": "\ndef flatten_list(nested_list):\n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n    \n    # Iterate over each element in the input list\n    for element in nested_list:\n        # If the element is a list, recursively flatten it and extend the flat_list\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        # If the element is not a list, append it directly to the flat_list\n        else:\n            flat_list.append(element)\n    \n    # Return the fully flattened list\n    return flat_list\n",
    "reward": true,
    "program_code": "\ndef flatten_list(nested_list):\n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n    \n    # Iterate over each element in the input list\n    for element in nested_list:\n        # If the element is a list, recursively flatten it and extend the flat_list\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        # If the element is not a list, append it directly to the flat_list\n        else:\n            flat_list.append(element)\n    \n    # Return the fully flattened list\n    return flat_list\n",
    "program_name": "flatten_list",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe need to write a function that takes a nested list and returns a flattened version of it. The function should handle lists that contain other lists, and it should return a single list with all the elements in a single, flat structure.\n\n## Conceptual Solution\n\n1. **Iterate Over the List**: Go through each element in the list.\n2. **Check for Nested Lists**: If an element is a list, recursively flatten it.\n3. **Collect Elements**: If an element is not a list, add it directly to the result.\n4. **Combine Results**: For nested lists, combine the results of the recursive calls into a single list.\n\n## Pseudocode\n\n```\nfunction flatten_list(nested_list):\n    initialize an empty list called flat_list\n    for each element in nested_list:\n        if element is a list:\n            extend flat_list with the result of flatten_list(element)\n        else:\n            append element to flat_list\n    return flat_list\n```\n\n## Final Python Solution\n\n```python\ndef flatten_list(nested_list):\n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n    \n    # Iterate over each element in the input list\n    for element in nested_list:\n        # If the element is a list, recursively flatten it and extend the flat_list\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        # If the element is not a list, append it directly to the flat_list\n        else:\n            flat_list.append(element)\n    \n    # Return the fully flattened list\n    return flat_list\n```\n\nThis solution uses recursion to handle nested lists, ensuring that all elements are added to a single flat list. The `isinstance` function checks if an element is a list, and the `extend` method is used to add elements from a nested list to the `flat_list`.",
    "no_parent": true,
    "dependency_used": false
}