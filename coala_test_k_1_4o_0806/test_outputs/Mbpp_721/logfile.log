INFO - [test iter]: 281/378

INFO - The task prompt is Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Given a square matrix of size N*N given as a list of lists, where e...

INFO - Attempting task_id Mbpp/721
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] Mbpp/721 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.
assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2
"""

[END PROBLEM]

INFO - [Task id] Mbpp/721 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] Mbpp/721 [generation text] ## Problem Restatement

We are given a square matrix where each cell has a specific cost. We need to find a path from the top-left corner to the bottom-right corner of the matrix. The path can only move right or down. Our goal is to find the path that has the maximum average cost, where the average is calculated as the total cost of the path divided by the number of cells in the path.

## Conceptual Solution

1. **Dynamic Programming Approach**: We can use dynamic programming to solve this problem efficiently. We'll maintain a 2D list `dp` where `dp[i][j]` will store the maximum total cost of reaching cell `(i, j)` from the top-left corner `(0, 0)`.

2. **Initialization**: 
   - Start by initializing `dp[0][0]` with the cost of the top-left cell, as this is the starting point.

3. **Filling the DP Table**:
   - For each cell `(i, j)`, calculate the maximum cost to reach that cell by considering the maximum cost of reaching the cell from the top `(i-1, j)` or from the left `(i, j-1)`.
   - The formula will be: `dp[i][j] = cost[i][j] + max(dp[i-1][j], dp[i][j-1])`.

4. **Calculate the Average**:
   - The number of cells in any path from `(0, 0)` to `(N-1, N-1)` is `2N - 1`.
   - The maximum average cost will be `dp[N-1][N-1] / (2N - 1)`.

5. **Return the Result**: Return the calculated maximum average.

## Pseudocode

```
function maxAverageOfPath(cost):
    N = length of cost
    create a 2D list dp of size N x N
    dp[0][0] = cost[0][0]
    
    for i from 1 to N-1:
        dp[i][0] = dp[i-1][0] + cost[i][0]
        dp[0][i] = dp[0][i-1] + cost[0][i]
    
    for i from 1 to N-1:
        for j from 1 to N-1:
            dp[i][j] = cost[i][j] + max(dp[i-1][j], dp[i][j-1])
    
    max_total_cost = dp[N-1][N-1]
    max_average = max_total_cost / (2 * N - 1)
    
    return max_average
```

## Final Python Solution

```python
def maxAverageOfPath(cost):
    N = len(cost)
    dp = [[0] * N for _ in range(N)]
    
    # Initialize the starting point
    dp[0][0] = cost[0][0]
    
    # Fill the first row and first column
    for i in range(1, N):
        dp[i][0] = dp[i-1][0] + cost[i][0]
        dp[0][i] = dp[0][i-1] + cost[0][i]
    
    # Fill the rest of the dp table
    for i in range(1, N):
        for j in range(1, N):
            dp[i][j] = cost[i][j] + max(dp[i-1][j], dp[i][j-1])
    
    # Calculate the maximum average
    max_total_cost = dp[N-1][N-1]
    max_average = max_total_cost / (2 * N - 1)
    
    return max_average
```
INFO - [35m Rollout attempt 1/4[0m
INFO - [33m Retrieving 1 entries for db: episodic 
 [0m
INFO - Retrieved (score=0.4559):

[Task]:
    Say you have an array for which the ith element is the price of a given stock on day i.

    Design an algorithm to find the maximum profit. You may complete at most two transactions.

    Note:Â You may not engage in multiple transactions at the same time (i.e., you must sell the sto...


INFO - [33m Retrieving 1 entries for db: semantic 
 [0m
INFO - Retrieved (score=0.3679):
Chapter: Dynamic programming
Section: Paths in a grid
Part: 1/1
\section{Paths in a grid}

Our next problem is to find a path
from the upper-left corner to
the lower-right corner
of an $n \times n$ grid, such that
we only move down and right.
Each square contains a positive integer,
and the path ...


INFO - [33m Retrieving 1 entries for db: reflections 
 [0m
INFO - Retrieved (score=0.4178):
### Reflection on the Problem and Solution

#### Key Insights from the Official Solution

1. **Dynamic Programming Approach**: The official solution uses a dynamic programming (DP) approach to solve the problem. This is insightful because it efficiently calculates the maximum alternating sum by m...


INFO - [33m Retrieving 1 entries for db: summaries 
 [0m
INFO - Retrieved (score=0.3977):
In tackling the problem of maximizing the sum of pizza slices you can pick from a circular array, the core concept was to use dynamic programming to handle the constraints of the problem, particularly the circular nature of the array and the requirement to skip slices picked by Alice and Bob.

##...


INFO - [33m Retrieving 1 entries for db: skill 
 [0m
INFO - Retrieved (score=0.6964):

[description for function: count_col_triang]
The function takes a list of tuples, where each tuple contains a point and its associated color, and calculates the total number of points, the number of distinct colors, and the total number of non-collinear triangles that can be formed within each c...


INFO - [33m Retrieving 1 entries for db: non_func 
 [0m
INFO - Retrieved (score=0.4364):

[description]
The function calculates the maximum sum of non-adjacent slices that can be selected from a circular array of pizza slices, where you can choose exactly one-third of the slices. It uses dynamic programming to solve the problem by considering two scenarios: one excluding the first sl...


INFO - Retrieved (score=0.3679): 
[Textbook Reference Material]:
    Chapter: Dynamic programming
    Section: Paths in a grid
    Part: 1/1
    \section{Paths in a grid}

    Our next problem is to find a path
    from the upper-left corner to
    the lower-right corner
    of an $n \times n$ grid, such that
    we only move do...
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] Mbpp/721 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.
assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2
"""

[END PROBLEM]

INFO - [Task id] Mbpp/721 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] Mbpp/721 [prompt] 
Also, here are some of your memories.
Feel free to use the given information to aid your problem solving process if necessary.
Do not confuse the memories with the problem statement.

## Memories

[Textbook Reference Material]:
    Chapter: Dynamic programming
    Section: Paths in a grid
    Part: 1/1
    \section{Paths in a grid}

    Our next problem is to find a path
    from the upper-left corner to
    the lower-right corner
    of an $n \times n$ grid, such that
    we only move down and right.
    Each square contains a positive integer,
    and the path should be constructed so
    that the sum of the values along
    the path is as large as possible.

    The following picture shows an optimal
    path in a grid:
    \begin{center}
    \begin{tikzpicture}[scale=.65]
      \begin{scope}
        \fill [color=lightgray] (0, 9) rectangle (1, 8);
        \fill [color=lightgray] (0, 8) rectangle (1, 7);
        \fill [color=lightgray] (1, 8) rectangle (2, 7);
        \fill [color=lightgray] (1, 7) rectangle (2, 6);
        \fill [color=lightgray] (2, 7) rectangle (3, 6);
        \fill [color=lightgray] (3, 7) rectangle (4, 6);
        \fill [color=lightgray] (4, 7) rectangle (5, 6);
        \fill [color=lightgray] (4, 6) rectangle (5, 5);
        \fill [color=lightgray] (4, 5) rectangle (5, 4);
        \draw (0, 4) grid (5, 9);
        \node at (0.5,8.5) {3};
        \node at (1.5,8.5) {7};
        \node at (2.5,8.5) {9};
        \node at (3.5,8.5) {2};
        \node at (4.5,8.5) {7};
        \node at (0.5,7.5) {9};
        \node at (1.5,7.5) {8};
        \node at (2.5,7.5) {3};
        \node at (3.5,7.5) {5};
        \node at (4.5,7.5) {5};
        \node at (0.5,6.5) {1};
        \node at (1.5,6.5) {7};
        \node at (2.5,6.5) {9};
        \node at (3.5,6.5) {8};
        \node at (4.5,6.5) {5};
        \node at (0.5,5.5) {3};
        \node at (1.5,5.5) {8};
        \node at (2.5,5.5) {6};
        \node at (3.5,5.5) {4};
        \node at (4.5,5.5) {10};
        \node at (0.5,4.5) {6};
        \node at (1.5,4.5) {3};
        \node at (2.5,4.5) {9};
        \node at (3.5,4.5) {7};
        \node at (4.5,4.5) {8};
      \end{scope}
    \end{tikzpicture}
    \end{center}
    The sum of the values on the path is 67,
    and this is the largest possible sum on a path
    from the
    upper-left corner to the lower-right corner.

    Assume that the rows and columns of the
    grid are numbered from 1 to $n$,
    and $\texttt{value}[y][x]$ equals the value
    of square $(y,x)$.
    Let $\texttt{sum}(y,x)$ denote the maximum
    sum on a path from the upper-left corner
    to square $(y,x)$.
    Now $\texttt{sum}(n,n)$ tells us
    the maximum sum
    from the upper-left corner to
    the lower-right corner.
    For example, in the above grid,
    $\texttt{sum}(5,5)=67$.

    We can recursively calculate the sums
    as follows:
    \[ \texttt{sum}(y,x) = \max(\texttt{sum}(y,x-1),\texttt{sum}(y-1,x))+\texttt{value}[y][x]\]


    The recursive formula is based on the observation
    that a path that ends at square $(y,x)$
    can come either from square $(y,x-1)$
    or square $(y-1,x)$:
    \begin{center}
    \begin{tikzpicture}[scale=.65]
      \begin{scope}
        \fill [color=lightgray] (3, 7) rectangle (4, 6);
        \draw (0, 4) grid (5, 9);
    
        \node at (2.5,6.5) {$\rightarrow$};
        \node at (3.5,7.5) {$\downarrow$};
    
      \end{scope}
    \end{tikzpicture}
    \end{center}

    Thus, we select the direction that maximizes
    the sum.
    We assume that $\texttt{sum}(y,x)=0$
    if $y=0$ or $x=0$ (because no such paths exist),
    so the recursive formula also works when $y=1$ or $x=1$.

    Since the function \texttt{sum} has two parameters,
    the dynamic programming array also has two dimensions.
    For example, we can use an array
    \begin{lstlisting}
    int sum[N][N];
    \end{lstlisting}
    and calculate the sums as follows:
    \begin{lstlisting}
    for (int y = 1; y <= n; y++) {
        for (int x = 1; x <= n; x++) {
            sum[y][x] = max(sum[y][x-1],sum[y-1][x])+value[y][x];
        }
    }
    \end{lstlisting}
    The time complexity of the algorithm is $O(n^2)$.
[/Textbook Reference Material]


INFO - [Task id] Mbpp/721 [generation text] 1. **Restate the problem in plain English:**

   We are given a square matrix where each cell has a cost. We need to find a path from the top-left corner to the bottom-right corner of the matrix, moving only right or down. The goal is to find the path that has the maximum average cost, where the average is calculated as the total cost of the path divided by the number of cells in the path.

2. **Conceptualize a solution in plain English:**

   To solve this problem, we can use dynamic programming. We will create a 2D array `dp` where `dp[i][j]` will store the maximum sum of costs from the top-left corner to the cell `(i, j)`. We will also keep track of the number of cells in the path to `(i, j)` in another 2D array `count`. The average for each cell `(i, j)` can be calculated as `dp[i][j] / count[i][j]`. We will iterate through the matrix, updating `dp` and `count` based on the maximum sum path to each cell. Finally, the maximum average path will be found at the bottom-right corner of the matrix.

3. **Write a pseudocode solution:**

   ```
   Initialize dp and count arrays with dimensions N x N
   Set dp[0][0] = matrix[0][0]
   Set count[0][0] = 1

   For each cell (i, j) in the matrix:
       If moving from the left (i, j-1) is possible:
           Calculate potential new sum and count
           Update dp[i][j] and count[i][j] if this path is better
       If moving from above (i-1, j) is possible:
           Calculate potential new sum and count
           Update dp[i][j] and count[i][j] if this path is better

   Calculate the maximum average at the bottom-right corner as dp[N-1][N-1] / count[N-1][N-1]
   Return the maximum average
   ```

4. **Output the final Python 3 solution with your solution steps in comments:**

```python
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average
```
INFO - program_code:
 
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average


INFO - program_name:
 maxAverageOfPath

INFO - dependencies:
 []

INFO - raw_msg:
 1. **Restate the problem in plain English:**

   We are given a square matrix where each cell has a cost. We need to find a path from the top-left corner to the bottom-right corner of the matrix, moving only right or down. The goal is to find the path that has the maximum average cost, where the average is calculated as the total cost of the path divided by the number of cells in the path.

2. **Conceptualize a solution in plain English:**

   To solve this problem, we can use dynamic programming. We will create a 2D array `dp` where `dp[i][j]` will store the maximum sum of costs from the top-left corner to the cell `(i, j)`. We will also keep track of the number of cells in the path to `(i, j)` in another 2D array `count`. The average for each cell `(i, j)` can be calculated as `dp[i][j] / count[i][j]`. We will iterate through the matrix, updating `dp` and `count` based on the maximum sum path to each cell. Finally, the maximum average path will be found at the bottom-right corner of the matrix.

3. **Write a pseudocode solution:**

   ```
   Initialize dp and count arrays with dimensions N x N
   Set dp[0][0] = matrix[0][0]
   Set count[0][0] = 1

   For each cell (i, j) in the matrix:
       If moving from the left (i, j-1) is possible:
           Calculate potential new sum and count
           Update dp[i][j] and count[i][j] if this path is better
       If moving from above (i-1, j) is possible:
           Calculate potential new sum and count
           Update dp[i][j] and count[i][j] if this path is better

   Calculate the maximum average at the bottom-right corner as dp[N-1][N-1] / count[N-1][N-1]
   Return the maximum average
   ```

4. **Output the final Python 3 solution with your solution steps in comments:**

```python
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average
```

INFO - no_parent:
 True

INFO - full code to be executed: 
 
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average


INFO - obs: Note: Tests are automatically generated and can be wrong.

Tests passed:
None

Tests failed:
assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2 # output: division by zero
reward: False
done: None
info: {'individual_results': (False,)}
INFO - [35m Rollout attempt 2/4[0m
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] Mbpp/721 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.
assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2
"""

[END PROBLEM]

INFO - [Task id] Mbpp/721 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] Mbpp/721 [prompt] 1. **Restate the problem in plain English:**

   We are given a square matrix where each cell has a cost. We need to find a path from the top-left corner to the bottom-right corner of the matrix, moving only right or down. The goal is to find the path that has the maximum average cost, where the average is calculated as the total cost of the path divided by the number of cells in the path.

2. **Conceptualize a solution in plain English:**

   To solve this problem, we can use dynamic programming. We will create a 2D array `dp` where `dp[i][j]` will store the maximum sum of costs from the top-left corner to the cell `(i, j)`. We will also keep track of the number of cells in the path to `(i, j)` in another 2D array `count`. The average for each cell `(i, j)` can be calculated as `dp[i][j] / count[i][j]`. We will iterate through the matrix, updating `dp` and `count` based on the maximum sum path to each cell. Finally, the maximum average path will be found at the bottom-right corner of the matrix.

3. **Write a pseudocode solution:**

   ```
   Initialize dp and count arrays with dimensions N x N
   Set dp[0][0] = matrix[0][0]
   Set count[0][0] = 1

   For each cell (i, j) in the matrix:
       If moving from the left (i, j-1) is possible:
           Calculate potential new sum and count
           Update dp[i][j] and count[i][j] if this path is better
       If moving from above (i-1, j) is possible:
           Calculate potential new sum and count
           Update dp[i][j] and count[i][j] if this path is better

   Calculate the maximum average at the bottom-right corner as dp[N-1][N-1] / count[N-1][N-1]
   Return the maximum average
   ```

4. **Output the final Python 3 solution with your solution steps in comments:**

```python
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average
```
INFO - [Task id] Mbpp/721 [prompt] 
[Environment Feedback]:
    Note: Tests are automatically generated and can be wrong.

    Tests passed:
    None

    Tests failed:
    assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2 # output: division by zero
[/Environment Feedback]

INFO - [Task id] Mbpp/721 [prompt] 
The code doesn't pass all the tests.

## Instructions
- First, think step-by-step about why your code is wrong.
- Then, think step-by-step about where you went wrong in your latest solution.

INFO - [Task id] Mbpp/721 [generation text] Let's analyze the code and the error message to understand what went wrong:

1. **Error Analysis:**
   - The error message indicates a "division by zero" error. This suggests that at some point, the `count` array has a zero value, which is unexpected because every path should have at least one cell (the starting cell).

2. **Step-by-Step Analysis of the Code:**
   - **Initialization:** The `dp` and `count` arrays are initialized correctly, and the starting point `(0, 0)` is set with the correct initial values.
   - **Filling the Arrays:** The logic for updating `dp[i][j]` and `count[i][j]` is based on comparing potential new paths from the left `(i, j-1)` and from above `(i-1, j)`.
   - **Potential Issue:** The condition `if new_sum * count[i][j] > dp[i][j] * new_count` is used to decide whether to update `dp[i][j]` and `count[i][j]`. However, if `count[i][j]` is initially zero (which it is for all cells except the starting cell), this condition will not work correctly because multiplying by zero will always result in zero, leading to incorrect comparisons.

3. **Where the Solution Went Wrong:**
   - The logic for updating `dp[i][j]` and `count[i][j]` does not handle the initial zero values in `count` correctly. This results in `count[i][j]` remaining zero for some cells, leading to a division by zero error when calculating the average.

4. **Solution:**
   - We need to ensure that `count[i][j]` is initialized properly for each cell that is reachable, and the comparison logic should be adjusted to handle the initial zero values correctly.

Let's correct the code with these insights in mind:

```python
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average
```

**Explanation of Changes:**
- The condition `if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count` ensures that we update `dp[i][j]` and `count[i][j]` if `count[i][j]` is initially zero, which means the cell hasn't been reached yet. This prevents division by zero errors.
INFO - [33m Retrieving 1 entries for db: episodic 
 [0m
INFO - Retrieved (score=0.4741):

[Task]:
    Dr. S. De teaches computer architecture in NIT Patna. Whenever he comes across any good question(with complexity $k$), he gives that question to students within roll number range $i$ and $j$
    At the start of semester he assigns score of $10$ to every student in his class if a stud...


INFO - [33m Retrieving 1 entries for db: semantic 
 [0m
INFO - Retrieved (score=0.4405):
Chapter: Dynamic programming
Section: Paths in a grid
Part: 1/1
\section{Paths in a grid}

Our next problem is to find a path
from the upper-left corner to
the lower-right corner
of an $n \times n$ grid, such that
we only move down and right.
Each square contains a positive integer,
and the path ...


INFO - [33m Retrieving 1 entries for db: reflections 
 [0m
INFO - Retrieved (score=0.4635):
Reflecting on the problem-solving process and comparing it with the official solution, here are some key insights:

1. **Dynamic Programming Approach**: The official solution uses a dynamic programming approach, which is both efficient and elegant. It maintains an array `reach` where `reach[j]` r...


INFO - [33m Retrieving 1 entries for db: summaries 
 [0m
INFO - Retrieved (score=0.4700):
In tackling the problem of maximizing the sum of pizza slices you can pick from a circular array, the core concept was to use dynamic programming to handle the constraints of the problem, particularly the circular nature of the array and the requirement to skip slices picked by Alice and Bob.

##...


INFO - [33m Retrieving 1 entries for db: skill 
 [0m
INFO - Retrieved (score=0.6622):

[description for function: count_col_triang]
The function takes a list of tuples, where each tuple contains a point and its associated color, and calculates the total number of points, the number of distinct colors, and the total number of non-collinear triangles that can be formed within each c...


INFO - [33m Retrieving 1 entries for db: non_func 
 [0m
INFO - Retrieved (score=0.4963):

[description]
The function calculates the maximum sum of non-adjacent slices that can be selected from a circular array of pizza slices, where you can choose exactly one-third of the slices. It uses dynamic programming to solve the problem by considering two scenarios: one excluding the first sl...


INFO - Retrieved (score=0.4405): 
[Textbook Reference Material]:
    Chapter: Dynamic programming
    Section: Paths in a grid
    Part: 1/1
    \section{Paths in a grid}

    Our next problem is to find a path
    from the upper-left corner to
    the lower-right corner
    of an $n \times n$ grid, such that
    we only move do...
INFO - LM call n parse attempt 1 / 3

INFO - [Task id] Mbpp/721 [prompt] 
You are an expert programmer tasked with solving the problem below.

Follow the user's instructions to solve the problem.
The user can ask for analysis, code, or both.

## Instructions
When asked to output code,
- Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
- include exactly one block of code with the entire solution
- No outside libraries are allowed. 
- Builtins are allowed.
- If the task specifies a function name to be used, follow it strictly (be case sensitive!) and declare the that function last (helper functions are declared first).
- DO NOT write any assert statements / tests.

## Problem
[BEGIN PROBLEM]
Write a Python function that satisfies the description below. Your code must strictly follow the function name and typings of the input and output specified in the assert statement below, and pass the assertion when executed.
"""
Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.
assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2
"""

[END PROBLEM]

INFO - [Task id] Mbpp/721 [prompt] 
## Instructions

Reason through the problem and:
1. Restate the problem in plain English
2. Conceptualize a solution first in plain English
3. Write a pseudocode solution
4. Output the final Python 3 solution with your solution steps in comments.

Make sure to wrap your code in '```python' and '```' Markdown delimiters, 
and include exactly one block of code with the entire solution.

No outside libraries are allowed.
Builtins are allowed.

INFO - [Task id] Mbpp/721 [prompt] 1. **Restate the problem in plain English:**

   We are given a square matrix where each cell has a cost. We need to find a path from the top-left corner to the bottom-right corner of the matrix, moving only right or down. The goal is to find the path that has the maximum average cost, where the average is calculated as the total cost of the path divided by the number of cells in the path.

2. **Conceptualize a solution in plain English:**

   To solve this problem, we can use dynamic programming. We will create a 2D array `dp` where `dp[i][j]` will store the maximum sum of costs from the top-left corner to the cell `(i, j)`. We will also keep track of the number of cells in the path to `(i, j)` in another 2D array `count`. The average for each cell `(i, j)` can be calculated as `dp[i][j] / count[i][j]`. We will iterate through the matrix, updating `dp` and `count` based on the maximum sum path to each cell. Finally, the maximum average path will be found at the bottom-right corner of the matrix.

3. **Write a pseudocode solution:**

   ```
   Initialize dp and count arrays with dimensions N x N
   Set dp[0][0] = matrix[0][0]
   Set count[0][0] = 1

   For each cell (i, j) in the matrix:
       If moving from the left (i, j-1) is possible:
           Calculate potential new sum and count
           Update dp[i][j] and count[i][j] if this path is better
       If moving from above (i-1, j) is possible:
           Calculate potential new sum and count
           Update dp[i][j] and count[i][j] if this path is better

   Calculate the maximum average at the bottom-right corner as dp[N-1][N-1] / count[N-1][N-1]
   Return the maximum average
   ```

4. **Output the final Python 3 solution with your solution steps in comments:**

```python
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average
```
INFO - [Task id] Mbpp/721 [prompt] 
[Environment Feedback]:
    Note: Tests are automatically generated and can be wrong.

    Tests passed:
    None

    Tests failed:
    assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2 # output: division by zero
[/Environment Feedback]

INFO - [Task id] Mbpp/721 [prompt] 
The code doesn't pass all the tests.

## Instructions
- First, think step-by-step about why your code is wrong.
- Then, think step-by-step about where you went wrong in your latest solution.

INFO - [Task id] Mbpp/721 [prompt] Let's analyze the code and the error message to understand what went wrong:

1. **Error Analysis:**
   - The error message indicates a "division by zero" error. This suggests that at some point, the `count` array has a zero value, which is unexpected because every path should have at least one cell (the starting cell).

2. **Step-by-Step Analysis of the Code:**
   - **Initialization:** The `dp` and `count` arrays are initialized correctly, and the starting point `(0, 0)` is set with the correct initial values.
   - **Filling the Arrays:** The logic for updating `dp[i][j]` and `count[i][j]` is based on comparing potential new paths from the left `(i, j-1)` and from above `(i-1, j)`.
   - **Potential Issue:** The condition `if new_sum * count[i][j] > dp[i][j] * new_count` is used to decide whether to update `dp[i][j]` and `count[i][j]`. However, if `count[i][j]` is initially zero (which it is for all cells except the starting cell), this condition will not work correctly because multiplying by zero will always result in zero, leading to incorrect comparisons.

3. **Where the Solution Went Wrong:**
   - The logic for updating `dp[i][j]` and `count[i][j]` does not handle the initial zero values in `count` correctly. This results in `count[i][j]` remaining zero for some cells, leading to a division by zero error when calculating the average.

4. **Solution:**
   - We need to ensure that `count[i][j]` is initialized properly for each cell that is reachable, and the comparison logic should be adjusted to handle the initial zero values correctly.

Let's correct the code with these insights in mind:

```python
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average
```

**Explanation of Changes:**
- The condition `if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count` ensures that we update `dp[i][j]` and `count[i][j]` if `count[i][j]` is initially zero, which means the cell hasn't been reached yet. This prevents division by zero errors.
INFO - [Task id] Mbpp/721 [prompt] 
## Instructions
Now, given your insights, try to fix the solution. 
Output a block of correct python3 code to be executed and evaluated again. 

Make sure to wrap your code in '```python' and '```' Markdown delimiters.

INFO - [Task id] Mbpp/721 [prompt] 
Also, here are some of your memories.
Feel free to use the given information to aid your problem solving process if necessary.
Do not confuse the memories with the problem statement.

## Memories

[Textbook Reference Material]:
    Chapter: Dynamic programming
    Section: Paths in a grid
    Part: 1/1
    \section{Paths in a grid}

    Our next problem is to find a path
    from the upper-left corner to
    the lower-right corner
    of an $n \times n$ grid, such that
    we only move down and right.
    Each square contains a positive integer,
    and the path should be constructed so
    that the sum of the values along
    the path is as large as possible.

    The following picture shows an optimal
    path in a grid:
    \begin{center}
    \begin{tikzpicture}[scale=.65]
      \begin{scope}
        \fill [color=lightgray] (0, 9) rectangle (1, 8);
        \fill [color=lightgray] (0, 8) rectangle (1, 7);
        \fill [color=lightgray] (1, 8) rectangle (2, 7);
        \fill [color=lightgray] (1, 7) rectangle (2, 6);
        \fill [color=lightgray] (2, 7) rectangle (3, 6);
        \fill [color=lightgray] (3, 7) rectangle (4, 6);
        \fill [color=lightgray] (4, 7) rectangle (5, 6);
        \fill [color=lightgray] (4, 6) rectangle (5, 5);
        \fill [color=lightgray] (4, 5) rectangle (5, 4);
        \draw (0, 4) grid (5, 9);
        \node at (0.5,8.5) {3};
        \node at (1.5,8.5) {7};
        \node at (2.5,8.5) {9};
        \node at (3.5,8.5) {2};
        \node at (4.5,8.5) {7};
        \node at (0.5,7.5) {9};
        \node at (1.5,7.5) {8};
        \node at (2.5,7.5) {3};
        \node at (3.5,7.5) {5};
        \node at (4.5,7.5) {5};
        \node at (0.5,6.5) {1};
        \node at (1.5,6.5) {7};
        \node at (2.5,6.5) {9};
        \node at (3.5,6.5) {8};
        \node at (4.5,6.5) {5};
        \node at (0.5,5.5) {3};
        \node at (1.5,5.5) {8};
        \node at (2.5,5.5) {6};
        \node at (3.5,5.5) {4};
        \node at (4.5,5.5) {10};
        \node at (0.5,4.5) {6};
        \node at (1.5,4.5) {3};
        \node at (2.5,4.5) {9};
        \node at (3.5,4.5) {7};
        \node at (4.5,4.5) {8};
      \end{scope}
    \end{tikzpicture}
    \end{center}
    The sum of the values on the path is 67,
    and this is the largest possible sum on a path
    from the
    upper-left corner to the lower-right corner.

    Assume that the rows and columns of the
    grid are numbered from 1 to $n$,
    and $\texttt{value}[y][x]$ equals the value
    of square $(y,x)$.
    Let $\texttt{sum}(y,x)$ denote the maximum
    sum on a path from the upper-left corner
    to square $(y,x)$.
    Now $\texttt{sum}(n,n)$ tells us
    the maximum sum
    from the upper-left corner to
    the lower-right corner.
    For example, in the above grid,
    $\texttt{sum}(5,5)=67$.

    We can recursively calculate the sums
    as follows:
    \[ \texttt{sum}(y,x) = \max(\texttt{sum}(y,x-1),\texttt{sum}(y-1,x))+\texttt{value}[y][x]\]


    The recursive formula is based on the observation
    that a path that ends at square $(y,x)$
    can come either from square $(y,x-1)$
    or square $(y-1,x)$:
    \begin{center}
    \begin{tikzpicture}[scale=.65]
      \begin{scope}
        \fill [color=lightgray] (3, 7) rectangle (4, 6);
        \draw (0, 4) grid (5, 9);
    
        \node at (2.5,6.5) {$\rightarrow$};
        \node at (3.5,7.5) {$\downarrow$};
    
      \end{scope}
    \end{tikzpicture}
    \end{center}

    Thus, we select the direction that maximizes
    the sum.
    We assume that $\texttt{sum}(y,x)=0$
    if $y=0$ or $x=0$ (because no such paths exist),
    so the recursive formula also works when $y=1$ or $x=1$.

    Since the function \texttt{sum} has two parameters,
    the dynamic programming array also has two dimensions.
    For example, we can use an array
    \begin{lstlisting}
    int sum[N][N];
    \end{lstlisting}
    and calculate the sums as follows:
    \begin{lstlisting}
    for (int y = 1; y <= n; y++) {
        for (int x = 1; x <= n; x++) {
            sum[y][x] = max(sum[y][x-1],sum[y-1][x])+value[y][x];
        }
    }
    \end{lstlisting}
    The time complexity of the algorithm is $O(n^2)$.
[/Textbook Reference Material]


INFO - [Task id] Mbpp/721 [generation text] Let's fix the solution based on the insights from the error analysis and the reference material. The main issue was handling the initial zero values in the `count` array, which led to division by zero errors. We need to ensure that the `count` array is updated correctly for each cell that is reachable.

Here's the corrected Python code:

```python
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average
```

**Explanation of Changes:**
- The condition `if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count` ensures that we update `dp[i][j]` and `count[i][j]` if `count[i][j]` is initially zero, which means the cell hasn't been reached yet. This prevents division by zero errors and ensures that the path is correctly updated.
INFO - program_code:
 
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average


INFO - program_name:
 maxAverageOfPath

INFO - dependencies:
 []

INFO - raw_msg:
 Let's fix the solution based on the insights from the error analysis and the reference material. The main issue was handling the initial zero values in the `count` array, which led to division by zero errors. We need to ensure that the `count` array is updated correctly for each cell that is reachable.

Here's the corrected Python code:

```python
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average
```

**Explanation of Changes:**
- The condition `if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count` ensures that we update `dp[i][j]` and `count[i][j]` if `count[i][j]` is initially zero, which means the cell hasn't been reached yet. This prevents division by zero errors and ensures that the path is correctly updated.

INFO - no_parent:
 True

INFO - full code to be executed: 
 
def maxAverageOfPath(matrix: list[list[int]]) -> float:
    N = len(matrix)
    
    # Initialize dp and count arrays
    dp = [[0] * N for _ in range(N)]
    count = [[0] * N for _ in range(N)]
    
    # Base case: starting point
    dp[0][0] = matrix[0][0]
    count[0][0] = 1
    
    # Fill the dp and count arrays
    for i in range(N):
        for j in range(N):
            if i == 0 and j == 0:
                continue
            # Check from left
            if j > 0:
                new_sum = dp[i][j-1] + matrix[i][j]
                new_count = count[i][j-1] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
            # Check from above
            if i > 0:
                new_sum = dp[i-1][j] + matrix[i][j]
                new_count = count[i-1][j] + 1
                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:
                    dp[i][j] = new_sum
                    count[i][j] = new_count
    
    # Calculate the maximum average at the bottom-right corner
    max_average = dp[N-1][N-1] / count[N-1][N-1]
    return max_average


INFO - obs: Note: Tests are automatically generated and can be wrong.

Tests passed:
assert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2

Tests failed:
None
reward: True
done: None
info: {'individual_results': (True,)}
INFO - acc:270/281 = 96.09%
