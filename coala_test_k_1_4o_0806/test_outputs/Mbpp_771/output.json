{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert check_expression(\"{()}[{}]\") == True\n\nTests failed:\nNone",
    "code": "\ndef check_expression(expression: str) -> bool:\n    # Stack to keep track of opening brackets\n    stack = []\n    # Mapping of closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is empty or the top of the stack is not the matching opening bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the top of the stack as it is a matching pair\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched correctly\n    return not stack\n",
    "full_code": "\ndef check_expression(expression: str) -> bool:\n    # Stack to keep track of opening brackets\n    stack = []\n    # Mapping of closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is empty or the top of the stack is not the matching opening bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the top of the stack as it is a matching pair\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched correctly\n    return not stack\n",
    "reward": true,
    "program_code": "\ndef check_expression(expression: str) -> bool:\n    # Stack to keep track of opening brackets\n    stack = []\n    # Mapping of closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is empty or the top of the stack is not the matching opening bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the top of the stack as it is a matching pair\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched correctly\n    return not stack\n",
    "program_name": "check_expression",
    "dependencies": [],
    "raw_msg": "1. **Restate the problem in plain English:**\n\n   We need to determine if a given string of brackets is balanced. A string is considered balanced if every opening bracket has a corresponding and correctly ordered closing bracket. The types of brackets to consider are parentheses `()`, square brackets `[]`, and curly braces `{}`.\n\n2. **Conceptualize a solution in plain English:**\n\n   To solve this problem, we can use a stack data structure. As we iterate through each character in the string:\n   - If the character is an opening bracket (`{`, `[`, or `(`), we push it onto the stack.\n   - If the character is a closing bracket (`}`, `]`, or `)`), we check if the stack is not empty and if the top of the stack is the corresponding opening bracket. If it is, we pop the stack. If not, the string is unbalanced.\n   - After processing all characters, if the stack is empty, the string is balanced; otherwise, it is not.\n\n3. **Write a pseudocode solution:**\n\n   ```\n   function check_expression(expression):\n       create an empty stack\n       create a mapping of closing to opening brackets\n       \n       for each character in expression:\n           if character is an opening bracket:\n               push it onto the stack\n           else if character is a closing bracket:\n               if stack is empty or top of stack is not the matching opening bracket:\n                   return False\n               pop the stack\n       \n       return True if stack is empty, else False\n   ```\n\n4. **Output the final Python 3 solution with your solution steps in comments:**\n\n```python\ndef check_expression(expression: str) -> bool:\n    # Stack to keep track of opening brackets\n    stack = []\n    # Mapping of closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is empty or the top of the stack is not the matching opening bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the top of the stack as it is a matching pair\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched correctly\n    return not stack\n```",
    "no_parent": true,
    "dependency_used": false
}