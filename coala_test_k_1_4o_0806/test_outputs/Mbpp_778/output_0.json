{
    "env_feedback": "Note: Tests are automatically generated and can be wrong.\n\nTests passed:\nassert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4])==[[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n\nTests failed:\nNone",
    "code": "\ndef pack_consecutive_duplicates(lst):\n    # Initialize the result list and a temporary list to hold current duplicates\n    result = []\n    temp = []\n\n    # Iterate through each element in the input list\n    for element in lst:\n        # If temp is empty or the current element is the same as the last in temp\n        if not temp or element == temp[-1]:\n            # Add the element to the temp list\n            temp.append(element)\n        else:\n            # If the current element is different, add the temp list to result\n            result.append(temp)\n            # Start a new temp list with the current element\n            temp = [element]\n\n    # After the loop, add any remaining elements in temp to result\n    if temp:\n        result.append(temp)\n\n    # Return the result list containing sublists of consecutive duplicates\n    return result\n",
    "full_code": "\ndef pack_consecutive_duplicates(lst):\n    # Initialize the result list and a temporary list to hold current duplicates\n    result = []\n    temp = []\n\n    # Iterate through each element in the input list\n    for element in lst:\n        # If temp is empty or the current element is the same as the last in temp\n        if not temp or element == temp[-1]:\n            # Add the element to the temp list\n            temp.append(element)\n        else:\n            # If the current element is different, add the temp list to result\n            result.append(temp)\n            # Start a new temp list with the current element\n            temp = [element]\n\n    # After the loop, add any remaining elements in temp to result\n    if temp:\n        result.append(temp)\n\n    # Return the result list containing sublists of consecutive duplicates\n    return result\n",
    "reward": true,
    "program_code": "\ndef pack_consecutive_duplicates(lst):\n    # Initialize the result list and a temporary list to hold current duplicates\n    result = []\n    temp = []\n\n    # Iterate through each element in the input list\n    for element in lst:\n        # If temp is empty or the current element is the same as the last in temp\n        if not temp or element == temp[-1]:\n            # Add the element to the temp list\n            temp.append(element)\n        else:\n            # If the current element is different, add the temp list to result\n            result.append(temp)\n            # Start a new temp list with the current element\n            temp = [element]\n\n    # After the loop, add any remaining elements in temp to result\n    if temp:\n        result.append(temp)\n\n    # Return the result list containing sublists of consecutive duplicates\n    return result\n",
    "program_name": "pack_consecutive_duplicates",
    "dependencies": [],
    "raw_msg": "## Problem Restatement\n\nWe need to transform a list of integers by grouping consecutive duplicate elements into sublists. The goal is to iterate through the list and whenever we encounter consecutive duplicates, we group them together in a sublist.\n\n## Conceptual Solution\n\n1. **Initialize Variables**: Start with an empty list to store the result and a temporary list to keep track of the current group of duplicates.\n\n2. **Iterate Through the List**: Go through each element in the list.\n   - If the current element is the same as the last element in the temporary list (or if the temporary list is empty), add it to the temporary list.\n   - If the current element is different, add the temporary list to the result list and start a new temporary list with the current element.\n\n3. **Finalize the Result**: After the loop, add any remaining elements in the temporary list to the result list.\n\n4. **Return the Result**: The result list will contain sublists of consecutive duplicates.\n\n## Pseudocode\n\n```\nfunction pack_consecutive_duplicates(lst):\n    initialize result as an empty list\n    initialize temp as an empty list\n\n    for each element in lst:\n        if temp is empty or element is equal to the last element in temp:\n            add element to temp\n        else:\n            add temp to result\n            reset temp to a new list containing the current element\n\n    if temp is not empty:\n        add temp to result\n\n    return result\n```\n\n## Final Python Solution\n\n```python\ndef pack_consecutive_duplicates(lst):\n    # Initialize the result list and a temporary list to hold current duplicates\n    result = []\n    temp = []\n\n    # Iterate through each element in the input list\n    for element in lst:\n        # If temp is empty or the current element is the same as the last in temp\n        if not temp or element == temp[-1]:\n            # Add the element to the temp list\n            temp.append(element)\n        else:\n            # If the current element is different, add the temp list to result\n            result.append(temp)\n            # Start a new temp list with the current element\n            temp = [element]\n\n    # After the loop, add any remaining elements in temp to result\n    if temp:\n        result.append(temp)\n\n    # Return the result list containing sublists of consecutive duplicates\n    return result\n```\n\nThis solution iterates through the list once, making it efficient with a time complexity of O(n), where n is the number of elements in the list.",
    "no_parent": true,
    "dependency_used": false
}