{"task_id": "Mbpp/100", "solution": "\ndef is_palindrome(number: int) -> bool:\n    # Convert the number to a string\n    str_num = str(number)\n    # Check if the string is equal to its reverse\n    return str_num == str_num[::-1]\n\ndef next_smallest_palindrome(n: int) -> int:\n    # Start with the next number after n\n    candidate = n + 1\n    # Continue until we find a palindrome\n    while not is_palindrome(candidate):\n        # Increment the candidate number\n        candidate += 1\n    # Return the palindrome found\n    return candidate\n"}
{"task_id": "Mbpp/101", "solution": "\ndef kth_element(array, k):\n    # Return the element at index k-1 to account for 1-based indexing\n    return array[k-1]\n"}
{"task_id": "Mbpp/102", "solution": "\ndef snake_to_camel(snake_str: str) -> str:\n    # Split the input string by underscores to get individual words\n    words = snake_str.split('_')\n    # Capitalize the first letter of each word and join them together\n    camel_case_str = ''.join(word.capitalize() for word in words)\n    # Return the resulting CamelCase string\n    return camel_case_str\n"}
{"task_id": "Mbpp/103", "solution": "\ndef eulerian_num(n: int, m: int) -> int:\n    # Memoization dictionary to store previously computed results\n    memo = {}\n\n    def compute_eulerian(n, m):\n        # Base case: if m is 0, there's exactly one permutation\n        if m == 0:\n            return 1\n        # If m is greater than or equal to n, there are no valid permutations\n        if m >= n:\n            return 0\n        # Check if the result is already computed\n        if (n, m) in memo:\n            return memo[(n, m)]\n        \n        # Recursive calculation using the Eulerian number formula\n        result = (n - m) * compute_eulerian(n-1, m-1) + (m + 1) * compute_eulerian(n-1, m)\n        # Store the result in the memoization dictionary\n        memo[(n, m)] = result\n        return result\n\n    # Call the recursive function\n    return compute_eulerian(n, m)\n"}
{"task_id": "Mbpp/104", "solution": "\ndef sort_sublists(list_of_lists):\n    # Convert the input to a list if it is a tuple\n    if isinstance(list_of_lists, tuple):\n        list_of_lists = list(list_of_lists)\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Sort the sublist in place\n        sublist.sort()\n    \n    # Return the modified list of lists\n    return list_of_lists\n"}
{"task_id": "Mbpp/105", "solution": "\ndef count(boolean_list):\n    # Initialize a counter to keep track of the number of True values\n    counter = 0\n    # Iterate over each element in the list\n    for element in boolean_list:\n        # Check if the current element is True\n        if element is True:\n            # Increment the counter if the element is True\n            counter += 1\n    # Return the total count of True values\n    return counter\n"}
{"task_id": "Mbpp/106", "solution": "\ndef add_lists(lst, tpl):\n    # Convert the list to a tuple\n    list_as_tuple = tuple(lst)\n    \n    # Concatenate the original tuple with the tuple created from the list\n    result = tpl + list_as_tuple\n    \n    # Return the resulting tuple\n    return result\n"}
{"task_id": "Mbpp/108", "solution": "\ndef merge_sorted_list(list1, list2, list3):\n    # Step 1: Combine the three lists into one\n    combined_list = list1 + list2 + list3\n    \n    # Step 2: Sort the combined list\n    sorted_list = sorted(combined_list)\n    \n    # Step 3: Return the sorted list\n    return sorted_list\n"}
{"task_id": "Mbpp/109", "solution": "\ndef odd_Equivalent(binary_string: str, num_rotations: int) -> int:\n    count_odd = 0  # Initialize the count of odd numbers\n    for _ in range(num_rotations):\n        # Rotate the binary string by moving the first character to the end\n        binary_string = binary_string[1:] + binary_string[0]\n        # Convert the rotated binary string to a decimal number\n        decimal_value = int(binary_string, 2)\n        # Check if the decimal number is odd\n        if decimal_value % 2 == 1:\n            count_odd += 1  # Increment the count if the number is odd\n    return count_odd  # Return the total count of odd numbers\n"}
{"task_id": "Mbpp/11", "solution": "\ndef remove_Occ(s: str, char: str) -> str:\n    # Find the index of the first occurrence of the character\n    first_index = s.find(char)\n    # Find the index of the last occurrence of the character\n    last_index = s.rfind(char)\n    \n    # If the character is found, remove it from the first and last positions\n    if first_index != -1:\n        # Remove the first occurrence\n        s = s[:first_index] + s[first_index+1:]\n        # Adjust last_index if it was after the first_index\n        if last_index > first_index:\n            last_index -= 1\n        # Remove the last occurrence\n        s = s[:last_index] + s[last_index+1:]\n    \n    # Return the modified string\n    return s\n"}
{"task_id": "Mbpp/111", "solution": "\ndef common_in_nested_lists(nested_lists):\n    # If the input list is empty, return an empty list\n    if not nested_lists:\n        return []\n\n    # Initialize the common elements with the first list converted to a set\n    common_elements = set(nested_lists[0])\n\n    # Iterate over the remaining lists\n    for lst in nested_lists[1:]:\n        # Update the common elements by intersecting with the current list converted to a set\n        common_elements.intersection_update(lst)\n\n    # Return the common elements as a list\n    return list(common_elements)\n"}
{"task_id": "Mbpp/113", "solution": "\ndef check_integer(s: str) -> bool:\n    try:\n        # Attempt to convert the string to an integer\n        int(s)\n        # If successful, return True\n        return True\n    except ValueError:\n        # If a ValueError is raised, return False\n        return False\n"}
{"task_id": "Mbpp/116", "solution": "\ndef tuple_to_int(tup):\n    # Initialize an empty string to store the concatenated result\n    result = ''\n    \n    # Iterate over each number in the tuple\n    for number in tup:\n        # Convert the number to a string and append it to the result\n        result += str(number)\n    \n    # Convert the concatenated string to an integer\n    return int(result)\n"}
{"task_id": "Mbpp/118", "solution": "\ndef string_to_list(s: str) -> list:\n    # Use the split method to divide the string into a list of words\n    # The split method by default splits on spaces\n    return s.split()\n"}
{"task_id": "Mbpp/119", "solution": "\ndef search(arr):\n    # Iterate over the array with a step of 2 to check pairs\n    for i in range(0, len(arr) - 1, 2):\n        # If the current element is not equal to the next one, it is the unique element\n        if arr[i] != arr[i + 1]:\n            return arr[i]\n    # If no unique element is found in pairs, the last element is the unique one\n    return arr[-1]\n"}
{"task_id": "Mbpp/12", "solution": "\ndef sort_matrix(matrix):\n    # Create a list of tuples where each tuple is (sum of row, row)\n    row_sums = [(sum(row), row) for row in matrix]\n    \n    # Sort the list of tuples based on the sum of the row\n    row_sums.sort()\n    \n    # Extract the rows from the sorted list of tuples\n    sorted_matrix = [row for _, row in row_sums]\n    \n    # Return the sorted list of rows\n    return sorted_matrix\n"}
{"task_id": "Mbpp/120", "solution": "\ndef max_product_tuple(list_of_tuples):\n    # Initialize the maximum product to 0\n    max_product = 0\n    \n    # Iterate over each tuple in the list\n    for a, b in list_of_tuples:\n        # Calculate the product of the two numbers in the tuple\n        product = a * b\n        # Calculate the absolute value of the product\n        abs_product = abs(product)\n        # If the absolute product is greater than the current maximum, update the maximum\n        if abs_product > max_product:\n            max_product = abs_product\n    \n    # Return the maximum absolute product found\n    return max_product\n"}
{"task_id": "Mbpp/123", "solution": "\n# Function to calculate the sum of proper divisors of a number\ndef sum_of_divisors(n):\n    # Initialize sum to 0\n    sum_div = 0\n    # Iterate over all numbers from 1 to n-1\n    for i in range(1, n):\n        # If i is a divisor of n, add it to the sum\n        if n % i == 0:\n            sum_div += i\n    return sum_div\n\n# Function to calculate the sum of all amicable numbers up to a given limit\ndef amicable_numbers_sum(limit):\n    # Initialize total sum of amicable numbers to 0\n    total_sum = 0\n    # Iterate over each number from 1 to the limit\n    for a in range(1, limit):\n        # Find the sum of divisors of a\n        b = sum_of_divisors(a)\n        # Check if a and b form an amicable pair\n        if b != a and sum_of_divisors(b) == a:\n            # Add a to the total sum if it is part of an amicable pair\n            total_sum += a\n    return total_sum\n"}
{"task_id": "Mbpp/124", "solution": "\nimport cmath\n\n# Define the function to calculate the angle of a complex number\ndef angle_complex(z: complex) -> float:\n    # Use cmath.phase to get the angle of the complex number\n    angle = cmath.phase(z)\n    # Return the calculated angle\n    return angle\n"}
{"task_id": "Mbpp/125", "solution": "\ndef find_length(binary_string: str) -> int:\n    # Initialize the maximum difference found so far to 0\n    max_diff = 0\n    # Initialize the current difference to 0\n    current_diff = 0\n\n    # Iterate over each character in the binary string\n    for char in binary_string:\n        # If the character is '0', treat it as +1\n        if char == '0':\n            current_diff += 1\n        # If the character is '1', treat it as -1\n        else:\n            current_diff -= 1\n\n        # Update the maximum difference if the current difference is greater\n        if current_diff > max_diff:\n            max_diff = current_diff\n\n        # If the current difference becomes negative, reset it to 0\n        if current_diff < 0:\n            current_diff = 0\n\n    # Return the maximum difference found\n    return max_diff\n"}
{"task_id": "Mbpp/126", "solution": "\ndef gcd(x, y):\n    # Helper function to calculate the greatest common divisor using Euclid's algorithm\n    while y != 0:\n        (x, y) = (y, x % y)\n    return x\n\ndef sum(a: int, b: int) -> int:\n    # Find the greatest common divisor of a and b\n    common_gcd = gcd(a, b)\n    \n    # Initialize the sum of divisors\n    total_sum = 0\n    \n    # Iterate over all numbers from 1 to the GCD\n    for i in range(1, common_gcd + 1):\n        # If i is a divisor of the GCD, add it to the total sum\n        if common_gcd % i == 0:\n            total_sum += i\n    \n    # Return the sum of all common divisors\n    return total_sum\n"}
{"task_id": "Mbpp/127", "solution": "\n# Define the function multiply_int with two parameters a and b\ndef multiply_int(a: int, b: int) -> int:\n    # Calculate the product of a and b\n    product = a * b\n    # Return the product\n    return product\n"}
{"task_id": "Mbpp/128", "solution": "\ndef long_words(n: int, sentence: str) -> list:\n    # Split the sentence into a list of words\n    words = sentence.split()\n    \n    # Initialize an empty list to store words longer than n characters\n    long_words_list = []\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Check if the length of the word is greater than n\n        if len(word) > n:\n            # Add the word to the list of long words\n            long_words_list.append(word)\n    \n    # Return the list of words that are longer than n characters\n    return long_words_list\n"}
{"task_id": "Mbpp/129", "solution": "\ndef magic_square_test(matrix):\n    n = len(matrix)\n    if n == 0:\n        return False\n    \n    # Calculate the target sum using the first row\n    target_sum = sum(matrix[0])\n    \n    # Check each row sum\n    for row in matrix:\n        if sum(row) != target_sum:\n            return False\n    \n    # Check each column sum\n    for col in range(n):\n        column_sum = 0\n        for row in matrix:\n            column_sum += row[col]\n        if column_sum != target_sum:\n            return False\n    \n    # Check the sum of the first diagonal\n    diagonal1_sum = 0\n    for i in range(n):\n        diagonal1_sum += matrix[i][i]\n    if diagonal1_sum != target_sum:\n        return False\n    \n    # Check the sum of the second diagonal\n    diagonal2_sum = 0\n    for i in range(n):\n        diagonal2_sum += matrix[i][n - 1 - i]\n    if diagonal2_sum != target_sum:\n        return False\n    \n    # If all checks passed, it is a magic square\n    return True\n"}
{"task_id": "Mbpp/130", "solution": "\ndef max_occurrences(lst):\n    # Create a dictionary to store the frequency of each number\n    frequency_count = {}\n    \n    # Count the occurrences of each number in the list\n    for number in lst:\n        if number not in frequency_count:\n            frequency_count[number] = 1\n        else:\n            frequency_count[number] += 1\n    \n    # Initialize variables to track the maximum frequency and the corresponding number\n    max_count = 0\n    max_item = None\n    \n    # Find the number with the maximum frequency\n    for number, count in frequency_count.items():\n        if count > max_count:\n            max_count = count\n            max_item = number\n    \n    # Return the number with the maximum frequency\n    return max_item\n"}
{"task_id": "Mbpp/131", "solution": "\ndef reverse_vowels(s: str) -> str:\n    # Define a set of vowels for quick lookup\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    \n    # Extract vowels from the string\n    vowel_list = [char for char in s if char in vowels]\n    \n    # Reverse the list of vowels\n    vowel_list.reverse()\n    \n    # Initialize a list to build the result string\n    result = []\n    \n    # Counter to track position in the reversed vowel list\n    vowel_index = 0\n    \n    # Iterate over each character in the original string\n    for char in s:\n        if char in vowels:\n            # If the character is a vowel, replace it with the next vowel from the reversed list\n            result.append(vowel_list[vowel_index])\n            vowel_index += 1\n        else:\n            # If not a vowel, keep the character as is\n            result.append(char)\n    \n    # Join the list into a string and return\n    return ''.join(result)\n"}
{"task_id": "Mbpp/132", "solution": "\ndef tup_string(t: tuple) -> str:\n    # Use the join method to concatenate all elements of the tuple into a single string\n    return ''.join(t)\n"}
{"task_id": "Mbpp/133", "solution": "\ndef sum_negativenum(numbers):\n    # Initialize a variable to store the sum of negative numbers\n    sum_negative = 0\n    \n    # Iterate over each number in the list\n    for num in numbers:\n        # Check if the number is negative\n        if num < 0:\n            # Add the negative number to the sum\n            sum_negative += num\n    \n    # Return the total sum of negative numbers\n    return sum_negative\n"}
{"task_id": "Mbpp/135", "solution": "\ndef hexagonal_num(n: int) -> int:\n    # Calculate the nth hexagonal number using the formula\n    # H_n = n * (2n - 1)\n    hexagonal_number = n * (2 * n - 1)\n    return hexagonal_number\n"}
{"task_id": "Mbpp/137", "solution": "\ndef zero_count(arr):\n    # Initialize counters for zeroes and non-zeroes\n    zero_count = 0\n    non_zero_count = 0\n    \n    # Iterate through each element in the array\n    for num in arr:\n        if num == 0:\n            # Increment zero_count if the element is zero\n            zero_count += 1\n        else:\n            # Increment non_zero_count if the element is non-zero\n            non_zero_count += 1\n    \n    # If there are no non-zero elements, return 0.0 to avoid division by zero\n    if non_zero_count == 0:\n        return 0.0\n    \n    # Calculate the ratio of zeroes to non-zeroes\n    ratio = zero_count / non_zero_count\n    \n    # Return the calculated ratio\n    return ratio\n"}
{"task_id": "Mbpp/138", "solution": "\ndef is_Sum_Of_Powers_Of_Two(n: int) -> bool:\n    # Convert the number to its binary representation\n    # and check if it contains only '0' and '1'\n    # The binary representation of a number in Python starts with '0b'\n    # so we slice it off using [2:]\n    binary_representation = bin(n)[2:]\n    \n    # Check if all characters in the binary representation are either '0' or '1'\n    for char in binary_representation:\n        if char not in '01':\n            return False\n    \n    # If we only have '0' and '1', it means the number can be represented\n    # as a sum of distinct powers of 2\n    return True\n"}
{"task_id": "Mbpp/139", "solution": "\nimport math\n\ndef circle_circumference(radius: float) -> float:\n    # Calculate the circumference using the formula: C = 2 * pi * radius\n    circumference = 2 * math.pi * radius\n    # Return the calculated circumference\n    return circumference\n"}
{"task_id": "Mbpp/14", "solution": "\ndef find_Volume(base: float, height: float, length: float) -> float:\n    # Calculate the area of the triangular base\n    area_of_base = 0.5 * base * height\n    # Calculate the volume of the triangular prism\n    volume = area_of_base * length\n    # Return the calculated volume\n    return volume\n"}
{"task_id": "Mbpp/140", "solution": "\ndef extract_singly(list_of_tuples):\n    # Initialize an empty set to store unique numbers\n    result_set = set()\n    \n    # Iterate over each tuple in the list\n    for tuple_ in list_of_tuples:\n        # Iterate over each number in the current tuple\n        for number in tuple_:\n            # Add the number to the set (duplicates are automatically handled)\n            result_set.add(number)\n    \n    # Return the set containing all unique numbers\n    return result_set\n"}
{"task_id": "Mbpp/141", "solution": "\ndef flip(arr, k):\n    # Reverse the first k elements of the array\n    start = 0\n    while start < k - 1:\n        arr[start], arr[k - 1] = arr[k - 1], arr[start]\n        start += 1\n        k -= 1\n\ndef pancake_sort(arr):\n    n = len(arr)\n    # Start from the complete array and reduce the size each time\n    for curr_size in range(n, 1, -1):\n        # Find the index of the maximum element in arr[0:curr_size]\n        max_index = 0\n        for i in range(1, curr_size):\n            if arr[i] > arr[max_index]:\n                max_index = i\n        # If the maximum element is not at its correct position\n        if max_index != curr_size - 1:\n            # Bring the maximum element to the front\n            flip(arr, max_index + 1)\n            # Move the maximum element to its correct position\n            flip(arr, curr_size)\n    return arr\n"}
{"task_id": "Mbpp/142", "solution": "\ndef count_samepair(list1, list2, list3):\n    # Initialize a counter to keep track of identical items in the same position\n    count = 0\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Check if the elements at the current index are the same in all three lists\n        if list1[i] == list2[i] == list3[i]:\n            # Increment the counter if they are identical\n            count += 1\n    \n    # Return the total count of identical items in the same position\n    return count\n"}
{"task_id": "Mbpp/145", "solution": "\ndef max_Abs_Diff(arr: tuple) -> int:\n    # If the array is empty, return 0 as there are no elements to compare\n    if not arr:\n        return 0\n    \n    # Find the minimum element in the array\n    min_element = min(arr)\n    \n    # Find the maximum element in the array\n    max_element = max(arr)\n    \n    # Calculate the difference between the maximum and minimum elements\n    max_difference = max_element - min_element\n    \n    # Return the maximum difference\n    return max_difference\n"}
{"task_id": "Mbpp/16", "solution": "\ndef text_lowercase_underscore(s: str) -> bool:\n    # Iterate through the string, starting from the second character and ending at the second last character\n    for i in range(1, len(s) - 1):\n        # Check if the current character is an underscore\n        if s[i] == '_':\n            # Check if the characters before and after the underscore are lowercase letters\n            if s[i - 1].islower() and s[i + 1].islower():\n                return True\n    # If no valid pattern is found, return False\n    return False\n"}
{"task_id": "Mbpp/160", "solution": "\ndef extended_gcd(a, b):\n    if b == 0:\n        return (a, 1, 0)\n    else:\n        gcd, x1, y1 = extended_gcd(b, a % b)\n        x = y1\n        y = x1 - (a // b) * y1\n        return (gcd, x, y)\n\ndef find_solution(a, b, n):\n    gcd, x0, y0 = extended_gcd(a, b)\n    if n % gcd != 0:\n        return None\n    scale = n // gcd\n    x = x0 * scale\n    y = y0 * scale\n    \n    # Adjust x and y to find a positive solution\n    b_div_gcd = b // gcd\n    a_div_gcd = a // gcd\n    \n    # Adjust x to be positive\n    while x < 0:\n        x += b_div_gcd\n        y -= a_div_gcd\n    \n    # Adjust y to be positive\n    while y < 0:\n        x -= b_div_gcd\n        y += a_div_gcd\n    \n    return (x, y)\n"}
{"task_id": "Mbpp/161", "solution": "\ndef remove_elements(list1, list2):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over each element in the first list\n    for element in list1:\n        # Check if the element is not present in the second list\n        if element not in list2:\n            # If not present, add it to the result list\n            result.append(element)\n    # Return the result list which contains elements not in the second list\n    return result\n"}
{"task_id": "Mbpp/162", "solution": "\ndef sum_series(n: int) -> int:\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate from 0 to n // 2 (inclusive)\n    for i in range(n // 2 + 1):\n        # Calculate the current term in the series\n        term = n - 2 * i\n        # Add the term to the total sum\n        total_sum += term\n    \n    # Return the total sum of the series\n    return total_sum\n"}
{"task_id": "Mbpp/165", "solution": "\ndef count_char_position(s: str) -> int:\n    # Convert the string to lowercase to handle case insensitivity\n    s = s.lower()\n    \n    # Initialize a counter for characters that match their position\n    count = 0\n    \n    # Iterate over each character in the string with its index\n    for i, char in enumerate(s):\n        # Calculate the position of the character in the alphabet\n        # 'a' is 1, 'b' is 2, ..., 'z' is 26\n        alphabet_position = ord(char) - ord('a') + 1\n        \n        # Check if the alphabet position matches the character's position in the string\n        # (i + 1 because string positions are 1-based in this context)\n        if alphabet_position == i + 1:\n            # Increment the count if the positions match\n            count += 1\n    \n    # Return the final count\n    return count\n"}
{"task_id": "Mbpp/166", "solution": "\ndef find_even_pair(numbers):\n    # Initialize counters for even and odd numbers\n    even_count = 0\n    odd_count = 0\n    \n    # Count the number of even and odd numbers\n    for number in numbers:\n        if number % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate the number of pairs of even numbers\n    even_pairs = even_count * (even_count - 1) // 2\n    \n    # Calculate the number of pairs of odd numbers\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    \n    # Return the total number of pairs that XOR to an even number\n    return even_pairs + odd_pairs\n"}
{"task_id": "Mbpp/167", "solution": "\ndef next_power_of_2(n: int) -> int:\n    # If n is 0, the smallest power of 2 greater than or equal to n is 1\n    if n == 0:\n        return 1\n    \n    # Start with the smallest power of 2, which is 1\n    power = 1\n    \n    # Double the power until it is greater than or equal to n\n    while power < n:\n        power *= 2\n    \n    # Return the smallest power of 2 that is greater than or equal to n\n    return power\n"}
{"task_id": "Mbpp/168", "solution": "\ndef frequency(lst, num):\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    # Iterate through each element in the list\n    for element in lst:\n        # If the current element matches the number we're looking for\n        if element == num:\n            # Increment the counter\n            count += 1\n    # Return the total count of occurrences\n    return count\n"}
{"task_id": "Mbpp/17", "solution": "\ndef square_perimeter(side_length: int) -> int:\n    # Calculate the perimeter by multiplying the side length by 4\n    return 4 * side_length\n"}
{"task_id": "Mbpp/170", "solution": "\ndef sum_range_list(numbers: list, start: int, end: int) -> int:\n    # Extract the sublist from the list using the start and end indices\n    sublist = numbers[start:end+1]\n    \n    # Calculate the sum of the numbers in the sublist\n    total_sum = sum(sublist)\n    \n    # Return the calculated sum\n    return total_sum\n"}
{"task_id": "Mbpp/171", "solution": "\ndef perimeter_pentagon(side_length: int) -> int:\n    # A regular pentagon has 5 equal sides.\n    # The perimeter is calculated by multiplying the length of one side by 5.\n    return side_length * 5\n"}
{"task_id": "Mbpp/172", "solution": "\ndef count_occurance(input_string: str) -> int:\n    # Initialize the count of occurrences to 0\n    count = 0\n    # Define the target substring we are looking for\n    target_substring = \"std\"\n    # Calculate the length of the target substring\n    target_length = len(target_substring)\n    \n    # Iterate over each possible starting index in the input string\n    for i in range(len(input_string) - target_length + 1):\n        # Check if the substring from the current index matches the target substring\n        if input_string[i:i + target_length] == target_substring:\n            # If it matches, increment the count\n            count += 1\n    \n    # Return the total count of occurrences\n    return count\n"}
{"task_id": "Mbpp/18", "solution": "\ndef remove_dirty_chars(s1: str, s2: str) -> str:\n    # Initialize an empty result string\n    result = ''\n    # Iterate over each character in the first string\n    for char in s1:\n        # If the character is not in the second string, add it to the result\n        if char not in s2:\n            result += char\n    # Return the result string\n    return result\n"}
{"task_id": "Mbpp/19", "solution": "\ndef test_duplicate(arr):\n    # Initialize an empty set to keep track of seen numbers\n    seen_numbers = set()\n    \n    # Iterate over each number in the array\n    for number in arr:\n        # Check if the number is already in the set\n        if number in seen_numbers:\n            # If it is, we found a duplicate, return True\n            return True\n        else:\n            # If not, add the number to the set\n            seen_numbers.add(number)\n    \n    # If no duplicates were found, return False\n    return False\n"}
{"task_id": "Mbpp/2", "solution": "\ndef similar_elements(list1, list2):\n    # Convert both input lists to sets\n    set1 = set(list1)\n    set2 = set(list2)\n    \n    # Find the intersection of the two sets\n    common_elements = set1.intersection(set2)\n    \n    # Convert the set of common elements to a list\n    return list(common_elements)\n"}
{"task_id": "Mbpp/20", "solution": "\ndef is_woodall(x: int) -> bool:\n    # Start with n = 1\n    n = 1\n    # Continue the loop indefinitely\n    while True:\n        # Calculate the Woodall number for the current n\n        woodall_number = n * (2 ** n) - 1\n        # Check if the calculated Woodall number matches x\n        if woodall_number == x:\n            return True\n        # If the calculated Woodall number exceeds x, x is not a Woodall number\n        if woodall_number > x:\n            return False\n        # Increment n to check the next possible Woodall number\n        n += 1\n"}
{"task_id": "Mbpp/222", "solution": "\ndef check_type(input_tuple):\n    # If the tuple is empty, return True as there are no elements to compare\n    if not input_tuple:\n        return True\n    \n    # Get the data type of the first element\n    first_type = type(input_tuple[0])\n    \n    # Iterate over each element in the tuple\n    for element in input_tuple:\n        # If the current element's type is not the same as the first element's type, return False\n        if type(element) != first_type:\n            return False\n    \n    # If all elements have the same type, return True\n    return True\n"}
{"task_id": "Mbpp/223", "solution": "\ndef find_first_occurrence(arr, n, x):\n    low, high = 0, n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        # Check if mid is the first occurrence of x\n        if arr[mid] == x and (mid == 0 or arr[mid - 1] != x):\n            return mid\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\ndef is_majority(arr, n, x):\n    # Find the first occurrence of x\n    first_occurrence = find_first_occurrence(arr, n, x)\n    \n    # If x is not present, it cannot be the majority element\n    if first_occurrence == -1:\n        return False\n    \n    # Check if x is the majority element\n    if first_occurrence + n // 2 < n and arr[first_occurrence + n // 2] == x:\n        return True\n    else:\n        return False\n"}
{"task_id": "Mbpp/224", "solution": "\ndef count_Set_Bits(n: int) -> int:\n    # Convert the number to a binary string and remove the '0b' prefix\n    binary_representation = bin(n)[2:]\n    # Count the number of '1's in the binary string\n    set_bits_count = binary_representation.count('1')\n    # Return the count of set bits\n    return set_bits_count\n"}
{"task_id": "Mbpp/226", "solution": "\ndef odd_values_string(s: str) -> str:\n    # Use slicing to get every character at even indices\n    # This effectively skips characters at odd indices\n    return s[::2]\n"}
{"task_id": "Mbpp/227", "solution": "\ndef min_of_three(a: int, b: int, c: int) -> int:\n    # Check if 'a' is the smallest among the three numbers\n    if a <= b and a <= c:\n        return a\n    # If not, check if 'b' is the smallest\n    elif b <= a and b <= c:\n        return b\n    # If neither 'a' nor 'b' is the smallest, 'c' must be the smallest\n    else:\n        return c\n"}
{"task_id": "Mbpp/230", "solution": "\ndef replace_blank(input_string: str, replacement_char: str) -> str:\n    # Use the replace method to replace all spaces in the input_string\n    # with the replacement_char\n    modified_string = input_string.replace(' ', replacement_char)\n    \n    # Return the modified string\n    return modified_string\n"}
{"task_id": "Mbpp/232", "solution": "\ndef larg_nnum(lst, n):\n    # Sort the list in descending order\n    sorted_lst = sorted(lst, reverse=True)\n    # Return the first n elements from the sorted list\n    return sorted_lst[:n]\n"}
{"task_id": "Mbpp/233", "solution": "\nimport math\n\ndef lateralsuface_cylinder(radius: float, height: float) -> float:\n    # Calculate the lateral surface area using the formula: 2 * \u03c0 * radius * height\n    lateral_surface_area = 2 * math.pi * radius * height\n    # Return the calculated lateral surface area\n    return lateral_surface_area\n"}
{"task_id": "Mbpp/234", "solution": "\ndef volume_cube(side_length: int) -> int:\n    # Calculate the volume of the cube by cubing the side length\n    volume = side_length ** 3\n    # Return the calculated volume\n    return volume\n"}
{"task_id": "Mbpp/235", "solution": "\ndef even_bit_set_number(n: int) -> int:\n    # Initialize the mask with 0\n    mask = 0\n    # Start with the 0th bit position\n    bit_position = 0\n    \n    # Loop to set all even bits in the mask\n    while bit_position < 32:  # Cover at least 32 bits\n        # Set the bit at the current even position\n        mask |= (1 << bit_position)\n        # Move to the next even bit position\n        bit_position += 2\n    \n    # Return the number with all even bits set\n    return n | mask\n"}
{"task_id": "Mbpp/237", "solution": "\ndef check_occurences(tuples_list):\n    # Initialize an empty dictionary to store the occurrences\n    occurrences = {}\n    \n    # Iterate over each tuple in the list\n    for tup in tuples_list:\n        # Sort the tuple to handle reverse order equivalence\n        sorted_tup = tuple(sorted(tup))\n        \n        # Check if the sorted tuple is already a key in the dictionary\n        if sorted_tup in occurrences:\n            # Increment the count for this tuple\n            occurrences[sorted_tup] += 1\n        else:\n            # Add the sorted tuple to the dictionary with a count of 1\n            occurrences[sorted_tup] = 1\n    \n    # Return the dictionary with tuple counts\n    return occurrences\n"}
{"task_id": "Mbpp/238", "solution": "\ndef number_of_substrings(s: str) -> int:\n    # Get the length of the string\n    n = len(s)\n    # Initialize the total number of substrings to 0\n    total_substrings = 0\n    # Iterate over each character in the string\n    for i in range(n):\n        # Add the number of substrings starting at position i\n        total_substrings += n - i\n    # Return the total number of non-empty substrings\n    return total_substrings\n"}
{"task_id": "Mbpp/239", "solution": "\ndef count_sequences(current_value, remaining_length, m):\n    # Base case: if no more elements are needed, we have a valid sequence\n    if remaining_length == 0:\n        return 1\n    \n    count = 0\n    # Try all possible next values that are at least twice the current value and <= m\n    next_value = current_value * 2\n    while next_value <= m:\n        count += count_sequences(next_value, remaining_length - 1, m)\n        next_value += 1\n    \n    return count\n\ndef get_total_number_of_sequences(m, n):\n    total_count = 0\n    # Try all possible starting values from 1 to m\n    for starting_value in range(1, m + 1):\n        total_count += count_sequences(starting_value, n - 1, m)\n    \n    return total_count\n"}
{"task_id": "Mbpp/240", "solution": "\ndef replace_list(list1, list2):\n    # Remove the last element from list1\n    list1.pop()\n    # Append all elements of list2 to list1\n    list1.extend(list2)\n    # Return the modified list1\n    return list1\n"}
{"task_id": "Mbpp/242", "solution": "\ndef count_charac(s: str) -> int:\n    # Use the built-in len() function to count the number of characters in the string\n    return len(s)\n"}
{"task_id": "Mbpp/244", "solution": "\ndef next_Perfect_Square(n: int) -> int:\n    # Calculate the square root of n\n    root = n ** 0.5\n    # Round up to the nearest whole number\n    next_root = int(root) + 1 if root % 1 != 0 else int(root) + 1\n    # Calculate the square of the next_root\n    next_square = next_root ** 2\n    # Return the next perfect square\n    return next_square\n"}
{"task_id": "Mbpp/245", "solution": "\ndef max_sum(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    # Initialize the inc and dec arrays\n    inc = [0] * n\n    dec = [0] * n\n\n    # Calculate the inc array\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n\n    # Calculate the dec array\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n\n    # Find the maximum sum of bitonic subsequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n\n    return max_sum\n"}
{"task_id": "Mbpp/247", "solution": "\ndef lps(s: str) -> int:\n    n = len(s)\n    # Create a 2D array to store the length of the longest palindromic subsequence\n    dp = [[0] * n for _ in range(n)]\n\n    # Every single character is a palindrome of length 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Build the table. The outer loop is for the length of the substring\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    # The result is in the top right corner of the table\n    return dp[0][n - 1]\n"}
{"task_id": "Mbpp/250", "solution": "\ndef count_X(tup: tuple, element: int) -> int:\n    # Use the built-in count method to count occurrences of element in tup\n    return tup.count(element)\n"}
{"task_id": "Mbpp/251", "solution": "\ndef insert_element(lst, element):\n    # Initialize an empty list to store the result\n    result = []\n    # Iterate over each item in the input list\n    for item in lst:\n        # Append the given element before the current item\n        result.append(element)\n        # Append the current item\n        result.append(item)\n    # Return the modified list\n    return result\n"}
{"task_id": "Mbpp/252", "solution": "\nimport math\n\ndef convert(z: complex) -> tuple:\n    # Extract the real and imaginary parts of the complex number\n    real_part = z.real\n    imaginary_part = z.imag\n    \n    # Calculate the magnitude (modulus) of the complex number\n    magnitude = math.sqrt(real_part**2 + imaginary_part**2)\n    \n    # Calculate the phase (argument) of the complex number\n    phase = math.atan2(imaginary_part, real_part)\n    \n    # Return the magnitude and phase as a tuple\n    return (magnitude, phase)\n"}
{"task_id": "Mbpp/253", "solution": "\ndef count_integer(lst):\n    # Initialize a counter to keep track of integer elements\n    count = 0\n    # Iterate over each element in the list\n    for element in lst:\n        # Check if the current element is an integer\n        if isinstance(element, int):\n            # Increment the counter if it is an integer\n            count += 1\n    # Return the total count of integer elements\n    return count\n"}
{"task_id": "Mbpp/255", "solution": "\ndef generate_combinations(current_combination, elements, n, result):\n    # If the current combination has reached the desired length, add it to the result\n    if len(current_combination) == n:\n        result.append(tuple(current_combination))\n        return\n    \n    # Iterate over each element in the list\n    for element in elements:\n        # Add the element to the current combination\n        current_combination.append(element)\n        # Recursively generate combinations with the updated combination\n        generate_combinations(current_combination, elements, n, result)\n        # Remove the last element to backtrack\n        current_combination.pop()\n\ndef combinations_colors(elements, n):\n    # Initialize an empty list to store the result\n    result = []\n    # Start the recursive generation of combinations\n    generate_combinations([], elements, n, result)\n    # Return the list of combinations\n    return result\n"}
{"task_id": "Mbpp/256", "solution": "\ndef is_prime(n: int) -> bool:\n    # A number less than 2 is not prime\n    if n < 2:\n        return False\n    # Check divisibility from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef count_Primes_nums(num: int) -> int:\n    # Initialize a counter for prime numbers\n    prime_count = 0\n    # Check each number from 2 to num (exclusive)\n    for i in range(2, num):\n        # If the number is prime, increment the counter\n        if is_prime(i):\n            prime_count += 1\n    # Return the total count of prime numbers found\n    return prime_count\n"}
{"task_id": "Mbpp/257", "solution": "\n# Define the function swap_numbers with two parameters\ndef swap_numbers(num1: int, num2: int) -> tuple:\n    # Create a tuple with the second number first and the first number second\n    result = (num2, num1)\n    # Return the tuple\n    return result\n"}
{"task_id": "Mbpp/259", "solution": "\ndef maximize_elements(tuple1: tuple, tuple2: tuple) -> tuple:\n    # Initialize an empty list to store the result tuples\n    result = []\n    \n    # Iterate over pairs of tuples from the two input tuples\n    for a, b in zip(tuple1, tuple2):\n        # Create a new tuple with the maximum of corresponding elements\n        max_tuple = (max(a[0], b[0]), max(a[1], b[1]))\n        # Append the new tuple to the result list\n        result.append(max_tuple)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "Mbpp/260", "solution": "\ndef newman_prime(n: int) -> int:\n    # Base cases for the sequence\n    if n == 0 or n == 1:\n        return 1\n    \n    # Initialize the first two terms of the sequence\n    a, b = 1, 1\n    \n    # Compute the sequence up to the nth term\n    for _ in range(2, n + 1):\n        # Calculate the next term using the recurrence relation\n        next_term = 2 * b + a\n        # Update the previous two terms\n        a, b = b, next_term\n    \n    # Return the nth term\n    return b\n"}
{"task_id": "Mbpp/261", "solution": "\ndef division_elements(tuple1, tuple2):\n    # Initialize an empty list to store the results of division\n    result = []\n    \n    # Iterate over the indices of the tuples\n    for i in range(len(tuple1)):\n        # Perform element-wise division and append the result to the list\n        result.append(tuple1[i] // tuple2[i])\n    \n    # Convert the list of results to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "Mbpp/262", "solution": "\ndef split_two_parts(lst, L):\n    # Slice the list from the start to L to get the first part\n    first_part = lst[:L]\n    # Slice the list from L to the end to get the second part\n    second_part = lst[L:]\n    # Return the two parts as a tuple\n    return (first_part, second_part)\n"}
{"task_id": "Mbpp/264", "solution": "\ndef dog_age(human_years: int) -> int:\n    # Calculate the conversion factor from human years to dog years\n    conversion_factor = 61 / 12\n    \n    # Calculate the dog's age in dog years using the conversion factor\n    dog_years = human_years * conversion_factor\n    \n    # Return the integer value of the dog's age in dog years\n    return int(dog_years)\n"}
{"task_id": "Mbpp/265", "solution": "\ndef list_split(lst, n):\n    # Initialize the result list to hold the split lists\n    result = []\n    \n    # Loop over each starting index from 0 to n-1\n    for i in range(n):\n        # Create a new list for the current starting index\n        new_list = []\n        \n        # Iterate over the list starting from index i, taking every nth element\n        for j in range(i, len(lst), n):\n            # Add the element to the new list\n            new_list.append(lst[j])\n        \n        # Add the new list to the result\n        result.append(new_list)\n    \n    # Return the list of split lists\n    return result\n"}
{"task_id": "Mbpp/266", "solution": "\ndef lateralsurface_cube(side_length: int) -> int:\n    # Calculate the area of one face of the cube\n    face_area = side_length * side_length\n    # Calculate the lateral surface area by multiplying the face area by 4\n    lateral_surface_area = 4 * face_area\n    # Return the calculated lateral surface area\n    return lateral_surface_area\n"}
{"task_id": "Mbpp/267", "solution": "\ndef square_Sum(n: int) -> int:\n    # Initialize the sum of squares to 0\n    sum_of_squares = 0\n    # Start with the first odd number\n    odd_number = 1\n    # Loop to calculate the sum of squares of the first n odd numbers\n    for _ in range(n):\n        # Add the square of the current odd number to the sum\n        sum_of_squares += odd_number ** 2\n        # Move to the next odd number\n        odd_number += 2\n    # Return the total sum of squares\n    return sum_of_squares\n"}
{"task_id": "Mbpp/268", "solution": "\ndef find_star_num(n: int) -> int:\n    # Calculate the nth star number using the formula\n    # S_n = 6 * n * (n - 1) + 1\n    star_number = 6 * n * (n - 1) + 1\n    return star_number\n"}
{"task_id": "Mbpp/269", "solution": "\ndef ascii_value(c: str) -> int:\n    # Use the ord() function to get the ASCII value of the character\n    return ord(c)\n"}
{"task_id": "Mbpp/270", "solution": "\ndef sum_even_and_even_index(numbers):\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the list with index and value\n    for i, num in enumerate(numbers):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Check if the number is even\n            if num % 2 == 0:\n                # Add the number to the total sum\n                total_sum += num\n    \n    # Return the total sum of even numbers at even indices\n    return total_sum\n"}
{"task_id": "Mbpp/271", "solution": "\ndef even_Power_Sum(n: int) -> int:\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the first n even numbers\n    for i in range(1, n + 1):\n        # Calculate the i-th even number\n        even_number = 2 * i\n        # Raise the even number to the fifth power\n        power_five = even_number ** 5\n        # Add the result to the total sum\n        total_sum += power_five\n    \n    # Return the total sum\n    return total_sum\n"}
{"task_id": "Mbpp/272", "solution": "\ndef rear_extract(tuples_list):\n    # Initialize an empty list to store the last elements of each tuple\n    result = []\n    \n    # Iterate over each tuple in the input list\n    for tup in tuples_list:\n        # Append the last element of the current tuple to the result list\n        result.append(tup[-1])\n    \n    # Return the list containing the last elements of each tuple\n    return result\n"}
{"task_id": "Mbpp/273", "solution": "\ndef substract_elements(tuple1, tuple2):\n    # Initialize an empty list to store the results of the subtractions\n    result = []\n    \n    # Iterate over the indices of the tuples\n    for i in range(len(tuple1)):\n        # Subtract the element of tuple2 from the element of tuple1 at the same index\n        # Append the result to the result list\n        result.append(tuple1[i] - tuple2[i])\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "Mbpp/274", "solution": "\ndef even_binomial_Coeff_Sum(n: int) -> int:\n    # Calculate 2 raised to the power of (n-1)\n    return 2 ** (n - 1)\n"}
{"task_id": "Mbpp/276", "solution": "\ndef volume_cylinder(radius: float, height: float) -> float:\n    # Import the math module to access the value of \u03c0\n    import math\n    \n    # Calculate the volume of the cylinder using the formula: \u03c0 * radius^2 * height\n    volume = math.pi * (radius ** 2) * height\n    \n    # Return the calculated volume\n    return volume\n"}
{"task_id": "Mbpp/277", "solution": "\ndef dict_filter(dictionary: dict, n: int) -> dict:\n    # Initialize an empty dictionary to store the filtered results\n    filtered_dict = {}\n    \n    # Iterate over each key-value pair in the input dictionary\n    for key, value in dictionary.items():\n        # Check if the value is greater than or equal to n\n        if value >= n:\n            # Add the key-value pair to the filtered dictionary\n            filtered_dict[key] = value\n    \n    # Return the filtered dictionary\n    return filtered_dict\n"}
{"task_id": "Mbpp/278", "solution": "\ndef count_first_elements(input_tuple):\n    # Initialize a counter to keep track of the number of elements before a tuple\n    counter = 0\n    \n    # Iterate over each element in the input tuple\n    for element in input_tuple:\n        # Check if the current element is a tuple\n        if isinstance(element, tuple):\n            # If it is a tuple, return the current count\n            return counter\n        # Increment the counter for each non-tuple element\n        counter += 1\n    \n    # If no tuple is found, return the total count of elements\n    return counter\n"}
{"task_id": "Mbpp/279", "solution": "\ndef is_num_decagonal(n: int) -> int:\n    # Calculate the nth decagonal number using the formula: D_n = 4 * n^2 - 3 * n\n    decagonal_number = 4 * n * n - 3 * n\n    # Return the calculated decagonal number\n    return decagonal_number\n"}
{"task_id": "Mbpp/280", "solution": "\ndef sequential_search(array, element):\n    # Iterate over the array with both index and value\n    for index, value in enumerate(array):\n        # Check if the current value matches the element we are searching for\n        if value == element:\n            # If found, return True and the current index\n            return (True, index)\n    # If the loop completes without finding the element, return False and -1\n    return (False, -1)\n"}
{"task_id": "Mbpp/281", "solution": "\ndef all_unique(lst):\n    # Convert the list to a set, which will remove any duplicate elements\n    unique_elements = set(lst)\n    \n    # Compare the length of the set with the length of the list\n    # If they are equal, it means all elements in the list were unique\n    return len(unique_elements) == len(lst)\n"}
{"task_id": "Mbpp/282", "solution": "\ndef sub_list(list1, list2):\n    # Initialize an empty list to store the results of the subtraction\n    result = []\n    # Iterate over the indices of the input lists\n    for i in range(len(list1)):\n        # Subtract the element in list2 from the element in list1 at the same index\n        # Append the result to the result list\n        result.append(list1[i] - list2[i])\n    # Return the list containing the results of the element-wise subtraction\n    return result\n"}
{"task_id": "Mbpp/283", "solution": "\ndef validate(n: int) -> bool:\n    # Convert the integer to a string to iterate over each digit\n    str_n = str(n)\n    \n    # Initialize a dictionary to count the frequency of each digit\n    digit_count = {}\n    \n    # Count the frequency of each digit\n    for char in str_n:\n        digit = int(char)\n        if digit not in digit_count:\n            digit_count[digit] = 0\n        digit_count[digit] += 1\n    \n    # Check if the frequency of each digit is less than or equal to the digit itself\n    for digit, count in digit_count.items():\n        if count > digit:\n            return False\n    \n    # If all conditions are satisfied, return True\n    return True\n"}
{"task_id": "Mbpp/284", "solution": "\ndef check_element(lst, element):\n    # Iterate over each item in the list\n    for item in lst:\n        # If the current item is not equal to the specified element\n        if item != element:\n            # Return False immediately\n            return False\n    # If all items are equal to the element, return True\n    return True\n"}
{"task_id": "Mbpp/285", "solution": "\ndef text_match_two_three(s: str) -> bool:\n    # Iterate through the string, checking for the patterns \"abb\" or \"abbb\"\n    for i in range(len(s) - 2):\n        # Check for \"abb\"\n        if s[i:i+3] == \"abb\":\n            return True\n        # Check for \"abbb\", ensure we don't go out of bounds\n        if i < len(s) - 3 and s[i:i+4] == \"abbb\":\n            return True\n    # If neither pattern is found, return False\n    return False\n"}
{"task_id": "Mbpp/286", "solution": "\ndef kadane(arr):\n    # Initialize variables for Kadane's algorithm\n    max_ending_here = max_so_far = arr[0]\n    for x in arr[1:]:\n        # Update the maximum sum of subarray ending at the current position\n        max_ending_here = max(x, max_ending_here + x)\n        # Update the overall maximum sum found so far\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n\ndef max_sub_array_sum_repeated(arr, n, k):\n    # Find the maximum subarray sum using Kadane's algorithm\n    max_sum = kadane(arr)\n    \n    # If the array is repeated only once, return the result of Kadane's algorithm\n    if k == 1:\n        return max_sum\n    \n    # Calculate the total sum of the array\n    total_sum = sum(arr)\n    \n    # Calculate the maximum prefix sum\n    prefix_sum = 0\n    max_prefix_sum = float('-inf')\n    for i in range(n):\n        prefix_sum += arr[i]\n        max_prefix_sum = max(max_prefix_sum, prefix_sum)\n    \n    # Calculate the maximum suffix sum\n    suffix_sum = 0\n    max_suffix_sum = float('-inf')\n    for i in range(n-1, -1, -1):\n        suffix_sum += arr[i]\n        max_suffix_sum = max(max_suffix_sum, suffix_sum)\n    \n    # If the total sum is positive, consider the contribution of the middle parts\n    if total_sum > 0:\n        return max(max_sum, max_prefix_sum + max_suffix_sum + (k-2) * total_sum)\n    else:\n        return max(max_sum, max_prefix_sum + max_suffix_sum)\n"}
{"task_id": "Mbpp/287", "solution": "\ndef square_Sum(n: int) -> int:\n    # Initialize the sum of squares to 0\n    sum_of_squares = 0\n    \n    # Loop through the first n even numbers\n    for i in range(1, n + 1):\n        # Calculate the i-th even number\n        even_number = 2 * i\n        # Add the square of the even number to the sum\n        sum_of_squares += even_number ** 2\n    \n    # Return the total sum of squares\n    return sum_of_squares\n"}
{"task_id": "Mbpp/290", "solution": "\ndef max_length(list_of_lists):\n    # Initialize variables to keep track of the maximum length and the longest list\n    max_len = 0\n    longest_list = []\n    \n    # Iterate through each list in the list of lists\n    for lst in list_of_lists:\n        # Check if the current list is longer than the current maximum length\n        if len(lst) > max_len:\n            # Update the maximum length and the longest list\n            max_len = len(lst)\n            longest_list = lst\n    \n    # Return a tuple containing the maximum length and the longest list\n    return (max_len, longest_list)\n"}
{"task_id": "Mbpp/292", "solution": "\ndef find(a: int, b: int) -> int:\n    # Use integer division to find the quotient of a divided by b\n    # The // operator performs division and rounds down to the nearest integer\n    return a // b\n"}
{"task_id": "Mbpp/293", "solution": "\ndef otherside_rightangle(side1: float, side2: float) -> float:\n    # Calculate the hypotenuse if both sides are legs\n    hypotenuse = (side1**2 + side2**2) ** 0.5\n    \n    # Return the length of the hypotenuse\n    return hypotenuse\n"}
{"task_id": "Mbpp/294", "solution": "\ndef max_val(lst):\n    # Step 1: Filter out only the numerical values from the list\n    numerical_values = [x for x in lst if isinstance(x, int)]\n    \n    # Step 2: Find the maximum value among the numerical values\n    max_value = max(numerical_values)\n    \n    # Step 3: Return the maximum value\n    return max_value\n"}
{"task_id": "Mbpp/296", "solution": "\ndef merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0\n\n    # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right\n    while i <= mid and j <= right:\n        if arr[i] <= arr[j]:\n            temp_arr[k] = arr[i]\n            i += 1\n        else:\n            # There are mid - i inversions, because all elements left to i in the left subarray\n            # are greater than arr[j]\n            temp_arr[k] = arr[j]\n            inv_count += (mid - i + 1)\n            j += 1\n        k += 1\n\n    # Copy the remaining elements of left subarray, if any\n    while i <= mid:\n        temp_arr[k] = arr[i]\n        i += 1\n        k += 1\n\n    # Copy the remaining elements of right subarray, if any\n    while j <= right:\n        temp_arr[k] = arr[j]\n        j += 1\n        k += 1\n\n    # Copy the sorted subarray into Original array\n    for i in range(left, right + 1):\n        arr[i] = temp_arr[i]\n\n    return inv_count\n\ndef merge_sort_and_count(arr, temp_arr, left, right):\n    inv_count = 0\n    if left < right:\n        mid = (left + right) // 2\n\n        inv_count += merge_sort_and_count(arr, temp_arr, left, mid)\n        inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right)\n        inv_count += merge_and_count(arr, temp_arr, left, mid, right)\n\n    return inv_count\n\ndef get_Inv_Count(arr):\n    temp_arr = [0] * len(arr)\n    return merge_sort_and_count(arr, temp_arr, 0, len(arr) - 1)\n"}
{"task_id": "Mbpp/297", "solution": "\ndef flatten_list(nested_list):\n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n    \n    # Iterate over each element in the input list\n    for element in nested_list:\n        # If the element is a list, recursively flatten it and extend the flat_list\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        # If the element is not a list, append it directly to the flat_list\n        else:\n            flat_list.append(element)\n    \n    # Return the fully flattened list\n    return flat_list\n"}
{"task_id": "Mbpp/299", "solution": "\ndef max_aggregate(tuples):\n    # Initialize a dictionary to store the total scores for each name\n    score_dict = {}\n\n    # Iterate over each tuple in the list\n    for name, score in tuples:\n        # If the name is already in the dictionary, add the score to the existing total\n        if name in score_dict:\n            score_dict[name] += score\n        # If the name is not in the dictionary, initialize it with the current score\n        else:\n            score_dict[name] = score\n\n    # Initialize variables to track the name with the maximum score\n    max_name = None\n    max_score = 0\n\n    # Iterate over the dictionary to find the name with the highest total score\n    for name, total_score in score_dict.items():\n        if total_score > max_score:\n            max_score = total_score\n            max_name = name\n\n    # Return the name with the highest score and the score itself\n    return (max_name, max_score)\n"}
{"task_id": "Mbpp/3", "solution": "\ndef is_not_prime(n: int) -> bool:\n    # Numbers less than 2 are not prime\n    if n < 2:\n        return True\n    \n    # Check for divisors from 2 to the square root of n\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True  # n is not prime if it has a divisor other than 1 and itself\n    \n    return False  # n is prime if no divisors are found\n"}
{"task_id": "Mbpp/300", "solution": "\ndef factorial(x):\n    # Calculate the factorial of x\n    result = 1\n    for i in range(2, x + 1):\n        result *= i\n    return result\n\ndef binomial_coefficient(n, k):\n    # Calculate the binomial coefficient C(n, k)\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef count_binary_seq(n):\n    # Initialize the total count of valid sequences\n    total_count = 0\n    # Iterate over all possible numbers of 1s in the first half\n    for k in range(n + 1):\n        # Calculate the number of ways to choose k 1s in the first half\n        count_k = binomial_coefficient(n, k)\n        # Add the square of this count to the total count\n        total_count += count_k * count_k\n    # Return the total count of valid sequences\n    return total_count\n"}
{"task_id": "Mbpp/301", "solution": "\ndef dict_depth(d: dict) -> int:\n    # Base case: if the input is not a dictionary, return 0\n    if not isinstance(d, dict):\n        return 0\n    \n    # Initialize the maximum depth to 1 (the current level)\n    max_depth = 1\n    \n    # Iterate over each key-value pair in the dictionary\n    for key, value in d.items():\n        # If the value is a dictionary, calculate its depth recursively\n        if isinstance(value, dict):\n            # Add 1 to the depth to account for the current level\n            depth = 1 + dict_depth(value)\n            # Update the maximum depth found so far\n            max_depth = max(max_depth, depth)\n    \n    # Return the maximum depth found\n    return max_depth\n"}
{"task_id": "Mbpp/305", "solution": "\ndef start_withp(words_list):\n    # Initialize an empty list to store words starting with 'P'\n    result = []\n    \n    # Iterate over each string in the list\n    for sentence in words_list:\n        # Split the string into individual words\n        words = sentence.split()\n        \n        # Check each word\n        for word in words:\n            # If the word starts with 'P', add it to the result list\n            if word.startswith('P'):\n                result.append(word)\n                # If we have found two words, return them as a tuple\n                if len(result) == 2:\n                    return (result[0], result[1])\n    \n    # If less than two words are found, return the available ones\n    return tuple(result)\n"}
{"task_id": "Mbpp/306", "solution": "\ndef max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize dp array to store the maximum sum of increasing subsequences ending at each index\n    dp = [0] * (i + 1)\n    # Variable to keep track of the maximum sum found\n    max_sum = 0\n    \n    # Iterate over each index from 0 to i\n    for j in range(i + 1):\n        # Start with the current element as the sum of the subsequence ending at j\n        dp[j] = arr[j]\n        # Check all previous elements to see if they can form an increasing subsequence with arr[j]\n        for m in range(j):\n            if arr[m] < arr[j]:\n                # Update dp[j] to the maximum sum of subsequences ending at j\n                dp[j] = max(dp[j], dp[m] + arr[j])\n        # If the current subsequence can be extended by including arr[k], update max_sum\n        if arr[j] < arr[k]:\n            max_sum = max(max_sum, dp[j] + arr[k])\n    \n    # Return the maximum sum found\n    return max_sum\n"}
{"task_id": "Mbpp/308", "solution": "\ndef large_product(list1, list2, n):\n    # Initialize an empty list to store products\n    products = []\n    \n    # Generate all possible products\n    for a in list1:\n        for b in list2:\n            products.append(a * b)\n    \n    # Sort the products in descending order\n    products.sort(reverse=True)\n    \n    # Return the first n elements\n    return products[:n]\n"}
{"task_id": "Mbpp/309", "solution": "\ndef maximum(a: int, b: int) -> int:\n    # Compare the two numbers\n    if a >= b:\n        # If a is greater than or equal to b, return a\n        return a\n    else:\n        # Otherwise, return b\n        return b\n"}
{"task_id": "Mbpp/310", "solution": "\ndef string_to_tuple(s: str) -> tuple:\n    # Convert the string s into a tuple, excluding spaces\n    result = tuple(char for char in s if char != ' ')\n    # Return the resulting tuple\n    return result\n"}
{"task_id": "Mbpp/311", "solution": "\ndef set_left_most_unset_bit(n: int) -> int:\n    # Determine the number of bits required to represent the number\n    num_bits = n.bit_length()\n    \n    # Start scanning from the most significant bit to the least significant bit\n    for position in range(num_bits - 1, -1, -1):\n        # Check if the bit at the current position is unset (0)\n        if (n & (1 << position)) == 0:\n            # Set the bit at the current position and return the new number\n            return n | (1 << position)\n    \n    # If all bits are set, set the next higher bit\n    return n | (1 << num_bits)\n"}
{"task_id": "Mbpp/312", "solution": "\ndef volume_cone(radius: float, height: float) -> float:\n    # Import the math module to access the value of pi\n    import math\n    \n    # Calculate the volume of the cone using the formula (1/3) * pi * r^2 * h\n    volume = (1/3) * math.pi * radius**2 * height\n    \n    # Return the calculated volume\n    return volume\n"}
{"task_id": "Mbpp/388", "solution": "\ndef highest_Power_of_2(n: int) -> int:\n    # Start with the smallest power of 2, which is 1 (2^0)\n    power = 1\n    \n    # Double the power until it exceeds n\n    while power <= n:\n        power *= 2\n    \n    # The loop exits when power is greater than n, so we divide by 2 to get the last valid power of 2\n    power //= 2\n    \n    # Return the highest power of 2 less than or equal to n\n    return power\n"}
{"task_id": "Mbpp/389", "solution": "\ndef find_lucas(n: int) -> int:\n    # Base cases for the first two Lucas numbers\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    \n    # Initialize the first two Lucas numbers\n    previous = 2\n    current = 1\n    \n    # Calculate the nth Lucas number iteratively\n    for i in range(2, n + 1):\n        next_lucas = previous + current\n        previous = current\n        current = next_lucas\n    \n    return current\n"}
{"task_id": "Mbpp/390", "solution": "\ndef add_string(elements, format_str):\n    # Initialize an empty list to store the formatted strings\n    formatted_list = []\n    \n    # Iterate over each element in the input list\n    for element in elements:\n        # Apply the format string to the current element and append to the formatted list\n        formatted_list.append(format_str.format(element))\n    \n    # Return the list of formatted strings\n    return formatted_list\n"}
{"task_id": "Mbpp/391", "solution": "\ndef convert_list_dictionary(ids, names, scores):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the indices of the input lists\n    for i in range(len(ids)):\n        # Create a nested dictionary for each set of id, name, and score\n        nested_dict = {ids[i]: {names[i]: scores[i]}}\n        # Append the nested dictionary to the result list\n        result.append(nested_dict)\n    \n    # Return the list of nested dictionaries\n    return result\n"}
{"task_id": "Mbpp/392", "solution": "\ndef get_max_sum(n: int) -> int:\n    # Dictionary to store computed values of f(n) for memoization\n    memo = {}\n    \n    # Helper function to compute f(x) using recursion and memoization\n    def f(x: int) -> int:\n        # If the value is already computed, return it\n        if x in memo:\n            return memo[x]\n        # Base case: if x is 0, return 0\n        if x == 0:\n            return 0\n        # Calculate the sum of f(x//2), f(x//3), f(x//4), and f(x//5)\n        sum_parts = f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5)\n        # The result is the maximum of sum_parts and x\n        result = max(sum_parts, x)\n        # Store the result in the memo dictionary\n        memo[x] = result\n        return result\n    \n    # Return the result of f(n)\n    return f(n)\n"}
{"task_id": "Mbpp/394", "solution": "\ndef check_distinct(t: tuple) -> bool:\n    # Convert the tuple to a set, which removes duplicates\n    unique_elements = set(t)\n    # Compare the length of the set with the length of the tuple\n    # If they are the same, it means there are no duplicates\n    return len(unique_elements) == len(t)\n"}
{"task_id": "Mbpp/395", "solution": "\ndef first_non_repeating_character(s: str) -> str:\n    # Initialize a dictionary to store the count of each character\n    char_count = {}\n    \n    # First pass: count the occurrences of each character\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    # Second pass: find the first character with a count of 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    # If no non-repeating character is found, return None\n    return None\n"}
{"task_id": "Mbpp/397", "solution": "\ndef median_numbers(a: int, b: int, c: int) -> float:\n    # Create a list of the three numbers\n    numbers = [a, b, c]\n    # Sort the list\n    numbers.sort()\n    # Return the second element of the sorted list as a float, which is the median\n    return float(numbers[1])\n"}
{"task_id": "Mbpp/398", "solution": "\ndef sum_of_digits(numbers):\n    # Initialize the total sum of digits to 0\n    total_sum = 0\n    \n    # Iterate over each number in the list\n    for number in numbers:\n        # Convert the number to a string to access each digit\n        for digit in str(number):\n            # Convert the character back to an integer and add to total sum\n            total_sum += int(digit)\n    \n    # Return the total sum of all digits\n    return total_sum\n"}
{"task_id": "Mbpp/4", "solution": "\ndef heap_queue_largest(numbers, n):\n    # Sort the list in descending order\n    sorted_numbers = sorted(numbers, reverse=True)\n    # Select the first 'n' elements from the sorted list\n    largest_numbers = sorted_numbers[:n]\n    # Return the selected elements\n    return largest_numbers\n"}
{"task_id": "Mbpp/404", "solution": "\ndef minimum(a: int, b: int) -> int:\n    # Compare the two numbers\n    if a <= b:\n        # If a is less than or equal to b, return a\n        return a\n    else:\n        # Otherwise, return b\n        return b\n"}
{"task_id": "Mbpp/405", "solution": "\ndef check_tuplex(tuple_data, element):\n    # Use the 'in' keyword to check if the element exists in the tuple\n    return element in tuple_data\n"}
{"task_id": "Mbpp/406", "solution": "\ndef find_Parity(number: int) -> bool:\n    # Check if the number is odd by using the modulus operator\n    # If the remainder when divided by 2 is 1, the number is odd\n    if number % 2 == 1:\n        return True\n    else:\n        return False\n"}
{"task_id": "Mbpp/409", "solution": "\ndef min_product_tuple(list_of_tuples):\n    # Initialize min_product with a very large number\n    min_product = float('inf')\n    \n    # Iterate through each tuple in the list\n    for a, b in list_of_tuples:\n        # Calculate the product of the two numbers in the tuple\n        product = a * b\n        \n        # If the calculated product is less than the current min_product, update min_product\n        if product < min_product:\n            min_product = product\n    \n    # Return the smallest product found\n    return min_product\n"}
{"task_id": "Mbpp/410", "solution": "\ndef min_val(lst):\n    # Initialize min_value to a very large number\n    min_value = float('inf')\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # Check if the element is an integer\n        if isinstance(element, int):\n            # If the element is less than the current min_value, update min_value\n            if element < min_value:\n                min_value = element\n    \n    # Return the smallest integer found\n    return min_value\n"}
{"task_id": "Mbpp/412", "solution": "\ndef remove_odd(numbers):\n    # Initialize an empty list to store even numbers\n    even_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is even\n        if number % 2 == 0:\n            # If even, append it to the even_numbers list\n            even_numbers.append(number)\n    \n    # Return the list of even numbers\n    return even_numbers\n"}
{"task_id": "Mbpp/413", "solution": "\ndef extract_nth_element(list_of_tuples, n):\n    # Initialize an empty list to store the nth elements\n    result = []\n    \n    # Iterate over each tuple in the list\n    for tuple_item in list_of_tuples:\n        # Append the nth element of the current tuple to the result list\n        result.append(tuple_item[n])\n    \n    # Return the list of nth elements\n    return result\n"}
{"task_id": "Mbpp/414", "solution": "\ndef overlapping(seq1, seq2):\n    # Iterate over each element in the first sequence\n    for element in seq1:\n        # Check if the current element is present in the second sequence\n        if element in seq2:\n            # If a common element is found, return True\n            return True\n    # If no common elements are found, return False\n    return False\n"}
{"task_id": "Mbpp/415", "solution": "\ndef max_Product(arr):\n    # Step 1: Sort the array in ascending order\n    arr.sort()\n    \n    # Step 2: Select the last two elements from the sorted array\n    # These are the two largest numbers in the array\n    num1 = arr[-1]\n    num2 = arr[-2]\n    \n    # Step 3: Return the pair as a tuple\n    return (num2, num1)\n"}
{"task_id": "Mbpp/418", "solution": "\ndef Find_Max(lists):\n    # Initialize max_list to the first list in the input\n    max_list = lists[0]\n    \n    # Iterate through each list in the input list of lists\n    for lst in lists:\n        # If the current list's length is greater than the length of max_list\n        if len(lst) > len(max_list):\n            # Update max_list to be the current list\n            max_list = lst\n    \n    # Return the list with the maximum length\n    return max_list\n"}
{"task_id": "Mbpp/419", "solution": "\ndef round_and_sum(numbers):\n    # Initialize a variable to store the sum of rounded numbers\n    rounded_sum = 0\n    \n    # Iterate over each number in the list\n    for number in numbers:\n        # Round the number to the nearest integer and add it to the sum\n        rounded_sum += round(number)\n    \n    # Calculate the length of the list\n    length_of_list = len(numbers)\n    \n    # Multiply the sum of rounded numbers by the length of the list\n    result = rounded_sum * length_of_list\n    \n    # Return the final result\n    return result\n"}
{"task_id": "Mbpp/420", "solution": "\ndef cube_Sum(n: int) -> int:\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the first n even natural numbers\n    for i in range(1, n + 1):\n        # Calculate the i-th even number\n        even_number = 2 * i\n        # Calculate the cube of the even number\n        cube = even_number ** 3\n        # Add the cube to the total sum\n        total_sum += cube\n    \n    # Return the total sum of cubes\n    return total_sum\n"}
{"task_id": "Mbpp/421", "solution": "\ndef concatenate_tuple(elements: tuple) -> str:\n    # Convert each element in the tuple to a string\n    string_elements = map(str, elements)\n    # Join the string elements with a hyphen as the delimiter\n    result = '-'.join(string_elements)\n    # Return the concatenated string\n    return result\n"}
{"task_id": "Mbpp/422", "solution": "\ndef find_Average_Of_Cube(n: int) -> float:\n    # Initialize the sum of cubes to 0\n    sum_of_cubes = 0\n    \n    # Loop through each number from 1 to n\n    for i in range(1, n + 1):\n        # Add the cube of the current number to the sum\n        sum_of_cubes += i ** 3\n    \n    # Calculate the average by dividing the sum of cubes by n\n    average = sum_of_cubes / n\n    \n    # Return the calculated average\n    return average\n"}
{"task_id": "Mbpp/424", "solution": "\ndef extract_rear(strings: tuple) -> list:\n    # Initialize an empty list to store the last characters\n    rear_elements = []\n    \n    # Iterate over each string in the tuple\n    for string in strings:\n        # Append the last character of the current string to the list\n        rear_elements.append(string[-1])\n    \n    # Return the list of last characters\n    return rear_elements\n"}
{"task_id": "Mbpp/425", "solution": "\ndef count_element_in_list(list_of_lists, element):\n    # Initialize a counter to keep track of sublists containing the element\n    count = 0\n    \n    # Iterate over each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Check if the element is present in the current sublist\n        if element in sublist:\n            # Increment the counter if the element is found\n            count += 1\n    \n    # Return the total count of sublists containing the element\n    return count\n"}
{"task_id": "Mbpp/426", "solution": "\ndef filter_oddnumbers(numbers):\n    # Create an empty list to store odd numbers\n    odd_numbers = []\n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is odd\n        if number % 2 != 0:\n            # If odd, append it to the odd_numbers list\n            odd_numbers.append(number)\n    # Return the list of odd numbers\n    return odd_numbers\n"}
{"task_id": "Mbpp/427", "solution": "\ndef change_date_format(date: str) -> str:\n    # Split the input date string into year, month, and day\n    parts = date.split('-')\n    \n    # Rearrange the parts to the order: day, month, year\n    new_format = [parts[2], parts[1], parts[0]]\n    \n    # Join the rearranged parts with hyphens to form the new date string\n    result = '-'.join(new_format)\n    \n    # Return the new date string\n    return result\n"}
{"task_id": "Mbpp/428", "solution": "\ndef shell_sort(arr):\n    # Get the length of the array\n    n = len(arr)\n    # Initialize the gap size\n    gap = n // 2\n    \n    # Continue the process until the gap is reduced to 0\n    while gap > 0:\n        # Perform a gapped insertion sort for this gap size\n        for i in range(gap, n):\n            # Store the current element in a temporary variable\n            temp = arr[i]\n            # Initialize j to the current index\n            j = i\n            # Shift earlier gap-sorted elements up until the correct location for arr[i] is found\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            # Place the temp element at its correct position\n            arr[j] = temp\n        # Reduce the gap for the next iteration\n        gap //= 2\n    \n    # Return the sorted array\n    return arr\n"}
{"task_id": "Mbpp/429", "solution": "\ndef and_tuples(tuple1, tuple2):\n    # Initialize an empty list to store the results of the bitwise AND operations\n    result = []\n    \n    # Iterate over the indices of the tuples\n    for i in range(len(tuple1)):\n        # Perform bitwise AND on the elements at the current index from both tuples\n        and_result = tuple1[i] & tuple2[i]\n        \n        # Append the result to the list\n        result.append(and_result)\n    \n    # Convert the list of results to a tuple\n    return tuple(result)\n"}
{"task_id": "Mbpp/430", "solution": "\ndef parabola_directrix(a: int, b: int, c: int) -> int:\n    # Calculate the vertex's y-coordinate (k)\n    k = c - (b**2 / (4 * a))\n    \n    # Calculate the directrix using the formula: y = k - (1 / (4 * a))\n    directrix = k - (1 / (4 * a))\n    \n    # Return the directrix as an integer\n    return int(directrix)\n"}
{"task_id": "Mbpp/432", "solution": "\ndef median_trapezium(base1: int, base2: int, height: int) -> int:\n    # Calculate the median length of the trapezium\n    # The median is the average of the two parallel sides (bases)\n    median_length = (base1 + base2) / 2\n    # Return the median length\n    return median_length\n"}
{"task_id": "Mbpp/433", "solution": "\ndef check_greater(arr, num):\n    # Iterate over each element in the array\n    for element in arr:\n        # If any element is greater than or equal to the given number\n        if element >= num:\n            # Return False because the number is not greater than all elements\n            return False\n    # If no element is greater than or equal to the number, return True\n    return True\n"}
{"task_id": "Mbpp/435", "solution": "\ndef last_Digit(number: int) -> int:\n    # Use the modulus operator to find the last digit of the number\n    return number % 10\n"}
{"task_id": "Mbpp/436", "solution": "\ndef neg_nos(numbers):\n    # Create an empty list to store negative numbers\n    negative_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is negative\n        if number < 0:\n            # Add the negative number to the list\n            negative_numbers.append(number)\n    \n    # Return the list of negative numbers\n    return negative_numbers\n"}
{"task_id": "Mbpp/437", "solution": "\ndef remove_odd(s: str) -> str:\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over the string with index\n    for i in range(len(s)):\n        # Check if the index is odd\n        if i % 2 != 0:\n            # Append the character at the odd index to the result\n            result += s[i]\n    \n    # Return the final result string\n    return result\n"}
{"task_id": "Mbpp/439", "solution": "\ndef multiple_to_single(numbers):\n    # Convert each number to a string and join them together\n    concatenated_string = ''.join(str(number) for number in numbers)\n    # Convert the concatenated string back to an integer\n    result = int(concatenated_string)\n    return result\n"}
{"task_id": "Mbpp/440", "solution": "\ndef find_adverb_position(sentence: str) -> tuple:\n    # Initialize the current index to track position in the sentence\n    current_index = 0\n    length = len(sentence)\n    \n    # Iterate over the sentence manually to handle punctuation\n    while current_index < length:\n        # Find the start of the next word\n        while current_index < length and not sentence[current_index].isalpha():\n            current_index += 1\n        \n        # If we reach the end of the sentence, break\n        if current_index >= length:\n            break\n        \n        # Find the end of the current word\n        start_index = current_index\n        while current_index < length and (sentence[current_index].isalpha() or sentence[current_index] in \"-'\"):\n            current_index += 1\n        \n        # Extract the word and strip punctuation from the end\n        word = sentence[start_index:current_index].rstrip('!.,?')\n        \n        # Check if the word ends with 'ly'\n        if word.endswith('ly'):\n            # Return the tuple with start index, end index, and the adverb\n            return (start_index, current_index, word)\n        \n        # Move past any trailing punctuation or spaces\n        while current_index < length and not sentence[current_index].isalpha():\n            current_index += 1\n    \n    # If no adverb is found, return None\n    return None\n"}
{"task_id": "Mbpp/441", "solution": "\ndef surfacearea_cube(side_length: int) -> int:\n    # Calculate the area of one face of the cube\n    face_area = side_length * side_length\n    # Calculate the total surface area by multiplying the face area by 6\n    total_surface_area = 6 * face_area\n    # Return the total surface area\n    return total_surface_area\n"}
{"task_id": "Mbpp/445", "solution": "\ndef index_multiplication(tuple1, tuple2):\n    # Initialize an empty list to store the result tuples\n    result = []\n    \n    # Iterate over the pairs of tuples from the two input tuples\n    for (a, b) in zip(tuple1, tuple2):\n        # Multiply the corresponding elements and create a new tuple\n        multiplied_tuple = (a[0] * b[0], a[1] * b[1])\n        # Append the new tuple to the result list\n        result.append(multiplied_tuple)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "Mbpp/446", "solution": "\ndef count_Occurrence(tup: tuple, lst: list) -> int:\n    # Initialize a counter to keep track of occurrences\n    count = 0\n    \n    # Iterate over each element in the tuple\n    for element in tup:\n        # Check if the current element is in the list\n        if element in lst:\n            # Increment the counter if the element is found in the list\n            count += 1\n    \n    # Return the total count of occurrences\n    return count\n"}
{"task_id": "Mbpp/447", "solution": "\ndef cube_nums(nums):\n    # Initialize an empty list to store the cubes of the numbers\n    cubes = []\n    # Iterate over each number in the input list\n    for num in nums:\n        # Compute the cube of the current number\n        cube = num ** 3\n        # Append the cube to the list of cubes\n        cubes.append(cube)\n    # Return the list of cubes\n    return cubes\n"}
{"task_id": "Mbpp/448", "solution": "\ndef cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 3\n    if n == 2:\n        return 3 + 0\n    \n    # Initialize the first three terms\n    P0 = 3\n    P1 = 0\n    P2 = 2\n    sum = P0 + P1 + P2\n    \n    # Generate terms from P3 to P(n-1)\n    for i in range(3, n):\n        Pn = P1 + P0\n        sum += Pn\n        # Update previous terms\n        P0 = P1\n        P1 = P2\n        P2 = Pn\n    \n    return sum\n\n\ndef cal_sum(n: int) -> int:\n    if n == 0:\n        return 0\n    if n == 1:\n        return 3\n    if n == 2:\n        return 3 + 0\n    \n    # Initialize the first three terms\n    P0 = 3\n    P1 = 0\n    P2 = 2\n    sum = P0 + P1 + P2\n    \n    # Generate terms from P3 to P(n-1)\n    for i in range(3, n):\n        Pn = P1 + P0\n        sum += Pn\n        # Update previous terms\n        P0 = P1\n        P1 = P2\n        P2 = Pn\n    \n    return sum\n"}
{"task_id": "Mbpp/450", "solution": "\ndef extract_string(strings: list, size: int) -> list:\n    # Initialize an empty list to store strings of the specified length\n    result = []\n    \n    # Iterate over each string in the input list\n    for string in strings:\n        # Check if the length of the string matches the specified size\n        if len(string) == size:\n            # Add the string to the result list\n            result.append(string)\n    \n    # Return the list of strings that have the specified length\n    return result\n"}
{"task_id": "Mbpp/451", "solution": "\ndef remove_whitespaces(input_string: str) -> str:\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the input string\n    for char in input_string:\n        # Check if the character is not a whitespace\n        if not char.isspace():\n            # Append the character to the result string\n            result += char\n    \n    # Return the result string with all whitespaces removed\n    return result\n"}
{"task_id": "Mbpp/453", "solution": "\ndef sumofFactors(n: int) -> int:\n    # Initialize the sum of even factors to 0\n    sum_even_factors = 0\n    \n    # Iterate over all numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a factor of n\n        if n % i == 0:\n            # Check if the factor is even\n            if i % 2 == 0:\n                # Add the even factor to the sum\n                sum_even_factors += i\n    \n    # Return the total sum of even factors\n    return sum_even_factors\n"}
{"task_id": "Mbpp/454", "solution": "\ndef text_match_wordz(input_string: str) -> bool:\n    # Iterate over each character in the input string\n    for char in input_string:\n        # Check if the current character is 'z'\n        if char == 'z':\n            # If 'z' is found, return True\n            return True\n    # If no 'z' is found after checking all characters, return False\n    return False\n"}
{"task_id": "Mbpp/455", "solution": "\ndef check_monthnumb_number(month_number: int) -> bool:\n    # Set of month numbers that have 31 days\n    months_with_31_days = {1, 3, 5, 7, 8, 10, 12}\n    \n    # Check if the given month number is in the set\n    return month_number in months_with_31_days\n"}
{"task_id": "Mbpp/456", "solution": "\ndef reverse_string_list(strings: list) -> list:\n    # Initialize an empty list to store the reversed strings\n    reversed_strings = []\n    \n    # Iterate over each string in the input list\n    for string in strings:\n        # Reverse the current string and append it to the reversed_strings list\n        reversed_strings.append(string[::-1])\n    \n    # Return the list of reversed strings\n    return reversed_strings\n"}
{"task_id": "Mbpp/457", "solution": "\ndef Find_Min(sublists):\n    # Initialize min_length to a large number\n    min_length = float('inf')\n    # Initialize min_sublist to None\n    min_sublist = None\n\n    # Iterate through each sublist in the list of sublists\n    for sublist in sublists:\n        # If the length of the current sublist is less than min_length\n        if len(sublist) < min_length:\n            # Update min_length to the length of the current sublist\n            min_length = len(sublist)\n            # Update min_sublist to the current sublist\n            min_sublist = sublist\n\n    # Return the sublist with the minimum length\n    return min_sublist\n"}
{"task_id": "Mbpp/458", "solution": "\n# Define the function rectangle_area with parameters length and width\ndef rectangle_area(length: int, width: int) -> int:\n    # Calculate the area by multiplying length and width\n    area = length * width\n    # Return the calculated area\n    return area\n"}
{"task_id": "Mbpp/459", "solution": "\ndef remove_uppercase(s: str) -> str:\n    # Initialize an empty result string\n    result = []\n    # Flag to track if we are in an uppercase substring\n    in_uppercase = False\n\n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Set the flag to indicate we are in an uppercase substring\n            in_uppercase = True\n        else:\n            # If we were in an uppercase substring, reset the flag\n            if in_uppercase:\n                in_uppercase = False\n            # Append the lowercase character to the result\n            result.append(char)\n\n    # Join the list into a string and return it\n    return ''.join(result)\n"}
{"task_id": "Mbpp/460", "solution": "\ndef Extract(list_of_lists):\n    # Initialize an empty list to store the first elements\n    first_elements = []\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in list_of_lists:\n        # Append the first element of the current sublist to the first_elements list\n        first_elements.append(sublist[0])\n    \n    # Return the list of first elements\n    return first_elements\n"}
{"task_id": "Mbpp/462", "solution": "\ndef generate_combinations(elements, start):\n    # Base case: if start index is at the end of the list, return a list with an empty list\n    if start == len(elements):\n        return [[]]\n    \n    # Get all combinations from the next index\n    smaller_combinations = generate_combinations(elements, start + 1)\n    \n    # Initialize a list to store all combinations\n    result = []\n    \n    # For each combination in the smaller combinations\n    for combination in smaller_combinations:\n        # Add the current combination as is\n        result.append(combination)\n        # Add the current element to the combination and add to result\n        result.append([elements[start]] + combination)\n    \n    # Return the list of combinations\n    return result\n\ndef combinations_list(elements):\n    # Generate all combinations starting from index 0\n    all_combinations = generate_combinations(elements, 0)\n    \n    # Sort the list of combinations to match the expected output order\n    all_combinations.sort(key=lambda x: (len(x), [elements.index(e) for e in x]))\n    \n    return all_combinations\n"}
{"task_id": "Mbpp/463", "solution": "\ndef max_subarray_product(arr):\n    # Initialize the maximum product to the first element\n    max_product = arr[0]\n    # Initialize current maximum and minimum products to the first element\n    current_max = arr[0]\n    current_min = arr[0]\n\n    # Iterate over the array starting from the second element\n    for num in arr[1:]:\n        # If the current number is negative, swap current_max and current_min\n        if num < 0:\n            current_max, current_min = current_min, current_max\n        \n        # Update current_max to be the maximum of the current number and the product of current_max and the current number\n        current_max = max(num, current_max * num)\n        # Update current_min to be the minimum of the current number and the product of current_min and the current number\n        current_min = min(num, current_min * num)\n        \n        # Update the global maximum product found so far\n        max_product = max(max_product, current_max)\n\n    return max_product\n"}
{"task_id": "Mbpp/465", "solution": "\ndef drop_empty(d: dict) -> dict:\n    # Initialize an empty dictionary to store non-empty items\n    result = {}\n    \n    # Iterate over each key-value pair in the input dictionary\n    for key, value in d.items():\n        # Check if the value is not None\n        if value is not None:\n            # Add the key-value pair to the result dictionary\n            result[key] = value\n    \n    # Return the dictionary with non-empty items\n    return result\n"}
{"task_id": "Mbpp/468", "solution": "\ndef max_product(arr):\n    # If the array is empty, return 0 as there are no subsequences\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    # Initialize the max_product array with the values of arr\n    max_product = arr[:]\n    \n    # Iterate over each element in the array starting from the second element\n    for i in range(1, n):\n        # Check all previous elements to see if they can form an increasing subsequence\n        for j in range(i):\n            if arr[j] < arr[i]:\n                # Update the max_product for the current element\n                max_product[i] = max(max_product[i], max_product[j] * arr[i])\n    \n    # Return the maximum value from the max_product array\n    return max(max_product)\n"}
{"task_id": "Mbpp/470", "solution": "\ndef add_pairwise(input_tuple):\n    # Initialize an empty list to store the results\n    result = []\n    \n    # Iterate over the tuple, stopping before the last element\n    for i in range(len(input_tuple) - 1):\n        # Calculate the sum of the current element and the next element\n        pair_sum = input_tuple[i] + input_tuple[i + 1]\n        # Append the sum to the result list\n        result.append(pair_sum)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "Mbpp/471", "solution": "\ndef find_remainder(arr, n):\n    # Initialize the product to 1\n    product = 1\n    \n    # Calculate the product of all elements in the array\n    for element in arr:\n        product *= element\n    \n    # Calculate the remainder of the product divided by n\n    remainder = product % n\n    \n    # Return the remainder\n    return remainder\n"}
{"task_id": "Mbpp/472", "solution": "\ndef check_Consecutive(numbers):\n    # If the list is empty, it cannot contain consecutive numbers\n    if not numbers:\n        return False\n    \n    # Find the minimum and maximum numbers in the list\n    min_num = min(numbers)\n    max_num = max(numbers)\n    \n    # Calculate the expected length of a consecutive sequence\n    expected_length = max_num - min_num + 1\n    \n    # Convert the list to a set to remove duplicates\n    unique_numbers = set(numbers)\n    \n    # Check if the size of the set matches the expected length\n    return len(unique_numbers) == expected_length\n"}
{"task_id": "Mbpp/473", "solution": "\ndef normalize_tuple(t: tuple) -> tuple:\n    # Sort the elements of the tuple to ensure consistent ordering\n    return tuple(sorted(t))\n\ndef tuple_intersection(list1: list, list2: list) -> set:\n    # Normalize each tuple in both lists\n    normalized_list1 = {normalize_tuple(t) for t in list1}\n    normalized_list2 = {normalize_tuple(t) for t in list2}\n    \n    # Find the intersection of the two sets\n    intersection = normalized_list1 & normalized_list2\n    \n    # Return the intersection as a set\n    return intersection\n"}
{"task_id": "Mbpp/474", "solution": "\ndef replace_char(s: str, old_char: str, new_char: str) -> str:\n    # Initialize an empty string to build the result\n    result = ''\n    \n    # Iterate over each character in the input string\n    for char in s:\n        # If the current character is the one to be replaced\n        if char == old_char:\n            # Append the new character to the result\n            result += new_char\n        else:\n            # Otherwise, append the original character\n            result += char\n    \n    # Return the modified string\n    return result\n"}
{"task_id": "Mbpp/475", "solution": "\ndef sort_counter(d: dict) -> list:\n    # Convert the dictionary into a list of tuples (key, value)\n    items = list(d.items())\n    # Sort the list of tuples by the second element (value) in descending order\n    sorted_items = sorted(items, key=lambda item: item[1], reverse=True)\n    # Return the sorted list of tuples\n    return sorted_items\n"}
{"task_id": "Mbpp/476", "solution": "\ndef big_sum(arr):\n    # Find the smallest number in the array\n    smallest = min(arr)\n    # Find the largest number in the array\n    largest = max(arr)\n    # Return the sum of the smallest and largest numbers\n    return smallest + largest\n"}
{"task_id": "Mbpp/477", "solution": "\ndef is_lower(s: str) -> str:\n    # Convert the input string to lowercase using the lower() method\n    return s.lower()\n"}
{"task_id": "Mbpp/478", "solution": "\ndef remove_lowercase(s: str) -> str:\n    # Initialize an empty string to store the result\n    result = \"\"\n    # Iterate over each character in the input string\n    for char in s:\n        # Check if the character is uppercase\n        if char.isupper():\n            # Add the uppercase character to the result string\n            result += char\n    # Return the result string containing only uppercase letters\n    return result\n"}
{"task_id": "Mbpp/479", "solution": "\ndef first_Digit(number: int) -> int:\n    # Convert the number to a string to easily access its first character\n    number_str = str(number)\n    # Get the first character of the string\n    first_char = number_str[0]\n    # Convert the first character back to an integer\n    first_digit = int(first_char)\n    # Return the first digit\n    return first_digit\n"}
{"task_id": "Mbpp/554", "solution": "\ndef Split(numbers):\n    # Initialize an empty list to store odd numbers\n    odd_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is odd\n        if number % 2 != 0:\n            # If it is odd, append it to the list of odd numbers\n            odd_numbers.append(number)\n    \n    # Return the list of odd numbers\n    return odd_numbers\n"}
{"task_id": "Mbpp/555", "solution": "\ndef difference(n: int) -> int:\n    # Calculate the sum of the first n natural numbers\n    sum_n = n * (n + 1) // 2\n    \n    # Calculate the sum of cubes of the first n natural numbers\n    sum_cubes = sum_n * sum_n\n    \n    # Calculate the difference\n    difference = sum_cubes - sum_n\n    \n    return difference\n"}
{"task_id": "Mbpp/556", "solution": "\ndef find_Odd_Pair(arr, n):\n    # Initialize counters for odd and even numbers\n    odd_count = 0\n    even_count = 0\n    \n    # Iterate through the array to count odd and even numbers\n    for number in arr:\n        if number % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # The number of pairs with an odd XOR is the product of odd and even counts\n    return odd_count * even_count\n"}
{"task_id": "Mbpp/557", "solution": "\ndef toggle_string(s: str) -> str:\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate over each character in the input string\n    for c in s:\n        # Check if the character is uppercase\n        if c.isupper():\n            # Convert to lowercase and append to result\n            result += c.lower()\n        # Check if the character is lowercase\n        elif c.islower():\n            # Convert to uppercase and append to result\n            result += c.upper()\n        else:\n            # If it's not an alphabetic character, append it as is\n            result += c\n    \n    # Return the final toggled string\n    return result\n"}
{"task_id": "Mbpp/558", "solution": "\ndef digit_distance_nums(a: int, b: int) -> int:\n    # Convert both numbers to strings to access individual digits\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Determine the maximum length of the two numbers\n    max_length = max(len(str_a), len(str_b))\n    \n    # Initialize the sum of differences\n    sum_difference = 0\n    \n    # Iterate over each digit position\n    for i in range(max_length):\n        # Get the digit from a if within bounds, otherwise 0\n        digit_a = int(str_a[i]) if i < len(str_a) else 0\n        # Get the digit from b if within bounds, otherwise 0\n        digit_b = int(str_b[i]) if i < len(str_b) else 0\n        \n        # Calculate the absolute difference and add to the sum\n        sum_difference += abs(digit_a - digit_b)\n    \n    # Return the total sum of differences\n    return sum_difference\n"}
{"task_id": "Mbpp/559", "solution": "\ndef max_sub_array_sum(arr: list, n: int) -> int:\n    # Initialize max_sum to the smallest possible integer\n    max_sum = float('-inf')\n    # Initialize current_sum to 0\n    current_sum = 0\n    \n    # Iterate over each element in the array\n    for num in arr:\n        # Add the current element to current_sum\n        current_sum += num\n        # Update max_sum if current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n        # If current_sum is negative, reset it to 0\n        if current_sum < 0:\n            current_sum = 0\n    \n    # Return the maximum sum found\n    return max_sum\n"}
{"task_id": "Mbpp/56", "solution": "\ndef check(n: int) -> bool:\n    # Convert the number to a string and reverse it\n    reversed_str = str(n)[::-1]\n    # Convert the reversed string back to an integer\n    reversed_n = int(reversed_str)\n    # Calculate twice the reversed number\n    twice_reversed = 2 * reversed_n\n    # Check if the original number is one less than twice the reversed number\n    return n == twice_reversed - 1\n"}
{"task_id": "Mbpp/560", "solution": "\ndef union_elements(tuple1: tuple, tuple2: tuple) -> tuple:\n    # Step 1: Concatenate the tuples\n    combined = tuple1 + tuple2\n    \n    # Step 2: Convert to set to remove duplicates\n    unique_elements = set(combined)\n    \n    # Step 3: Sort the unique elements\n    sorted_elements = sorted(unique_elements)\n    \n    # Step 4: Convert the sorted list back to a tuple\n    result = tuple(sorted_elements)\n    \n    # Step 5: Return the result\n    return result\n"}
{"task_id": "Mbpp/562", "solution": "\ndef Find_Max_Length(list_of_sublists):\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate over each sublist in the list\n    for sublist in list_of_sublists:\n        # Calculate the length of the current sublist\n        length_of_sublist = len(sublist)\n        \n        # Update the maximum length if the current sublist is longer\n        if length_of_sublist > max_length:\n            max_length = length_of_sublist\n    \n    # Return the maximum length found\n    return max_length\n"}
{"task_id": "Mbpp/563", "solution": "\ndef extract_values(s: str) -> list:\n    # Initialize an empty list to store the extracted values\n    results = []\n    # Initialize the index to start from the beginning of the string\n    i = 0\n\n    # Loop through the string until the end\n    while i < len(s):\n        # Check if the current character is a quotation mark\n        if s[i] == '\"':\n            # Find the next quotation mark\n            j = i + 1\n            while j < len(s) and s[j] != '\"':\n                j += 1\n            # Extract the substring between the quotation marks\n            if j < len(s):\n                results.append(s[i+1:j])\n            # Move the index to the position after the second quotation mark\n            i = j\n        # Move to the next character\n        i += 1\n\n    # Return the list of extracted values\n    return results\n"}
{"task_id": "Mbpp/564", "solution": "\ndef count_Pairs(arr, n):\n    # Initialize a counter to keep track of the number of valid pairs\n    count = 0\n    \n    # Iterate over each element in the list using its index\n    for i in range(n):\n        # For each element, iterate over the elements that come after it\n        for j in range(i + 1, n):\n            # If the two elements are different, it's a valid pair\n            if arr[i] != arr[j]:\n                # Increment the count of valid pairs\n                count += 1\n    \n    # Return the total count of valid pairs\n    return count\n"}
{"task_id": "Mbpp/565", "solution": "\ndef split(s: str) -> list:\n    # Use a list comprehension to iterate over each character in the string\n    # and collect them into a list\n    return [char for char in s]\n"}
{"task_id": "Mbpp/566", "solution": "\ndef sum_digits(n: int) -> int:\n    # Convert the integer to a string to iterate over each digit\n    n_str = str(n)\n    # Initialize the sum of digits to 0\n    total_sum = 0\n    # Iterate over each character in the string representation of the number\n    for char in n_str:\n        # Convert the character back to an integer and add it to the total sum\n        total_sum += int(char)\n    # Return the total sum of the digits\n    return total_sum\n"}
{"task_id": "Mbpp/567", "solution": "\ndef issort_list(lst):\n    # Iterate through the list from the first element to the second-to-last element\n    for i in range(len(lst) - 1):\n        # Compare the current element with the next element\n        if lst[i] > lst[i + 1]:\n            # If the current element is greater than the next, the list is not sorted\n            return False\n    # If no such pair is found, the list is sorted\n    return True\n"}
{"task_id": "Mbpp/568", "solution": "\ndef empty_list(N: int) -> list:\n    # Create a list with N empty dictionaries using list comprehension\n    return [{} for _ in range(N)]\n"}
{"task_id": "Mbpp/569", "solution": "\ndef sort_sublists(lst: list) -> list:\n    # Iterate over each sublist in the main list\n    for sublist in lst:\n        # Sort the current sublist alphabetically\n        sublist.sort()\n    # Return the modified list of lists\n    return lst\n"}
{"task_id": "Mbpp/57", "solution": "\ndef find_Max_Num(digits):\n    # Step 1: Sort the digits in descending order\n    sorted_digits = sorted(digits, reverse=True)\n    \n    # Step 2: Convert each digit to a string and concatenate them\n    max_num_str = ''.join(map(str, sorted_digits))\n    \n    # Step 3: Convert the concatenated string to an integer\n    max_num = int(max_num_str)\n    \n    # Step 4: Return the resulting integer\n    return max_num\n"}
{"task_id": "Mbpp/572", "solution": "\ndef two_unique_nums(nums):\n    # Create a dictionary to count occurrences of each number\n    count_dict = {}\n    \n    # Count each number in the list\n    for num in nums:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    # Create a list to store numbers that appear exactly once\n    unique_nums = []\n    \n    # Add numbers with a count of 1 to the unique_nums list\n    for num, count in count_dict.items():\n        if count == 1:\n            unique_nums.append(num)\n    \n    # Return the list of unique numbers\n    return unique_nums\n"}
{"task_id": "Mbpp/573", "solution": "\ndef unique_product(numbers):\n    # Convert the list to a set to get unique numbers\n    unique_numbers = set(numbers)\n    \n    # Initialize the product to 1\n    product = 1\n    \n    # Multiply each unique number to the product\n    for number in unique_numbers:\n        product *= number\n    \n    # Return the final product\n    return product\n"}
{"task_id": "Mbpp/576", "solution": "\ndef is_Sub_Array(main_list, sub_list):\n    # If the sub_list is longer than the main_list, it cannot be a sublist\n    if len(sub_list) > len(main_list):\n        return False\n    \n    # Iterate over each possible starting index in the main_list\n    for i in range(len(main_list) - len(sub_list) + 1):\n        # Assume the sublist is found\n        sublist_found = True\n        # Check if the sub_list matches the sequence in main_list starting at index i\n        for j in range(len(sub_list)):\n            if main_list[i + j] != sub_list[j]:\n                # If any element doesn't match, set sublist_found to False and break\n                sublist_found = False\n                break\n        # If sublist_found is still True, we found the sublist\n        if sublist_found:\n            return True\n    \n    # If no matching sublist was found, return False\n    return False\n"}
{"task_id": "Mbpp/577", "solution": "\ndef last_Digit_Factorial(n: int) -> int:\n    # If n is 5 or greater, the factorial will end with a 0\n    if n >= 5:\n        return 0\n    else:\n        # Calculate the factorial of n\n        factorial = 1\n        for i in range(1, n + 1):\n            factorial *= i\n        # Return the last digit of the factorial\n        return factorial % 10\n"}
{"task_id": "Mbpp/578", "solution": "\ndef interleave_lists(list1, list2, list3):\n    # Initialize an empty list to store the interleaved elements\n    result = []\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Append one element from each list in turn\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    \n    # Return the interleaved list\n    return result\n"}
{"task_id": "Mbpp/579", "solution": "\ndef find_dissimilar(tuple1, tuple2):\n    # Convert the first tuple to a set\n    set1 = set(tuple1)\n    # Convert the second tuple to a set\n    set2 = set(tuple2)\n    # Find the symmetric difference between the two sets\n    dissimilar_set = set1.symmetric_difference(set2)\n    # Convert the resulting set back to a tuple\n    dissimilar_tuple = tuple(dissimilar_set)\n    # Return the tuple of dissimilar elements\n    return dissimilar_tuple\n"}
{"task_id": "Mbpp/58", "solution": "\ndef opposite_Signs(x: int, y: int) -> bool:\n    # Check if the product of x and y is negative\n    # If the product is negative, it means x and y have opposite signs\n    return x * y < 0\n"}
{"task_id": "Mbpp/580", "solution": "\ndef extract_even(t):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each element in the tuple\n    for elem in t:\n        # Check if the element is an integer\n        if isinstance(elem, int):\n            # If the integer is even, add it to the result\n            if elem % 2 == 0:\n                result.append(elem)\n        # Check if the element is a tuple\n        elif isinstance(elem, tuple):\n            # Recursively process the nested tuple\n            filtered_tuple = extract_even(elem)\n            # If the resulting tuple is not empty, add it to the result\n            if filtered_tuple:\n                result.append(filtered_tuple)\n    \n    # Convert the result list back to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "Mbpp/581", "solution": "\ndef surface_Area(base_edge: int, height: int) -> int:\n    # Calculate the area of the base (a square)\n    base_area = base_edge * base_edge\n    \n    # Calculate the slant height using the Pythagorean theorem\n    # The slant height is the hypotenuse of a right triangle with sides (base_edge / 2) and height\n    slant_height = ((base_edge / 2) ** 2 + height ** 2) ** 0.5\n    \n    # Calculate the lateral surface area (area of the four triangular faces)\n    # Each triangular face has an area of (1/2 * base_edge * slant_height)\n    # Total lateral area is 2 * base_edge * slant_height\n    lateral_area = 2 * base_edge * slant_height\n    \n    # Total surface area is the sum of the base area and the lateral area\n    total_surface_area = base_area + lateral_area\n    \n    # Return the total surface area rounded to the nearest integer\n    return round(total_surface_area)\n"}
{"task_id": "Mbpp/583", "solution": "\ndef catalan_number(n: int) -> int:\n    # Initialize a list to store Catalan numbers up to the nth number\n    catalan = [0] * (n + 1)\n    \n    # The first Catalan number is 1\n    catalan[0] = 1\n    \n    # Calculate the Catalan numbers from 1 to n using the recursive formula\n    for i in range(1, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            # Use the recursive relation to calculate the ith Catalan number\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    \n    # Return the nth Catalan number\n    return catalan[n]\n"}
{"task_id": "Mbpp/585", "solution": "\ndef expensive_items(items, n):\n    # Sort the items in descending order based on their price\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    \n    # Return the first n items from the sorted list\n    return sorted_items[:n]\n"}
{"task_id": "Mbpp/586", "solution": "\ndef split_Arr(arr, n):\n    # Split the list into two parts: first_part and second_part\n    first_part = arr[0:n]  # Elements from the start to the n-th element (exclusive)\n    second_part = arr[n:]  # Elements from the n-th element to the end\n    \n    # Concatenate second_part with first_part\n    result = second_part + first_part\n    \n    # Return the modified list\n    return result\n"}
{"task_id": "Mbpp/587", "solution": "\ndef list_tuple(lst):\n    # Convert the list to a tuple using the tuple() function\n    return tuple(lst)\n"}
{"task_id": "Mbpp/588", "solution": "\ndef big_diff(numbers):\n    # Find the largest number in the list\n    largest = max(numbers)\n    # Find the smallest number in the list\n    smallest = min(numbers)\n    # Calculate the difference between the largest and smallest numbers\n    difference = largest - smallest\n    # Return the difference\n    return difference\n"}
{"task_id": "Mbpp/589", "solution": "\ndef perfect_squares(a: int, b: int) -> list:\n    # Initialize an empty list to store perfect squares\n    squares = []\n    \n    # Start with the smallest integer whose square is greater than or equal to a\n    n = 1\n    \n    # Continue until the square of n exceeds b\n    while n * n <= b:\n        # Calculate the square of n\n        square = n * n\n        \n        # If the square is within the range [a, b], add it to the list\n        if square >= a:\n            squares.append(square)\n        \n        # Move to the next integer\n        n += 1\n    \n    # Return the list of perfect squares\n    return squares\n"}
{"task_id": "Mbpp/59", "solution": "\ndef is_octagonal(n: int) -> int:\n    # Calculate the nth octagonal number using the formula\n    # O(n) = n * (3n - 2)\n    octagonal_number = n * (3 * n - 2)\n    # Return the calculated octagonal number\n    return octagonal_number\n"}
{"task_id": "Mbpp/590", "solution": "\nimport math\n\ndef polar_rect(r: float, theta: float) -> tuple:\n    # Calculate the x coordinate using the cosine of theta\n    x = r * math.cos(theta)\n    # Calculate the y coordinate using the sine of theta\n    y = r * math.sin(theta)\n    # Create the complex number representation\n    complex_number = complex(x, y)\n    # Return the tuple of rectangular coordinates and the complex number\n    return ((x, y), complex_number)\n"}
{"task_id": "Mbpp/591", "solution": "\ndef swap_List(lst):\n    # Check if the list has more than one element\n    if len(lst) > 1:\n        # Store the first element in a temporary variable\n        temp = lst[0]\n        # Assign the last element to the first position\n        lst[0] = lst[-1]\n        # Assign the temporary variable to the last position\n        lst[-1] = temp\n    # Return the modified list\n    return lst\n"}
{"task_id": "Mbpp/592", "solution": "\ndef factorial(x):\n    # Helper function to calculate factorial of x\n    if x == 0 or x == 1:\n        return 1\n    result = 1\n    for i in range(2, x + 1):\n        result *= i\n    return result\n\ndef binomial_coefficient(n, k):\n    # Calculate the binomial coefficient C(n, k)\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef sum_Of_product(n: int) -> int:\n    # Initialize the sum of products\n    sum_of_products = 0\n    \n    # Iterate over each pair of consecutive binomial coefficients\n    for k in range(n):\n        # Calculate C(n, k) and C(n, k+1)\n        c_n_k = binomial_coefficient(n, k)\n        c_n_k1 = binomial_coefficient(n, k + 1)\n        \n        # Calculate the product of consecutive binomial coefficients\n        product = c_n_k * c_n_k1\n        \n        # Add the product to the sum\n        sum_of_products += product\n    \n    # Return the total sum of products\n    return sum_of_products\n"}
{"task_id": "Mbpp/593", "solution": "\ndef removezero_ip(ip_address: str) -> str:\n    # Split the IP address into segments\n    segments = ip_address.split('.')\n    \n    # Remove leading zeros by converting each segment to an integer and back to a string\n    cleaned_segments = [str(int(segment)) for segment in segments]\n    \n    # Join the cleaned segments with '.' to form the cleaned IP address\n    cleaned_ip_address = '.'.join(cleaned_segments)\n    \n    return cleaned_ip_address\n"}
{"task_id": "Mbpp/594", "solution": "\ndef diff_even_odd(numbers):\n    # Initialize variables to store the first even and first odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list of numbers\n    for number in numbers:\n        # Check if the number is even and first_even is not yet set\n        if number % 2 == 0 and first_even is None:\n            first_even = number\n        # Check if the number is odd and first_odd is not yet set\n        if number % 2 != 0 and first_odd is None:\n            first_odd = number\n        # If both first_even and first_odd are found, break the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Return the absolute difference between the first even and first odd numbers\n    return abs(first_even - first_odd)\n"}
{"task_id": "Mbpp/596", "solution": "\nimport sys\n\ndef tuple_size(t: tuple) -> int:\n    # Use sys.getsizeof to get the size of the tuple in bytes\n    return sys.getsizeof(t)\n"}
{"task_id": "Mbpp/597", "solution": "\ndef find_kth(arr1, arr2, k):\n    # Initialize pointers for both arrays\n    i, j = 0, 0\n    # Initialize a counter to track the number of elements processed\n    counter = 0\n    \n    # Loop until we find the k-th element\n    while counter < k:\n        # Check if we can take an element from arr1\n        if i < len(arr1) and (j >= len(arr2) or arr1[i] <= arr2[j]):\n            # Increment the counter as we are considering an element\n            counter += 1\n            # If this is the k-th element, return it\n            if counter == k:\n                return arr1[i]\n            # Move the pointer in arr1\n            i += 1\n        else:\n            # Increment the counter as we are considering an element from arr2\n            counter += 1\n            # If this is the k-th element, return it\n            if counter == k:\n                return arr2[j]\n            # Move the pointer in arr2\n            j += 1\n"}
{"task_id": "Mbpp/598", "solution": "\ndef armstrong_number(n: int) -> bool:\n    # Convert the number to a string to iterate over digits\n    digits = str(n)\n    # Calculate the number of digits\n    num_digits = len(digits)\n    # Initialize the sum of powered digits\n    sum_of_powers = 0\n    # Iterate over each digit\n    for digit in digits:\n        # Convert digit to integer and raise to the power of num_digits\n        sum_of_powers += int(digit) ** num_digits\n    # Check if the sum of powered digits equals the original number\n    return sum_of_powers == n\n"}
{"task_id": "Mbpp/599", "solution": "\ndef sum_average(n: int) -> tuple:\n    # Calculate the sum of the first n natural numbers using the formula\n    total_sum = n * (n + 1) // 2  # Use integer division for exact result\n    \n    # Calculate the average by dividing the sum by n\n    average = total_sum / n  # Division to get a float result\n    \n    # Return the sum and average as a tuple\n    return (total_sum, average)\n"}
{"task_id": "Mbpp/6", "solution": "\ndef differ_At_One_Bit_Pos(a: int, b: int) -> bool:\n    # Perform XOR operation on a and b\n    xor_result = a ^ b\n    \n    # Check if xor_result is a power of two\n    # A number is a power of two if it has exactly one bit set\n    # This can be checked using the condition: xor_result & (xor_result - 1) == 0\n    # Also ensure xor_result is not zero, as zero means no bits are set\n    return xor_result != 0 and (xor_result & (xor_result - 1)) == 0\n"}
{"task_id": "Mbpp/600", "solution": "\ndef is_Even(n: int) -> bool:\n    # Check if the number n is divisible by 2\n    if n % 2 == 0:\n        # If divisible, it is even, return True\n        return True\n    else:\n        # If not divisible, it is odd, return False\n        return False\n"}
{"task_id": "Mbpp/602", "solution": "\ndef first_repeated_char(s: str) -> str:\n    # Initialize an empty set to keep track of seen characters\n    seen_chars = set()\n    \n    # Iterate over each character in the string\n    for char in s:\n        # If the character is already in the set, it is the first repeated character\n        if char in seen_chars:\n            return char\n        # Otherwise, add the character to the set\n        seen_chars.add(char)\n    \n    # If no repeated character is found, return None\n    return None\n"}
{"task_id": "Mbpp/603", "solution": "\ndef get_ludic(n: int) -> list:\n    # Create a list of numbers from 1 to n\n    numbers = list(range(1, n + 1))\n    # Initialize an empty list to store ludic numbers\n    ludic_numbers = []\n    \n    # While there are numbers left in the list\n    while numbers:\n        # The first number in the list is a ludic number\n        ludic = numbers[0]\n        # Add it to the list of ludic numbers\n        ludic_numbers.append(ludic)\n        # Remove every ludic-th number from the list starting from the next number\n        numbers = [num for i, num in enumerate(numbers) if (i + 1) % ludic != 0]\n    \n    # Return the list of ludic numbers\n    return ludic_numbers\n"}
{"task_id": "Mbpp/604", "solution": "\ndef reverse_words(s: str) -> str:\n    # Split the string into a list of words\n    words = s.split()\n    # Reverse the list of words\n    reversed_words = words[::-1]\n    # Join the reversed list into a single string with spaces in between\n    result = ' '.join(reversed_words)\n    # Return the resulting string\n    return result\n"}
{"task_id": "Mbpp/605", "solution": "\ndef prime_num(n: int) -> bool:\n    # If the number is less than 2, it is not prime\n    if n < 2:\n        return False\n    # 2 is the only even prime number\n    if n == 2:\n        return True\n    # If the number is even and greater than 2, it is not prime\n    if n % 2 == 0:\n        return False\n    # Check for factors from 3 to the square root of n, only odd numbers\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    # If no factors were found, the number is prime\n    return True\n"}
{"task_id": "Mbpp/606", "solution": "\ndef radian_degree(degrees: float) -> float:\n    # Define the value of pi\n    pi = 3.141592653589793\n    # Convert degrees to radians using the formula: radians = degrees * (pi / 180)\n    radians = degrees * (pi / 180)\n    # Return the calculated radians\n    return radians\n"}
{"task_id": "Mbpp/607", "solution": "\ndef find_literals(text: str, pattern: str) -> tuple:\n    # Find the starting index of the pattern in the text\n    start_index = text.find(pattern)\n    \n    # Check if the pattern is found\n    if start_index != -1:\n        # Calculate the ending index\n        end_index = start_index + len(pattern)\n        # Return the pattern, start index, and end index\n        return (pattern, start_index, end_index)\n    \n    # If pattern is not found, return None values (or handle as needed)\n    return (None, None, None)\n"}
{"task_id": "Mbpp/608", "solution": "\ndef bell_Number(n: int) -> int:\n    # Create a 2D list (triangle) with n+1 rows\n    bell_triangle = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    # Initialize the first element of the first row to 1\n    bell_triangle[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # Set the first element of the row to the last element of the previous row\n        bell_triangle[i][0] = bell_triangle[i - 1][i - 1]\n        \n        # Fill the rest of the row\n        for j in range(1, i + 1):\n            # Set the current element to the sum of the element to the left and the element above\n            bell_triangle[i][j] = bell_triangle[i - 1][j - 1] + bell_triangle[i][j - 1]\n    \n    # Return the first element of the nth row\n    return bell_triangle[n][0]\n"}
{"task_id": "Mbpp/61", "solution": "\ndef count_Substrings(s: str) -> int:\n    # Initialize the count of valid substrings\n    count = 0\n    \n    # Iterate over each possible starting index of the substring\n    for i in range(len(s)):\n        # Initialize the sum of digits for the current starting index\n        sum_of_digits = 0\n        \n        # Iterate over each possible ending index of the substring\n        for j in range(i, len(s)):\n            # Add the digit at position j to the sum_of_digits\n            sum_of_digits += int(s[j])\n            \n            # Check if the sum of digits equals the length of the substring\n            if sum_of_digits == (j - i + 1):\n                # If so, increment the count\n                count += 1\n    \n    # Return the total count of valid substrings\n    return count\n"}
{"task_id": "Mbpp/610", "solution": "\ndef remove_kth_element(lst, k):\n    # Return a new list with the k-th element removed\n    # lst[:k] gives all elements before the k-th element\n    # lst[k+1:] gives all elements after the k-th element\n    return lst[:k] + lst[k+1:]\n"}
{"task_id": "Mbpp/611", "solution": "\ndef max_of_nth(matrix, n):\n    # Initialize an empty list to store the values of the n-th column\n    column_values = []\n    \n    # Iterate over each row in the matrix\n    for row in matrix:\n        # Append the n-th element of the current row to column_values\n        column_values.append(row[n])\n    \n    # Return the maximum value from the collected n-th column values\n    return max(column_values)\n"}
{"task_id": "Mbpp/612", "solution": "\ndef merge(list_of_lists):\n    # Initialize two empty lists to store the first and second elements\n    first_elements = []\n    second_elements = []\n    \n    # Iterate over each sublist in the input list\n    for sublist in list_of_lists:\n        # Append the first element of the sublist to first_elements\n        first_elements.append(sublist[0])\n        # Append the second element of the sublist to second_elements\n        second_elements.append(sublist[1])\n    \n    # Return a list containing the two lists\n    return [first_elements, second_elements]\n"}
{"task_id": "Mbpp/614", "solution": "\ndef cummulative_sum(tuple_list):\n    # Initialize the cumulative sum to 0\n    total_sum = 0\n    \n    # Iterate over each tuple in the list\n    for tup in tuple_list:\n        # Iterate over each number in the current tuple\n        for num in tup:\n            # Add the number to the cumulative sum\n            total_sum += num\n    \n    # Return the final cumulative sum\n    return total_sum\n"}
{"task_id": "Mbpp/615", "solution": "\ndef average_tuple(tuples):\n    # Initialize an empty list to store the averages\n    averages = []\n    \n    # Iterate over each tuple in the input\n    for t in tuples:\n        # Calculate the sum of the elements in the tuple\n        total = sum(t)\n        # Calculate the average by dividing the sum by the number of elements\n        avg = total / len(t)\n        # Append the average to the list\n        averages.append(avg)\n    \n    # Return the list of averages\n    return averages\n"}
{"task_id": "Mbpp/616", "solution": "\ndef tuple_modulo(tuple1, tuple2):\n    # Initialize an empty list to store the results of the modulo operations\n    result = []\n    \n    # Iterate over the indices of the tuples\n    for i in range(len(tuple1)):\n        # Calculate the modulo of the elements at the current index\n        mod_result = tuple1[i] % tuple2[i]\n        # Append the result to the list\n        result.append(mod_result)\n    \n    # Convert the list to a tuple and return it\n    return tuple(result)\n"}
{"task_id": "Mbpp/618", "solution": "\ndef div_list(list1, list2):\n    # Initialize an empty list to store the results of the division\n    result = []\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Divide the element from list1 by the corresponding element in list2\n        # Append the result to the result list\n        result.append(list1[i] / list2[i])\n    \n    # Return the list containing the division results\n    return result\n"}
{"task_id": "Mbpp/619", "solution": "\ndef move_num(s: str) -> str:\n    # Initialize lists to hold letters and numbers separately\n    letters = []\n    numbers = []\n\n    # Iterate over each character in the input string\n    for char in s:\n        if char.isdigit():\n            # If the character is a digit, add it to the numbers list\n            numbers.append(char)\n        else:\n            # If the character is a letter, add it to the letters list\n            letters.append(char)\n\n    # Concatenate the letters and numbers lists and convert to a string\n    return ''.join(letters) + ''.join(numbers)\n"}
{"task_id": "Mbpp/62", "solution": "\ndef smallest_num(numbers):\n    # Check if the list is empty and return None if it is\n    if not numbers:\n        return None\n    \n    # Initialize the smallest number as the first element of the list\n    smallest = numbers[0]\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # If the current number is smaller than the smallest found so far\n        if number < smallest:\n            # Update the smallest number\n            smallest = number\n    \n    # Return the smallest number found\n    return smallest\n"}
{"task_id": "Mbpp/620", "solution": "\ndef largest_subset(nums):\n    # If the list is empty, return 0 as there are no elements to form a subset\n    if not nums:\n        return 0\n    \n    # Sort the numbers to ensure that if a divides b, then a <= b\n    nums.sort()\n    n = len(nums)\n    \n    # Initialize the dp array where each element is 1, as each number is a subset of itself\n    dp = [1] * n\n    \n    # Iterate over each number in the sorted list\n    for i in range(1, n):\n        # Check all previous numbers to see if they can form a divisible pair with nums[i]\n        for j in range(i):\n            # If nums[i] is divisible by nums[j], update dp[i]\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    # The result is the maximum value in the dp array, which represents the largest subset size\n    return max(dp)\n"}
{"task_id": "Mbpp/622", "solution": "\ndef get_median(list1, list2, n):\n    # Initialize an empty list to store the merged result\n    merged_list = []\n    # Initialize pointers for both lists\n    i, j = 0, 0\n    \n    # Merge the two lists\n    while i < n and j < n:\n        if list1[i] < list2[j]:\n            merged_list.append(list1[i])\n            i += 1\n        else:\n            merged_list.append(list2[j])\n            j += 1\n    \n    # Append remaining elements from list1 if any\n    while i < n:\n        merged_list.append(list1[i])\n        i += 1\n    \n    # Append remaining elements from list2 if any\n    while j < n:\n        merged_list.append(list2[j])\n        j += 1\n    \n    # Calculate the median\n    total_length = 2 * n\n    if total_length % 2 == 1:\n        # If odd, return the middle element\n        return float(merged_list[total_length // 2])\n    else:\n        # If even, return the average of the two middle elements\n        mid1 = total_length // 2 - 1\n        mid2 = total_length // 2\n        return (merged_list[mid1] + merged_list[mid2]) / 2.0\n"}
{"task_id": "Mbpp/623", "solution": "\ndef nth_nums(nums, n):\n    # Initialize an empty list to store the results\n    result = []\n    # Iterate over each number in the input list\n    for num in nums:\n        # Compute the n-th power of the number and append to the result list\n        result.append(num ** n)\n    # Return the list of powered numbers\n    return result\n"}
{"task_id": "Mbpp/624", "solution": "\ndef is_upper(s: str) -> str:\n    # Convert the input string to uppercase using the upper() method\n    return s.upper()\n"}
{"task_id": "Mbpp/626", "solution": "\ndef triangle_area(radius: float) -> float:\n    # If the radius is negative, return None as a triangle cannot be inscribed\n    if radius < 0:\n        return None\n    # Calculate the area of the largest inscribed triangle\n    # The largest triangle is a right triangle with both legs equal to the radius\n    # Area = 1/2 * base * height = 1/2 * radius * radius\n    area = 0.5 * radius * radius\n    return area\n"}
{"task_id": "Mbpp/628", "solution": "\ndef replace_spaces(s: str) -> str:\n    # Use the replace method to replace all spaces with '%20'\n    return s.replace(' ', '%20')\n"}
{"task_id": "Mbpp/629", "solution": "\ndef Split(numbers):\n    # Initialize an empty list to store even numbers\n    even_numbers = []\n    \n    # Iterate through each number in the input list\n    for number in numbers:\n        # Check if the number is even\n        if number % 2 == 0:\n            # If it is even, add it to the even_numbers list\n            even_numbers.append(number)\n    \n    # Return the list of even numbers\n    return even_numbers\n"}
{"task_id": "Mbpp/63", "solution": "\ndef max_difference(pairs: list) -> int:\n    # Initialize the maximum difference to 0\n    max_diff = 0\n    \n    # Iterate over each pair in the list\n    for a, b in pairs:\n        # Calculate the absolute difference between the two numbers in the pair\n        diff = abs(a - b)\n        \n        # Update max_diff if the current difference is greater\n        if diff > max_diff:\n            max_diff = diff\n    \n    # Return the maximum difference found\n    return max_diff\n"}
{"task_id": "Mbpp/630", "solution": "\ndef get_coordinates(coord: tuple) -> list:\n    # Unpack the input tuple into x and y\n    x, y = coord\n    # Initialize an empty list to store the adjacent coordinates\n    adjacent_coords = []\n    # Iterate over the range [-1, 0, 1] for both x and y to cover all adjacent positions\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            # Calculate the new coordinates by adding dx and dy to x and y\n            new_x = x + dx\n            new_y = y + dy\n            # Append the new coordinate as a list to the adjacent_coords list\n            adjacent_coords.append([new_x, new_y])\n    # Return the list of adjacent coordinates\n    return adjacent_coords\n"}
{"task_id": "Mbpp/631", "solution": "\ndef replace_spaces(s: str) -> str:\n    # Initialize an empty list to store the modified characters\n    modified_chars = []\n    \n    # Iterate over each character in the string\n    for char in s:\n        if char == ' ':\n            # If the character is a space, replace it with an underscore\n            modified_chars.append('_')\n        elif char == '_':\n            # If the character is an underscore, replace it with a space\n            modified_chars.append(' ')\n        else:\n            # If the character is neither, keep it unchanged\n            modified_chars.append(char)\n    \n    # Join the list into a string and return it\n    return ''.join(modified_chars)\n"}
{"task_id": "Mbpp/632", "solution": "\ndef move_zero(lst):\n    # Step 1: Initialize an empty list for non-zero elements\n    non_zero_elements = []\n    \n    # Step 2: Initialize a counter for zeroes\n    zero_count = 0\n    \n    # Step 3: Iterate through the list\n    for num in lst:\n        if num != 0:\n            # Collect non-zero elements\n            non_zero_elements.append(num)\n        else:\n            # Count zeroes\n            zero_count += 1\n    \n    # Step 4: Concatenate non-zero elements with zeroes\n    result = non_zero_elements + [0] * zero_count\n    \n    # Step 5: Return the result\n    return result\n"}
{"task_id": "Mbpp/633", "solution": "\ndef pair_xor_Sum(arr, n):\n    # Initialize the total sum of XORs to 0\n    total_sum = 0\n    \n    # Iterate over all pairs (i, j) with i < j\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Calculate the XOR of the current pair\n            xor_value = arr[i] ^ arr[j]\n            # Add the XOR value to the total sum\n            total_sum += xor_value\n    \n    # Return the total sum of XORs\n    return total_sum\n"}
{"task_id": "Mbpp/635", "solution": "\ndef heapify(arr, n, i):\n    # Initialize largest as root\n    largest = i\n    left = 2 * i + 1  # left child index\n    right = 2 * i + 2  # right child index\n\n    # If left child is larger than root\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        # Swap root with largest\n        arr[i], arr[largest] = arr[largest], arr[i]\n        # Recursively heapify the affected sub-tree\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n\n    # Build a maxheap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # One by one extract elements\n    for i in range(n - 1, 0, -1):\n        # Move current root to end\n        arr[i], arr[0] = arr[0], arr[i]\n        # Call max heapify on the reduced heap\n        heapify(arr, i, 0)\n\n    return arr\n"}
{"task_id": "Mbpp/637", "solution": "\ndef noprofit_noloss(cost_price: int, selling_price: int) -> bool:\n    # Check if the cost price is equal to the selling price\n    # If they are equal, it means there is no profit and no loss\n    if cost_price == selling_price:\n        return True\n    else:\n        return False\n"}
{"task_id": "Mbpp/638", "solution": "\ndef wind_chill(velocity: float, temperature: float) -> int:\n    # Calculate the wind chill index using the given formula\n    WCI = 13.12 + 0.6215 * temperature - 11.37 * (velocity ** 0.16) + 0.3965 * temperature * (velocity ** 0.16)\n    \n    # Round the wind chill index to the nearest integer\n    rounded_WCI = round(WCI)\n    \n    # Return the rounded wind chill index\n    return rounded_WCI\n"}
{"task_id": "Mbpp/639", "solution": "\ndef sample_nam(names: list) -> int:\n    # Initialize the total length counter\n    total_length = 0\n    \n    # Iterate over each name in the list\n    for name in names:\n        # Check if the first character of the name is uppercase\n        if name[0].isupper():\n            # Add the length of the name to the total length\n            total_length += len(name)\n    \n    # Return the total length of names that start with an uppercase letter\n    return total_length\n"}
{"task_id": "Mbpp/64", "solution": "\ndef subject_marks(marks_list):\n    # Sort the list of tuples based on the second element of each tuple (the marks)\n    # Use a lambda function as the key to extract the second element for sorting\n    sorted_list = sorted(marks_list, key=lambda x: x[1])\n    # Return the sorted list\n    return sorted_list\n"}
{"task_id": "Mbpp/641", "solution": "\ndef is_nonagonal(n: int) -> int:\n    # Calculate the nth nonagonal number using the formula\n    # N(n) = n * (7n - 5) / 2\n    nonagonal_number = n * (7 * n - 5) // 2\n    return nonagonal_number\n"}
{"task_id": "Mbpp/643", "solution": "\ndef text_match_wordz_middle(s: str) -> bool:\n    # If the string is too short to have a middle 'z', return False\n    if len(s) < 3:\n        return False\n    \n    # Iterate over the string from the second character to the second-to-last character\n    for i in range(1, len(s) - 1):\n        # Check if the current character is 'z'\n        if s[i] == 'z':\n            return True\n    \n    # If no 'z' was found in the middle, return False\n    return False\n"}
{"task_id": "Mbpp/644", "solution": "\ndef reverse_Array_Upto_K(arr, k):\n    # Check if k is greater than the length of the array\n    if k > len(arr):\n        # If k is greater, return the array as is\n        return arr\n    \n    # Reverse the subarray from the start to the k-th position (exclusive)\n    reversed_part = arr[:k][::-1]\n    \n    # Concatenate the reversed part with the rest of the array starting from k\n    result = reversed_part + arr[k:]\n    \n    # Return the resulting array\n    return result\n"}
{"task_id": "Mbpp/65", "solution": "\ndef recursive_list_sum(lst):\n    # Initialize the total sum to 0\n    total_sum = 0\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is a list, recursively call the function\n        if isinstance(element, list):\n            total_sum += recursive_list_sum(element)\n        else:\n            # Otherwise, add the element to the total sum\n            total_sum += element\n    \n    # Return the total sum of all elements\n    return total_sum\n"}
{"task_id": "Mbpp/66", "solution": "\ndef pos_count(numbers):\n    # Initialize a counter to keep track of positive numbers\n    count = 0\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is positive\n        if number > 0:\n            # Increment the counter if the number is positive\n            count += 1\n    \n    # Return the total count of positive numbers\n    return count\n"}
{"task_id": "Mbpp/67", "solution": "\ndef bell_number(n: int) -> int:\n    # Create a 2D list `bell` with dimensions (n+1) x (n+1) initialized to 0\n    bell = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    \n    # The first Bell number is 1\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n+1):\n        # The first element of each row is the last element of the previous row\n        bell[i][0] = bell[i-1][i-1]\n        \n        # Fill the rest of the row\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    \n    # The Bell number for n is the first element of the n-th row\n    return bell[n][0]\n"}
{"task_id": "Mbpp/68", "solution": "\ndef is_Monotonic(arr):\n    # Initialize flags for non-decreasing and non-increasing\n    is_non_decreasing = True\n    is_non_increasing = True\n    \n    # Iterate through the array to check monotonicity\n    for i in range(len(arr) - 1):\n        # Check if the array is not non-decreasing\n        if arr[i] > arr[i + 1]:\n            is_non_decreasing = False\n        # Check if the array is not non-increasing\n        if arr[i] < arr[i + 1]:\n            is_non_increasing = False\n    \n    # The array is monotonic if it is either non-decreasing or non-increasing\n    return is_non_decreasing or is_non_increasing\n"}
{"task_id": "Mbpp/69", "solution": "\ndef is_sublist(main_list, sub_list):\n    # Get the lengths of the main list and the sublist\n    len_main = len(main_list)\n    len_sub = len(sub_list)\n    \n    # If the sublist is longer than the main list, it cannot be a sublist\n    if len_sub > len_main:\n        return False\n    \n    # Iterate over each possible starting index in the main list\n    for i in range(len_main - len_sub + 1):\n        # Check if the segment of main_list starting at this index matches the sub_list\n        if main_list[i:i+len_sub] == sub_list:\n            return True\n    \n    # If no match is found after checking all possible starting positions, return False\n    return False\n"}
{"task_id": "Mbpp/7", "solution": "\ndef find_char_long(s: str) -> list:\n    # Split the input string into words\n    words = s.split()\n    \n    # Initialize an empty list to store words that are at least 4 characters long\n    long_words = []\n    \n    # Iterate through each word in the list of words\n    for word in words:\n        # Check if the length of the word is 4 or more\n        if len(word) >= 4:\n            # Add the word to the list of long words\n            long_words.append(word)\n    \n    # Return the list of long words\n    return long_words\n"}
{"task_id": "Mbpp/70", "solution": "\ndef get_equal(tuples):\n    # If the list of tuples is empty, return True\n    if not tuples:\n        return True\n    \n    # Get the length of the first tuple\n    first_length = len(tuples[0])\n    \n    # Iterate through each tuple in the list\n    for t in tuples:\n        # If the current tuple's length is not equal to the first tuple's length, return False\n        if len(t) != first_length:\n            return False\n    \n    # If all tuples have the same length, return True\n    return True\n"}
{"task_id": "Mbpp/71", "solution": "\ndef comb_sort(arr):\n    # Initialize the gap to the length of the array\n    gap = len(arr)\n    # Define the shrink factor\n    shrink = 1.3\n    # Initialize the sorted flag to False\n    sorted = False\n    \n    # Continue the loop until the gap is 1 and the array is sorted\n    while gap > 1 or not sorted:\n        # Update the gap for the next comb\n        gap = int(gap // shrink)\n        # Ensure the gap is at least 1\n        if gap < 1:\n            gap = 1\n        \n        # Assume the array is sorted\n        sorted = True\n        \n        # Compare all elements with the current gap\n        for i in range(len(arr) - gap):\n            # If the current element is greater than the element at the gap distance\n            if arr[i] > arr[i + gap]:\n                # Swap the elements\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                # Since we made a swap, the array might not be sorted\n                sorted = False\n    \n    # Return the sorted array\n    return arr\n"}
{"task_id": "Mbpp/72", "solution": "\ndef dif_Square(n: int) -> bool:\n    # Check if the number is of the form 4k + 2\n    # If it is, it cannot be expressed as the difference of two squares\n    if n % 4 == 2:\n        return False\n    # Otherwise, it can be expressed as the difference of two squares\n    else:\n        return True\n"}
{"task_id": "Mbpp/720", "solution": "\ndef add_dict_to_tuple(input_tuple: tuple, input_dict: dict) -> tuple:\n    # Convert the input tuple to a list to allow appending\n    temp_list = list(input_tuple)\n    \n    # Append the dictionary to the list\n    temp_list.append(input_dict)\n    \n    # Convert the list back to a tuple\n    result_tuple = tuple(temp_list)\n    \n    # Return the new tuple\n    return result_tuple\n"}
{"task_id": "Mbpp/721", "solution": "\ndef maxAverageOfPath(matrix: list[list[int]]) -> float:\n    N = len(matrix)\n    \n    # Initialize dp and count arrays\n    dp = [[0] * N for _ in range(N)]\n    count = [[0] * N for _ in range(N)]\n    \n    # Base case: starting point\n    dp[0][0] = matrix[0][0]\n    count[0][0] = 1\n    \n    # Fill the dp and count arrays\n    for i in range(N):\n        for j in range(N):\n            if i == 0 and j == 0:\n                continue\n            # Check from left\n            if j > 0:\n                new_sum = dp[i][j-1] + matrix[i][j]\n                new_count = count[i][j-1] + 1\n                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:\n                    dp[i][j] = new_sum\n                    count[i][j] = new_count\n            # Check from above\n            if i > 0:\n                new_sum = dp[i-1][j] + matrix[i][j]\n                new_count = count[i-1][j] + 1\n                if count[i][j] == 0 or new_sum * count[i][j] > dp[i][j] * new_count:\n                    dp[i][j] = new_sum\n                    count[i][j] = new_count\n    \n    # Calculate the maximum average at the bottom-right corner\n    max_average = dp[N-1][N-1] / count[N-1][N-1]\n    return max_average\n"}
{"task_id": "Mbpp/722", "solution": "\ndef filter_data(students_dict: dict, min_height: float, min_weight: float) -> dict:\n    # Initialize an empty dictionary to store students who meet the criteria\n    filtered_students = {}\n    \n    # Iterate over each student in the input dictionary\n    for student_name, (height, weight) in students_dict.items():\n        # Check if both height and weight are greater than or equal to the minimum thresholds\n        if height >= min_height and weight >= min_weight:\n            # Add the student to the filtered dictionary\n            filtered_students[student_name] = (height, weight)\n    \n    # Return the dictionary containing only the students who meet the criteria\n    return filtered_students\n"}
{"task_id": "Mbpp/723", "solution": "\ndef count_same_pair(list1, list2):\n    # Initialize a counter to keep track of indices with the same values\n    count = 0\n    \n    # Iterate over the indices of the lists\n    for i in range(len(list1)):\n        # Compare the values at the current index in both lists\n        if list1[i] == list2[i]:\n            # If they are the same, increment the counter\n            count += 1\n    \n    # Return the total count of indices with the same values\n    return count\n"}
{"task_id": "Mbpp/724", "solution": "\ndef power_base_sum(base: int, power: int) -> int:\n    # Calculate the result of base raised to the power\n    result = base ** power\n    \n    # Convert the result to a string to iterate over each digit\n    result_str = str(result)\n    \n    # Initialize the sum of digits to 0\n    sum_of_digits = 0\n    \n    # Iterate over each character in the string representation of the result\n    for char in result_str:\n        # Convert the character to an integer and add it to the sum_of_digits\n        sum_of_digits += int(char)\n    \n    # Return the sum of the digits\n    return sum_of_digits\n"}
{"task_id": "Mbpp/725", "solution": "\ndef extract_quotation(s: str) -> list:\n    # Initialize an empty list to store the extracted substrings\n    results = []\n    # This flag indicates whether we are currently inside a pair of quotes\n    inside_quotes = False\n    # This will hold the current substring being built\n    current_string = \"\"\n\n    # Iterate over each character in the input string\n    for char in s:\n        if char == '\"':\n            # If we encounter a double quote\n            if inside_quotes:\n                # If we are already inside quotes, this means we found the closing quote\n                results.append(current_string)\n                # Reset the current string for the next potential quoted substring\n                current_string = \"\"\n                # Toggle the inside_quotes flag\n                inside_quotes = False\n            else:\n                # If we are not inside quotes, this is an opening quote\n                inside_quotes = True\n        elif inside_quotes:\n            # If we are inside quotes, add the character to the current substring\n            current_string += char\n\n    # Return the list of extracted substrings\n    return results\n"}
{"task_id": "Mbpp/726", "solution": "\ndef multiply_elements(input_tuple):\n    # Initialize an empty list to store the products\n    products = []\n    \n    # Iterate through the input tuple, stopping one element before the end\n    for i in range(len(input_tuple) - 1):\n        # Calculate the product of the current element and the next element\n        product = input_tuple[i] * input_tuple[i + 1]\n        # Append the product to the products list\n        products.append(product)\n    \n    # Convert the products list to a tuple and return it\n    return tuple(products)\n"}
{"task_id": "Mbpp/728", "solution": "\ndef sum_list(list1, list2):\n    # Initialize an empty list to store the sums\n    result = []\n    # Iterate over the indices of the input lists\n    for i in range(len(list1)):\n        # Add the elements from both lists at the current index and append to result\n        result.append(list1[i] + list2[i])\n    # Return the list containing the sums\n    return result\n"}
{"task_id": "Mbpp/730", "solution": "\ndef consecutive_duplicates(lst):\n    # If the input list is empty, return an empty list\n    if not lst:\n        return []\n    \n    # Initialize the result list with the first element of the input list\n    result = [lst[0]]\n    \n    # Iterate over the input list starting from the second element\n    for i in range(1, len(lst)):\n        # If the current element is different from the last element in the result list\n        if lst[i] != result[-1]:\n            # Append the current element to the result list\n            result.append(lst[i])\n    \n    # Return the result list which contains no consecutive duplicates\n    return result\n"}
{"task_id": "Mbpp/731", "solution": "\nimport math\n\ndef lateralsurface_cone(r: float, h: float) -> float:\n    # Calculate the slant height using the Pythagorean theorem\n    l = math.sqrt(r**2 + h**2)\n    # Calculate the lateral surface area using the formula \u03c0 * r * l\n    area = math.pi * r * l\n    # Return the calculated lateral surface area\n    return area\n"}
{"task_id": "Mbpp/732", "solution": "\ndef replace_specialchar(text: str) -> str:\n    # Initialize an empty string to store the result\n    result = ''\n    # Iterate over each character in the input text\n    for char in text:\n        # Check if the character is a space, comma, or period\n        if char in ' ,.':\n            # Replace it with a colon\n            result += ':'\n        else:\n            # Otherwise, keep the character as it is\n            result += char\n    # Return the modified string\n    return result\n"}
{"task_id": "Mbpp/733", "solution": "\ndef find_first_occurrence(arr, target):\n    # Initialize the low and high pointers for binary search\n    low = 0\n    high = len(arr) - 1\n    # Initialize result to -1 to indicate target not found initially\n    result = -1\n\n    # Perform binary search\n    while low <= high:\n        # Calculate the middle index\n        mid = (low + high) // 2\n\n        # If the target is found at mid\n        if arr[mid] == target:\n            # Update result to the current mid index\n            result = mid\n            # Move high to mid - 1 to check for earlier occurrences\n            high = mid - 1\n        # If the target is greater than the mid element, search in the right half\n        elif arr[mid] < target:\n            low = mid + 1\n        # If the target is less than the mid element, search in the left half\n        else:\n            high = mid - 1\n\n    # Return the index of the first occurrence or -1 if not found\n    return result\n"}
{"task_id": "Mbpp/734", "solution": "\ndef sum_Of_Subarray_Prod(arr):\n    # Initialize the total sum of products to 0\n    total_sum = 0\n    \n    # Iterate over each possible starting index of sublists\n    for i in range(len(arr)):\n        # Initialize the product for the current sublist\n        product = 1\n        # Iterate over each possible ending index of sublists starting from i\n        for j in range(i, len(arr)):\n            # Multiply the current product by the current element\n            product *= arr[j]\n            # Add the current product to the total sum\n            total_sum += product\n    \n    # Return the total sum of products of all sublists\n    return total_sum\n"}
{"task_id": "Mbpp/735", "solution": "\ndef toggle_middle_bits(n: int) -> int:\n    # Convert the number to a binary string without the '0b' prefix\n    binary_str = bin(n)[2:]\n    \n    # If the length of the binary string is less than or equal to 2, return n\n    # because there are no middle bits to toggle\n    if len(binary_str) <= 2:\n        return n\n    \n    # Keep the first and last bits unchanged\n    first_bit = binary_str[0]\n    last_bit = binary_str[-1]\n    \n    # Toggle the middle bits\n    middle_bits = binary_str[1:-1]\n    toggled_middle_bits = ''.join('1' if bit == '0' else '0' for bit in middle_bits)\n    \n    # Construct the new binary string\n    new_binary_str = first_bit + toggled_middle_bits + last_bit\n    \n    # Convert the new binary string back to an integer\n    return int(new_binary_str, 2)\n"}
{"task_id": "Mbpp/736", "solution": "\ndef left_insertion(arr, value):\n    # Iterate over each element in the array\n    for i in range(len(arr)):\n        # Check if the current element is greater than or equal to the specified value\n        if arr[i] >= value:\n            # Return the current index as the left insertion point\n            return i\n    # If no element is greater than or equal to the value, return the length of the array\n    return len(arr)\n"}
{"task_id": "Mbpp/737", "solution": "\nimport re\n\ndef check_str(s: str) -> bool:\n    # Define a regular expression pattern to match the start of the string with any vowel\n    # The pattern '^' indicates the start of the string\n    # '[aeiou]' matches any vowel\n    # The 're.IGNORECASE' flag makes the match case-insensitive\n    pattern = r'^[aeiou]'\n    \n    # Use re.match to check if the string starts with a vowel\n    if re.match(pattern, s, re.IGNORECASE):\n        return True\n    else:\n        return False\n"}
{"task_id": "Mbpp/739", "solution": "\ndef find_Index(n: int) -> int:\n    # Start with the first triangular number\n    index = 1\n    while True:\n        # Calculate the current triangular number using the formula\n        triangular_number = index * (index + 1) // 2\n        # Check if the number of digits in the triangular number is equal to n\n        if len(str(triangular_number)) == n:\n            # If yes, return the current index\n            return index\n        # Move to the next index\n        index += 1\n"}
{"task_id": "Mbpp/74", "solution": "\ndef is_samepatterns(patterns: list, sequence: list) -> bool:\n    # Check if the lengths of the two lists are the same\n    if len(patterns) != len(sequence):\n        return False\n    \n    # Initialize dictionaries to store mappings\n    pattern_to_sequence = {}\n    sequence_to_pattern = {}\n    \n    # Iterate over both lists simultaneously\n    for p, s in zip(patterns, sequence):\n        # Check if there is a conflicting mapping in pattern_to_sequence\n        if p in pattern_to_sequence:\n            if pattern_to_sequence[p] != s:\n                return False\n        else:\n            pattern_to_sequence[p] = s\n        \n        # Check if there is a conflicting mapping in sequence_to_pattern\n        if s in sequence_to_pattern:\n            if sequence_to_pattern[s] != p:\n                return False\n        else:\n            sequence_to_pattern[s] = p\n    \n    # If no conflicts were found, the patterns match\n    return True\n"}
{"task_id": "Mbpp/740", "solution": "\ndef tuple_to_dict(t: tuple) -> dict:\n    # Initialize an empty dictionary to store the key-value pairs\n    result = {}\n    \n    # Iterate over the tuple with a step of 2 to process elements in pairs\n    for i in range(0, len(t), 2):\n        # Use the current element as the key and the next element as the value\n        result[t[i]] = t[i + 1]\n    \n    # Return the constructed dictionary\n    return result\n"}
{"task_id": "Mbpp/741", "solution": "\ndef all_Characters_Same(s: str) -> bool:\n    # If the string is empty, return True (no differing characters)\n    if not s:\n        return True\n    \n    # Get the first character of the string\n    first_char = s[0]\n    \n    # Check each character in the string\n    for char in s:\n        # If a character is different from the first character, return False\n        if char != first_char:\n            return False\n    \n    # If all characters are the same, return True\n    return True\n"}
{"task_id": "Mbpp/742", "solution": "\ndef area_tetrahedron(edge_length: float) -> float:\n    # Calculate the area of one equilateral triangle face\n    one_face_area = (3**0.5 / 4) * edge_length**2\n    # Multiply by 4 to get the total surface area of the tetrahedron\n    total_area = 4 * one_face_area\n    # Return the total surface area\n    return total_area\n"}
{"task_id": "Mbpp/743", "solution": "\ndef rotate_right(lst, k):\n    # Calculate the length of the list\n    n = len(lst)\n    \n    # Calculate the effective number of rotations needed\n    k = k % n\n    \n    # If no rotation is needed, return the original list\n    if k == 0:\n        return lst\n    \n    # Return the rotated list by slicing and concatenating\n    return lst[-k:] + lst[:-k]\n"}
{"task_id": "Mbpp/744", "solution": "\ndef check_none(input_tuple):\n    # Iterate over each element in the tuple\n    for element in input_tuple:\n        # Check if the current element is None\n        if element is None:\n            # If a None value is found, return True\n            return True\n    # If no None value is found, return False\n    return False\n"}
{"task_id": "Mbpp/745", "solution": "\ndef divisible_by_digits(startnum: int, endnum: int) -> list:\n    # Initialize an empty list to store numbers that meet the criteria\n    result = []\n    \n    # Iterate over each number in the range from startnum to endnum (inclusive)\n    for number in range(startnum, endnum + 1):\n        # Convert the number to a string to easily access each digit\n        num_str = str(number)\n        \n        # Assume the number is divisible by all its digits until proven otherwise\n        divisible = True\n        \n        # Check each digit in the number\n        for digit in num_str:\n            # Convert the digit back to an integer\n            digit_int = int(digit)\n            \n            # If the digit is 0 or the number is not divisible by this digit, set divisible to False\n            if digit_int == 0 or number % digit_int != 0:\n                divisible = False\n                break\n        \n        # If the number is divisible by all its digits, add it to the result list\n        if divisible:\n            result.append(number)\n    \n    # Return the list of numbers that are divisible by all their digits\n    return result\n"}
{"task_id": "Mbpp/748", "solution": "\ndef capital_words_spaces(s: str) -> str:\n    # Initialize an empty result string\n    result = \"\"\n    \n    # Iterate over each character in the string with its index\n    for i, char in enumerate(s):\n        # If the character is uppercase and it's not the first character\n        if char.isupper() and i != 0:\n            # Add a space before the character\n            result += \" \"\n        # Add the current character to the result\n        result += char\n    \n    # Return the final result string\n    return result\n"}
{"task_id": "Mbpp/749", "solution": "\ndef sort_numeric_strings(lst: list) -> list:\n    # Convert each string in the list to an integer\n    int_list = [int(num) for num in lst]\n    \n    # Sort the list of integers\n    int_list.sort()\n    \n    # Return the sorted list\n    return int_list\n"}
{"task_id": "Mbpp/75", "solution": "\ndef find_tuples(tuples_list, k):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for t in tuples_list:\n        # Check if all elements in the tuple are divisible by k\n        if all(element % k == 0 for element in t):\n            # If true, append the tuple to the result list\n            result.append(t)\n    \n    # Return the list of tuples that meet the criteria\n    return result\n"}
{"task_id": "Mbpp/750", "solution": "\ndef add_tuple(lst: list, tpl: tuple) -> list:\n    # Convert the tuple to a list\n    tpl_as_list = list(tpl)\n    # Concatenate the list with the converted tuple list\n    result = lst + tpl_as_list\n    # Return the resulting list\n    return result\n"}
{"task_id": "Mbpp/751", "solution": "\ndef check_min_heap(arr):\n    n = len(arr)\n    # Iterate over each parent node\n    for i in range((n // 2)):\n        left_child_index = 2 * i + 1\n        right_child_index = 2 * i + 2\n        \n        # Check if the left child exists and violates the min-heap property\n        if left_child_index < n and arr[i] > arr[left_child_index]:\n            return False\n        \n        # Check if the right child exists and violates the min-heap property\n        if right_child_index < n and arr[i] > arr[right_child_index]:\n            return False\n    \n    # If no violations are found, the array is a min-heap\n    return True\n"}
{"task_id": "Mbpp/752", "solution": "\ndef jacobsthal_num(n: int) -> int:\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Jacobsthal numbers\n    prev2 = 0  # J(0)\n    prev1 = 1  # J(1)\n    \n    # Calculate Jacobsthal numbers iteratively\n    for i in range(2, n + 1):\n        current = prev1 + 2 * prev2\n        prev2 = prev1\n        prev1 = current\n    \n    return prev1\n"}
{"task_id": "Mbpp/753", "solution": "\ndef min_k(tuple_list, k):\n    # Sort the list of tuples based on the second element of each tuple\n    sorted_list = sorted(tuple_list, key=lambda x: x[1])\n    \n    # Return the first k elements from the sorted list\n    return sorted_list[:k]\n"}
{"task_id": "Mbpp/754", "solution": "\ndef extract_index_list(l1, l2, l3):\n    # Initialize an empty list to store common elements\n    common_elements = []\n    \n    # Determine the minimum length of the three lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    # Iterate over the indices up to the minimum length\n    for i in range(min_length):\n        # Check if the elements at the current index are the same in all three lists\n        if l1[i] == l2[i] == l3[i]:\n            # If they are the same, append the element to the common_elements list\n            common_elements.append(l1[i])\n    \n    # Return the list of common elements\n    return common_elements\n"}
{"task_id": "Mbpp/755", "solution": "\ndef second_smallest(numbers):\n    # Initialize the first and second smallest numbers to infinity\n    first_smallest = float('inf')\n    second_smallest = float('inf')\n    \n    # Iterate through each number in the list\n    for number in numbers:\n        # If the current number is smaller than the first smallest\n        if number < first_smallest:\n            # Update the second smallest to be the previous first smallest\n            second_smallest = first_smallest\n            # Update the first smallest to be the current number\n            first_smallest = number\n        # If the current number is greater than the first smallest but smaller than the second smallest\n        elif first_smallest < number < second_smallest:\n            # Update the second smallest to be the current number\n            second_smallest = number\n    \n    # Return the second smallest number found\n    return second_smallest\n"}
{"task_id": "Mbpp/757", "solution": "\ndef count_reverse_pairs(strings: list) -> int:\n    # Set to keep track of strings that have been paired\n    paired = set()\n    # Counter for reverse pairs\n    count = 0\n    \n    # Iterate over each string in the list\n    for string in strings:\n        # Check if the string is not already paired\n        if string not in paired:\n            # Reverse the string\n            reversed_string = string[::-1]\n            # Check if the reversed string is in the list and not already paired\n            if reversed_string in strings and reversed_string not in paired:\n                # Increment the counter for a found pair\n                count += 1\n                # Add both the string and its reverse to the paired set\n                paired.add(string)\n                paired.add(reversed_string)\n    \n    # Return the total count of reverse pairs\n    return count\n"}
{"task_id": "Mbpp/758", "solution": "\ndef unique_sublists(list_of_lists):\n    # Initialize an empty dictionary to store tuples and their counts\n    tuple_count = {}\n    \n    # Iterate over each sublist in the input list\n    for sublist in list_of_lists:\n        # Convert the sublist to a tuple\n        tuple_key = tuple(sublist)\n        \n        # Check if the tuple is already a key in the dictionary\n        if tuple_key in tuple_count:\n            # Increment the count of the tuple\n            tuple_count[tuple_key] += 1\n        else:\n            # Add the tuple to the dictionary with a count of 1\n            tuple_count[tuple_key] = 1\n    \n    # Return the dictionary with tuples and their counts\n    return tuple_count\n"}
{"task_id": "Mbpp/759", "solution": "\ndef is_decimal(s: str) -> bool:\n    # Split the string by the decimal point\n    parts = s.split('.')\n    \n    # Check if there are exactly two parts\n    if len(parts) != 2:\n        return False\n    \n    # Check if the first part is a valid integer (can be empty for numbers like .11)\n    if not (parts[0].isdigit() or parts[0] == ''):\n        return False\n    \n    # Check if the second part has exactly two digits\n    if len(parts[1]) != 2 or not parts[1].isdigit():\n        return False\n    \n    # If all checks are satisfied, return True\n    return True\n"}
{"task_id": "Mbpp/760", "solution": "\ndef unique_Element(numbers: list) -> bool:\n    # Convert the list to a set to remove duplicate elements\n    unique_numbers = set(numbers)\n    \n    # Check if the length of the set is 1\n    # If it is, it means all elements in the list are the same\n    return len(unique_numbers) == 1\n"}
{"task_id": "Mbpp/762", "solution": "\ndef check_monthnumber_number(month_number: int) -> bool:\n    # List of month numbers that have 30 days\n    months_with_30_days = [4, 6, 9, 11]\n    \n    # Check if the given month number is in the list\n    return month_number in months_with_30_days\n"}
{"task_id": "Mbpp/763", "solution": "\ndef find_min_diff(arr: tuple, n: int) -> int:\n    # Convert the tuple to a list and sort it\n    sorted_arr = sorted(arr)\n    \n    # Initialize the minimum difference to a large number\n    min_diff = float('inf')\n    \n    # Iterate through the sorted array to find the minimum difference\n    for i in range(n - 1):\n        # Calculate the difference between consecutive elements\n        diff = sorted_arr[i + 1] - sorted_arr[i]\n        \n        # Update min_diff if the current difference is smaller\n        if diff < min_diff:\n            min_diff = diff\n    \n    # Return the smallest difference found\n    return min_diff\n"}
{"task_id": "Mbpp/764", "solution": "\ndef number_ctr(s: str) -> int:\n    # Initialize a counter to keep track of the number of digits\n    digit_count = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Check if the character is a digit\n        if char.isdigit():\n            # Increment the counter if it is a digit\n            digit_count += 1\n    \n    # Return the total count of digit characters\n    return digit_count\n"}
{"task_id": "Mbpp/765", "solution": "\ndef is_power_of_two(x: int) -> bool:\n    # A number is a power of two if it has exactly one bit set in its binary representation\n    return x > 0 and (x & (x - 1)) == 0\n\ndef is_polite(n: int) -> int:\n    # Initialize the count of polite numbers found\n    polite_count = 0\n    # Start checking from number 1\n    current_number = 1\n    \n    # Continue until we find the nth polite number\n    while polite_count < n:\n        # Check if the current number is not a power of two\n        if not is_power_of_two(current_number):\n            # Increment the count of polite numbers found\n            polite_count += 1\n            # If we have found the nth polite number, return it\n            if polite_count == n:\n                return current_number\n        # Move to the next number\n        current_number += 1\n"}
{"task_id": "Mbpp/766", "solution": "\ndef pair_wise(lst):\n    # Initialize an empty list to store the pairs\n    result = []\n    # Loop through the list from the first element to the second-to-last element\n    for i in range(len(lst) - 1):\n        # Create a tuple with the current element and the next element\n        pair = (lst[i], lst[i + 1])\n        # Append this tuple to the result list\n        result.append(pair)\n    # Return the result list\n    return result\n"}
{"task_id": "Mbpp/767", "solution": "\ndef get_pairs_count(numbers, target_sum):\n    # Dictionary to store the frequency of each number\n    frequency = {}\n    # Variable to count the number of pairs\n    pair_count = 0\n\n    # Iterate over each number in the list\n    for number in numbers:\n        # Calculate the complement that would sum with the current number to reach the target sum\n        complement = target_sum - number\n        \n        # If the complement is already in the frequency dictionary, it means we have found pairs\n        if complement in frequency:\n            # Add the frequency of the complement to the pair count\n            pair_count += frequency[complement]\n        \n        # Update the frequency dictionary with the current number\n        if number in frequency:\n            frequency[number] += 1\n        else:\n            frequency[number] = 1\n\n    # Return the total count of pairs\n    return pair_count\n"}
{"task_id": "Mbpp/769", "solution": "\ndef Diff(list1, list2):\n    # Initialize an empty list to store the difference\n    result = []\n    # Iterate over each element in the first list\n    for element in list1:\n        # Check if the element is not present in the second list\n        if element not in list2:\n            # If not present, add it to the result list\n            result.append(element)\n    # Return the list containing elements only in the first list\n    return result\n"}
{"task_id": "Mbpp/77", "solution": "\ndef is_Diff(n: int) -> bool:\n    # Convert the number to a string to access each digit\n    n_str = str(n)\n    \n    # Initialize sums for odd and even positioned digits\n    sum_odd = 0\n    sum_even = 0\n    \n    # Iterate over each digit in the string representation of the number\n    for i, digit in enumerate(n_str):\n        # Convert the character to an integer\n        digit_value = int(digit)\n        \n        # Check if the index is even or odd and update the respective sum\n        if i % 2 == 0:\n            sum_odd += digit_value\n        else:\n            sum_even += digit_value\n    \n    # Calculate the difference between the sums\n    difference = sum_odd - sum_even\n    \n    # Check if the difference is divisible by 11\n    return difference % 11 == 0\n"}
{"task_id": "Mbpp/770", "solution": "\ndef odd_num_sum(n: int) -> int:\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Loop through the first n odd numbers\n    for i in range(n):\n        # Calculate the i-th odd number\n        odd_number = 2 * i + 1\n        # Calculate the fourth power of the odd number\n        fourth_power = odd_number ** 4\n        # Add the fourth power to the total sum\n        total_sum += fourth_power\n    \n    # Return the total sum of fourth powers\n    return total_sum\n"}
{"task_id": "Mbpp/771", "solution": "\ndef check_expression(expression: str) -> bool:\n    # Stack to keep track of opening brackets\n    stack = []\n    # Mapping of closing brackets to their corresponding opening brackets\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    # Iterate over each character in the expression\n    for char in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if char in bracket_map.values():\n            stack.append(char)\n        # If the character is a closing bracket\n        elif char in bracket_map:\n            # Check if the stack is empty or the top of the stack is not the matching opening bracket\n            if not stack or stack[-1] != bracket_map[char]:\n                return False\n            # Pop the top of the stack as it is a matching pair\n            stack.pop()\n    \n    # If the stack is empty, all brackets were matched correctly\n    return not stack\n"}
{"task_id": "Mbpp/772", "solution": "\ndef remove_length(s: str, k: int) -> str:\n    # Split the input string into a list of words\n    words = s.split()\n    \n    # Filter out words that have a length equal to k\n    filtered_words = [word for word in words if len(word) != k]\n    \n    # Join the remaining words back into a single string with spaces\n    result = ' '.join(filtered_words)\n    \n    # Return the resulting string\n    return result\n"}
{"task_id": "Mbpp/773", "solution": "\ndef occurance_substring(main_string: str, substring: str):\n    # Find the starting index of the substring in the main string\n    start_index = main_string.find(substring)\n    \n    # If the substring is not found, find returns -1\n    if start_index == -1:\n        return None\n    \n    # Calculate the ending index of the substring\n    end_index = start_index + len(substring)\n    \n    # Return the tuple with the substring, starting index, and ending index\n    return (substring, start_index, end_index)\n"}
{"task_id": "Mbpp/775", "solution": "\ndef odd_position(lst):\n    # Iterate over the list, checking only the elements at odd indices\n    for i in range(1, len(lst), 2):\n        # Check if the element at the current odd index is not odd\n        if lst[i] % 2 == 0:\n            # If an element at an odd index is not odd, return False\n            return False\n    # If all elements at odd indices are odd, return True\n    return True\n"}
{"task_id": "Mbpp/777", "solution": "\ndef find_sum(lst):\n    # Create a dictionary to count occurrences of each element\n    count_dict = {}\n    \n    # Count each element in the list\n    for element in lst:\n        if element in count_dict:\n            count_dict[element] += 1\n        else:\n            count_dict[element] = 1\n    \n    # Initialize the sum of non-repeated elements\n    sum_of_non_repeated = 0\n    \n    # Sum up elements that appear exactly once\n    for key, value in count_dict.items():\n        if value == 1:\n            sum_of_non_repeated += key\n    \n    return sum_of_non_repeated\n"}
{"task_id": "Mbpp/778", "solution": "\ndef pack_consecutive_duplicates(lst):\n    # Initialize the result list and a temporary list to hold current duplicates\n    result = []\n    temp = []\n\n    # Iterate through each element in the input list\n    for element in lst:\n        # If temp is empty or the current element is the same as the last in temp\n        if not temp or element == temp[-1]:\n            # Add the element to the temp list\n            temp.append(element)\n        else:\n            # If the current element is different, add the temp list to result\n            result.append(temp)\n            # Start a new temp list with the current element\n            temp = [element]\n\n    # After the loop, add any remaining elements in temp to result\n    if temp:\n        result.append(temp)\n\n    # Return the result list containing sublists of consecutive duplicates\n    return result\n"}
{"task_id": "Mbpp/780", "solution": "\ndef find_combinations(tuple_list):\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each tuple in the list\n    for i in range(len(tuple_list)):\n        tuple1 = tuple_list[i]\n        \n        # Iterate over each subsequent tuple to form unique pairs\n        for j in range(i + 1, len(tuple_list)):\n            tuple2 = tuple_list[j]\n            \n            # Calculate the sum of the first elements and the second elements\n            sum_first = tuple1[0] + tuple2[0]\n            sum_second = tuple1[1] + tuple2[1]\n            \n            # Create a new tuple with these sums\n            new_tuple = (sum_first, sum_second)\n            \n            # Append the new tuple to the result list\n            result.append(new_tuple)\n    \n    # Return the list of resulting tuples\n    return result\n"}
{"task_id": "Mbpp/781", "solution": "\ndef count_divisors(n: int) -> bool:\n    # Initialize the count of divisors to 0\n    count = 0\n    \n    # Iterate over each number from 1 to the square root of n\n    i = 1\n    while i * i <= n:\n        # If i is a divisor of n\n        if n % i == 0:\n            # Increment the count for the divisor i\n            count += 1\n            # If i is not the square root of n, increment for the paired divisor\n            if i != n // i:\n                count += 1\n        i += 1\n    \n    # Return True if the count of divisors is even, otherwise False\n    return count % 2 == 0\n"}
{"task_id": "Mbpp/782", "solution": "\ndef odd_length_sum(arr):\n    # Initialize the total sum of all odd-length subarrays\n    total_sum = 0\n    \n    # Iterate over each possible starting index of the subarray\n    for i in range(len(arr)):\n        # Initialize the current sum for the subarray starting at index i\n        current_sum = 0\n        \n        # Iterate over each possible ending index of the subarray\n        for j in range(i, len(arr)):\n            # Add the current element to the current sum\n            current_sum += arr[j]\n            \n            # Check if the length of the subarray is odd\n            if (j - i + 1) % 2 == 1:\n                # If odd, add the current sum to the total sum\n                total_sum += current_sum\n    \n    # Return the total sum of all odd-length subarrays\n    return total_sum\n"}
{"task_id": "Mbpp/784", "solution": "\ndef mul_even_odd(numbers):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list of numbers\n    for number in numbers:\n        # Check if the number is even and we haven't found an even number yet\n        if number % 2 == 0 and first_even is None:\n            first_even = number\n        # Check if the number is odd and we haven't found an odd number yet\n        if number % 2 != 0 and first_odd is None:\n            first_odd = number\n        # If both first even and odd numbers are found, break the loop\n        if first_even is not None and first_odd is not None:\n            break\n    \n    # Return the product of the first even and odd numbers\n    return first_even * first_odd\n"}
{"task_id": "Mbpp/785", "solution": "\ndef tuple_str_int(tuple_str: str) -> tuple:\n    # Remove the parentheses from the string\n    numbers_str = tuple_str.strip(\"()\")\n    \n    # Split the string by commas to get a list of string numbers\n    numbers_list = numbers_str.split(\", \")\n    \n    # Convert each string in the list to an integer\n    numbers = [int(num) for num in numbers_list]\n    \n    # Create a tuple from the list of integers\n    result_tuple = tuple(numbers)\n    \n    # Return the tuple\n    return result_tuple\n"}
{"task_id": "Mbpp/786", "solution": "\ndef right_insertion(sorted_list, value):\n    # Iterate over the list to find the right insertion point\n    for index in range(len(sorted_list)):\n        # If the current element is greater than the value, return the current index\n        if sorted_list[index] > value:\n            return index\n    # If no such element is found, return the length of the list\n    return len(sorted_list)\n"}
{"task_id": "Mbpp/787", "solution": "\ndef text_match_three(text: str) -> bool:\n    # Iterate over the string, checking each substring of length 4\n    for i in range(len(text) - 3):\n        # Check if the current substring matches \"abbb\"\n        if text[i:i+4] == \"abbb\":\n            return True\n    # If no match is found, return False\n    return False\n"}
{"task_id": "Mbpp/788", "solution": "\ndef new_tuple(lst, s):\n    # Convert the list to a tuple\n    tuple_from_list = tuple(lst)\n    # Create a new tuple by adding the string to the tuple\n    result_tuple = tuple_from_list + (s,)\n    # Return the resulting tuple\n    return result_tuple\n"}
{"task_id": "Mbpp/79", "solution": "\ndef word_len(word: str) -> bool:\n    # Calculate the length of the word\n    length = len(word)\n    # Check if the length is odd\n    if length % 2 != 0:\n        return True\n    else:\n        return False\n"}
{"task_id": "Mbpp/790", "solution": "\ndef even_position(lst):\n    # Iterate over the list, checking only even indices\n    for i in range(0, len(lst), 2):\n        # If the number at an even index is odd, return False\n        if lst[i] % 2 != 0:\n            return False\n    # If all numbers at even indices are even, return True\n    return True\n"}
{"task_id": "Mbpp/791", "solution": "\ndef remove_nested(input_tuple):\n    # Initialize an empty list to store non-tuple elements\n    result = []\n    \n    # Iterate over each element in the input tuple\n    for element in input_tuple:\n        # Check if the element is not a tuple\n        if not isinstance(element, tuple):\n            # Append non-tuple elements to the result list\n            result.append(element)\n    \n    # Convert the result list back to a tuple\n    return tuple(result)\n"}
{"task_id": "Mbpp/792", "solution": "\ndef count_list(lists):\n    # Initialize a counter to keep track of the number of lists\n    count = 0\n    # Iterate over each element in the input list\n    for element in lists:\n        # Check if the current element is a list\n        if isinstance(element, list):\n            # Increment the counter if the element is a list\n            count += 1\n    # Return the total count of lists\n    return count\n"}
{"task_id": "Mbpp/793", "solution": "\ndef last(arr, target):\n    # Initialize last_index to -1 to indicate the target is not found initially\n    last_index = -1\n    \n    # Iterate over the array\n    for index in range(len(arr)):\n        # If the current element is equal to the target, update last_index\n        if arr[index] == target:\n            last_index = index\n    \n    # Return the last index where the target was found, or -1 if not found\n    return last_index\n"}
{"task_id": "Mbpp/794", "solution": "\ndef text_starta_endb(s: str) -> bool:\n    # Check if the string starts with 'a' and ends with 'b'\n    if s.startswith('a') and s.endswith('b'):\n        return True\n    else:\n        return False\n"}
{"task_id": "Mbpp/796", "solution": "\ndef return_sum(dictionary: dict) -> int:\n    # Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over all values in the dictionary\n    for value in dictionary.values():\n        # Add each value to the total sum\n        total_sum += value\n    \n    # Return the total sum of all values\n    return total_sum\n"}
{"task_id": "Mbpp/797", "solution": "\ndef sum_in_range(l: int, r: int) -> int:\n    # Initialize the sum of odd numbers to 0\n    total_sum = 0\n    \n    # Iterate over each number in the range from l to r (inclusive)\n    for n in range(l, r + 1):\n        # Check if the number is odd\n        if n % 2 != 0:\n            # Add the odd number to the total sum\n            total_sum += n\n    \n    # Return the total sum of odd numbers\n    return total_sum\n"}
{"task_id": "Mbpp/798", "solution": "\ndef _sum(numbers: list) -> int:\n    # Initialize the sum to zero\n    total_sum = 0\n    # Iterate over each number in the list\n    for number in numbers:\n        # Add the current number to the total sum\n        total_sum += number\n    # Return the computed sum\n    return total_sum\n"}
{"task_id": "Mbpp/799", "solution": "\ndef left_rotate(n: int, d: int) -> int:\n    # Perform left shift on the number by d positions\n    left_shifted = n << d\n    \n    # Perform right shift on the number by (32 - d) positions\n    right_shifted = n >> (32 - d)\n    \n    # Combine the left shifted and right shifted results using bitwise OR\n    # Mask with 0xFFFFFFFF to ensure the result is within 32 bits\n    result = (left_shifted | right_shifted) & 0xFFFFFFFF\n    \n    return result\n"}
{"task_id": "Mbpp/8", "solution": "\ndef square_nums(nums):\n    # Initialize an empty list to store the squares\n    squared_list = []\n    \n    # Iterate over each number in the input list\n    for num in nums:\n        # Calculate the square of the current number\n        square = num * num\n        # Append the squared number to the squared_list\n        squared_list.append(square)\n    \n    # Return the list containing squares of the original numbers\n    return squared_list\n"}
{"task_id": "Mbpp/80", "solution": "\ndef tetrahedral_number(n: int) -> int:\n    # Calculate the nth tetrahedral number using the formula:\n    # T(n) = (n * (n + 1) * (n + 2)) / 6\n    # This formula gives the sum of the first n triangular numbers.\n    return (n * (n + 1) * (n + 2)) // 6\n"}
{"task_id": "Mbpp/800", "solution": "\ndef remove_all_spaces(input_string: str) -> str:\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate over each character in the input string\n    for char in input_string:\n        # Check if the character is not a whitespace\n        if not char.isspace():\n            # Append the character to the result string\n            result += char\n    \n    # Return the result string with all whitespaces removed\n    return result\n"}
{"task_id": "Mbpp/801", "solution": "\ndef test_three_equal(a: int, b: int, c: int) -> int:\n    # Check if all three numbers are equal\n    if a == b and b == c:\n        return 3\n    # Check if any two numbers are equal\n    elif a == b or b == c or a == c:\n        return 2\n    # If no numbers are equal\n    else:\n        return 0\n"}
{"task_id": "Mbpp/803", "solution": "\ndef is_perfect_square(n: int) -> bool:\n    # If the number is negative, it cannot be a perfect square\n    if n < 0:\n        return False\n    \n    # Calculate the integer square root of n\n    root = int(n**0.5)\n    \n    # Check if the square of the root is equal to n\n    return root * root == n\n"}
{"task_id": "Mbpp/804", "solution": "\ndef is_product_even(numbers):\n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the current number is even\n        if number % 2 == 0:\n            # If an even number is found, the product is even\n            return True\n    # If no even number is found, the product is odd\n    return False\n"}
{"task_id": "Mbpp/805", "solution": "\ndef max_sum_list(lists):\n    # Initialize max_sum to a very small number\n    max_sum = float('-inf')\n    # Initialize max_list to None\n    max_list = None\n\n    # Iterate through each sublist in the list of lists\n    for sublist in lists:\n        # Calculate the sum of the current sublist\n        current_sum = sum(sublist)\n        # If the current sum is greater than max_sum, update max_sum and max_list\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    # Return the sublist with the maximum sum\n    return max_list\n"}
{"task_id": "Mbpp/806", "solution": "\ndef max_run_uppercase(s: str) -> int:\n    # Initialize variables to track the maximum run and the current run of uppercase letters\n    max_run = 0\n    current_run = 0\n    \n    # Iterate over each character in the string\n    for c in s:\n        # Check if the character is uppercase\n        if c.isupper():\n            # Increment the current run count\n            current_run += 1\n        else:\n            # Update the maximum run if the current run is greater\n            max_run = max(max_run, current_run)\n            # Reset the current run count\n            current_run = 0\n    \n    # Final check to update the maximum run in case the string ends with an uppercase sequence\n    max_run = max(max_run, current_run)\n    \n    # Return the maximum run of consecutive uppercase letters\n    return max_run\n"}
{"task_id": "Mbpp/807", "solution": "\ndef first_odd(numbers):\n    # Iterate through each number in the list\n    for number in numbers:\n        # Check if the number is odd\n        if number % 2 != 0:\n            # Return the first odd number found\n            return number\n    # If no odd number is found, return None\n    return None\n"}
{"task_id": "Mbpp/808", "solution": "\ndef check_K(tuple_of_numbers: tuple, k: int) -> bool:\n    # Iterate through each number in the tuple\n    for number in tuple_of_numbers:\n        # Check if the current number is equal to k\n        if number == k:\n            # If a match is found, return True\n            return True\n    # If no match is found after checking all numbers, return False\n    return False\n"}
{"task_id": "Mbpp/809", "solution": "\ndef check_smaller(tuple1, tuple2):\n    # Iterate over the indices of the tuples\n    for i in range(len(tuple1)):\n        # Check if the element in the second tuple is not smaller than the element in the first tuple\n        if tuple2[i] >= tuple1[i]:\n            # If any element in the second tuple is not smaller, return False\n            return False\n    # If all elements in the second tuple are smaller, return True\n    return True\n"}
{"task_id": "Mbpp/82", "solution": "\nimport math\n\ndef volume_sphere(radius: float) -> float:\n    # Calculate the volume of the sphere using the formula (4/3) * \u03c0 * radius^3\n    volume = (4/3) * math.pi * (radius ** 3)\n    # Return the calculated volume\n    return volume\n"}
{"task_id": "Mbpp/84", "solution": "\ndef sequence(n: int) -> int:\n    # Base cases for the sequence\n    if n == 1 or n == 2:\n        return 1\n    \n    # Initialize a list to store the sequence values\n    seq = [0] * (n + 1)\n    seq[1] = 1\n    seq[2] = 1\n    \n    # Compute the sequence values from 3 to n\n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    \n    # Return the nth value in the sequence\n    return seq[n]\n"}
{"task_id": "Mbpp/85", "solution": "\nimport math\n\ndef surfacearea_sphere(radius: float) -> float:\n    # Calculate the surface area using the formula 4 * pi * radius^2\n    surface_area = 4 * math.pi * radius ** 2\n    # Return the calculated surface area\n    return surface_area\n"}
{"task_id": "Mbpp/86", "solution": "\ndef centered_hexagonal_number(n: int) -> int:\n    # Calculate the nth centered hexagonal number using the formula\n    # The formula is derived from the geometric pattern of centered hexagons\n    # Formula: 3 * n * (n - 1) + 1\n    return 3 * n * (n - 1) + 1\n"}
{"task_id": "Mbpp/87", "solution": "\ndef merge_dictionaries_three(dict1: dict, dict2: dict, dict3: dict) -> dict:\n    # Create a new dictionary to hold the merged result\n    merged_dict = {}\n    \n    # Update the merged dictionary with the contents of the first dictionary\n    merged_dict.update(dict1)\n    \n    # Update the merged dictionary with the contents of the second dictionary\n    merged_dict.update(dict2)\n    \n    # Update the merged dictionary with the contents of the third dictionary\n    merged_dict.update(dict3)\n    \n    # Return the merged dictionary\n    return merged_dict\n"}
{"task_id": "Mbpp/88", "solution": "\ndef freq_count(lst):\n    # Create an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate over each element in the list\n    for element in lst:\n        # If the element is already in the dictionary, increment its count\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        # If the element is not in the dictionary, add it with a count of 1\n        else:\n            frequency_dict[element] = 1\n    \n    # Return the dictionary containing the frequency of each element\n    return frequency_dict\n"}
{"task_id": "Mbpp/89", "solution": "\ndef closest_num(n: int) -> int:\n    # Subtract 1 from n to get the closest smaller number\n    return n - 1\n"}
{"task_id": "Mbpp/9", "solution": "\ndef find_Rotations(s: str) -> int:\n    # Store the original string for comparison\n    original = s\n    \n    # Iterate over the range from 1 to the length of the string\n    for i in range(1, len(s) + 1):\n        # Rotate the string by moving the first character to the end\n        s = s[1:] + s[0]\n        \n        # Check if the rotated string matches the original string\n        if s == original:\n            # Return the number of rotations needed\n            return i\n"}
{"task_id": "Mbpp/90", "solution": "\ndef len_log(words: list) -> int:\n    # Initialize the maximum length to 0\n    max_length = 0\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Calculate the length of the current word\n        word_length = len(word)\n        \n        # Update max_length if the current word's length is greater\n        if word_length > max_length:\n            max_length = word_length\n    \n    # Return the maximum length found\n    return max_length\n"}
{"task_id": "Mbpp/91", "solution": "\ndef find_substring(list_of_strings, substring):\n    # Iterate over each string in the list\n    for string in list_of_strings:\n        # Check if the substring is present in the current string\n        if substring in string:\n            # If found, return True\n            return True\n    # If the loop completes without finding the substring, return False\n    return False\n"}
{"task_id": "Mbpp/92", "solution": "\ndef is_undulating(n: int) -> bool:\n    # Convert the number to a string to access each digit\n    s = str(n)\n    \n    # If the number has less than 2 digits, it cannot be undulating\n    if len(s) < 2:\n        return False\n    \n    # Get the first two digits\n    first_digit = s[0]\n    second_digit = s[1]\n    \n    # If the first two digits are the same, it cannot be undulating\n    if first_digit == second_digit:\n        return False\n    \n    # Check the alternating pattern for the rest of the digits\n    for i in range(2, len(s)):\n        if i % 2 == 0:  # Even index should match the first digit\n            if s[i] != first_digit:\n                return False\n        else:  # Odd index should match the second digit\n            if s[i] != second_digit:\n                return False\n    \n    # If all checks pass, the number is undulating\n    return True\n"}
{"task_id": "Mbpp/93", "solution": "\ndef power(a: int, b: int) -> int:\n    # Initialize the result to 1, as any number to the power of 0 is 1\n    result = 1\n    # Multiply result by 'a', 'b' times\n    for _ in range(b):\n        result *= a\n    # Return the final result which is a^b\n    return result\n"}
{"task_id": "Mbpp/94", "solution": "\ndef index_minimum(list_of_tuples):\n    # Check if the list is empty\n    if not list_of_tuples:\n        return None\n    \n    # Initialize min_value and min_name with the first tuple's values\n    min_value = list_of_tuples[0][1]\n    min_name = list_of_tuples[0][0]\n    \n    # Iterate over each tuple in the list\n    for name, value in list_of_tuples:\n        # If the current tuple's value is smaller than min_value, update min_value and min_name\n        if value < min_value:\n            min_value = value\n            min_name = name\n    \n    # Return the name associated with the smallest value\n    return min_name\n"}
{"task_id": "Mbpp/95", "solution": "\ndef Find_Min_Length(lists: list) -> int:\n    # Initialize min_length to a large number\n    min_length = float('inf')\n    \n    # Iterate over each list in the list of lists\n    for lst in lists:\n        # Calculate the length of the current list\n        current_length = len(lst)\n        \n        # Update min_length if the current list's length is smaller\n        if current_length < min_length:\n            min_length = current_length\n    \n    # Return the smallest length found\n    return min_length\n"}
{"task_id": "Mbpp/96", "solution": "\ndef divisor(n: int) -> int:\n    # Initialize a counter to keep track of the number of divisors\n    count = 0\n    \n    # Iterate over each number from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # If it is, increment the count\n            count += 1\n    \n    # Return the total count of divisors\n    return count\n"}
{"task_id": "Mbpp/97", "solution": "\ndef frequency_lists(list_of_lists):\n    # Initialize an empty list to store all elements from the sublists\n    flattened_list = []\n    \n    # Flatten the list of lists into a single list\n    for sublist in list_of_lists:\n        for element in sublist:\n            flattened_list.append(element)\n    \n    # Initialize an empty dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Count the frequency of each element in the flattened list\n    for element in flattened_list:\n        if element in frequency_dict:\n            frequency_dict[element] += 1\n        else:\n            frequency_dict[element] = 1\n    \n    # Return the dictionary containing the frequencies\n    return frequency_dict\n"}
{"task_id": "Mbpp/98", "solution": "\ndef multiply_num(numbers):\n    # Initialize the product to 1\n    product = 1\n    \n    # Multiply each number in the list to the product\n    for number in numbers:\n        product *= number\n    \n    # Calculate the length of the list\n    length_of_list = len(numbers)\n    \n    # Divide the product by the length of the list to get the result\n    result = product / length_of_list\n    \n    # Return the result\n    return result\n"}
{"task_id": "Mbpp/99", "solution": "\ndef decimal_to_binary(n: int) -> str:\n    # Special case for zero\n    if n == 0:\n        return \"0\"\n    \n    # Initialize an empty string to store binary digits\n    binary_str = \"\"\n    \n    # Loop until n becomes zero\n    while n > 0:\n        # Get the remainder of n divided by 2 (either 0 or 1)\n        remainder = n % 2\n        # Append the remainder to the binary string\n        binary_str = str(remainder) + binary_str\n        # Update n to be the integer division of n by 2\n        n = n // 2\n    \n    # Return the binary string\n    return binary_str\n"}
